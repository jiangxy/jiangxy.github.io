<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[foolbear的冥想盆]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://jxy.me/"/>
  <updated>2016-12-20T11:24:59.742Z</updated>
  <id>http://jxy.me/</id>
  
  <author>
    <name><![CDATA[foolbear]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[不务正业again]]></title>
    <link href="http://jxy.me/2016/12/07/wx-applet/"/>
    <id>http://jxy.me/2016/12/07/wx-applet/</id>
    <published>2016-12-07T10:06:50.000Z</published>
    <updated>2016-12-20T11:21:25.000Z</updated>
    <content type="html"><![CDATA[<p>又一次不务正业，研究了下微信小程序。</p>
<p>其实微信小程序已经火了好久了。几个月之前内测的时候，很多人就迫不及待去研究，各种破解资料、教程满天飞。公司内部也专门组织人去学习了下。<br>可惜当时我事情比较多，只是打了个酱油，等公测开始才真正去研究了下。<a href="https://github.com/jiangxy/wxapplet-canvas-demo" target="_blank" rel="external">写了个简单的小游戏</a>，算是对小程序有了个大概的了解。话说最好的学习方式果然还是实践。古人云：“纸上得来终觉浅，须知此事要躬行”。</p>
<p><strong>本文不是一个教程</strong>，只是总结下学习过程中的感想。</p>
<a id="more"></a>
<h1 id="初印象">初印象</h1>
<p>其实最早的传闻，是微信要做一个叫“服务号”的东西，老大说要我们关注下，但完全没有头绪，网上也没有啥靠谱的资料。</p>
<p>题外话，我一直觉得微信的生态好复杂，订阅号/服务号/企业号傻傻分不清楚，公众平台/开放平台到底是啥关系，工作中碰到各种openId/unionId、各种授权的问题也总是会晕。而且这个生态特别封闭，自成体系，微信会管的很多，比如外链的限制、对外部接口的限制等等。这倒是和appstore有点像。<br>在这种封闭的生态中做开发，其实挺难受的。。。但生态封闭、开发难受，用户体验就能得到保证。参考ios vs android。而且，能做出这样一个生态真是挺NB的，不得不服。</p>
<p>另外，总有人纠结HTML5 vs H5，我觉得这种纠结很无聊啊。写作<code>HTML5</code>就比<code>H5</code>高大上了？有人看到H5就一定要去纠正一下：“你这样是不对的，应该是<code>HTML5</code>，H5是中国人自己发明的叫法”，以此彰显自己的专业。知乎上这种风气尤甚。你咋不说茴字有四种写法呢╮(╯_╰)╭？嘛，你们开心就好，我反正是个二手前端，图省事一般都叫做H5。</p>
<p>小程序的<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/structure.html?t=20161122" target="_blank" rel="external">结构</a>还是比较简单的，无非是<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/?t=20161122" target="_blank" rel="external">WXML</a>和<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html?t=20161122" target="_blank" rel="external">WXSS</a>解决视图层的问题，JS解决逻辑层的问题。WXML和WXSS可以认为是HTML和CSS的方言，只是有些特殊的限制，其实经过编译之后还是HTML和CSS。这套逻辑和各种概念早就被各种JS的MVVM框架玩烂了，实在没啥新鲜的。<br>WXML除了常规的数据绑定/模版/引用等概念，值得注意的是<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/event.html?t=20161122" target="_blank" rel="external">事件绑定</a>，和普通的HTML不同，不过用起来挺顺手的。<br>WXSS和CSS没啥区别，写起来还是一样的痛苦。。。我本来还期望着微信能有什么方法解决布局的问题，释放二手前端生产力。。。为啥前端一直没有一种可视化的布局工具嘞？像若干年的VB6一样，拖拖拽拽就能搭出一个页面。mac上有个软件<a href="http://www.maczapp.com/sparkle-pro-visual-web-design" target="_blank" rel="external">Sparkle</a>实现了类似的想法，可是不太好用。</p>
<p>因为我之前有研究过一点React，于是学习小程序的过程中总是会不自觉的和React对比。小程序也确实和React有点像。比如<code>setData</code>明显就是抄的<code>setState</code>，还有组件化/生命周期等概念。但用户无法自定义组件是一大问题，而且只有页面级别的组件，也许这是微信为了降低开发复杂度而做的妥协吧。<br>应该说，页面是唯一的“容器组件”，所有的状态都在页面组件中。另外<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html?t=20161122" target="_blank" rel="external">页面路由</a>的管理也真是很迷。。。经常有些诡异的状况出现。</p>
<p>在视图层，微信提供了一些可用的<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/?t=20161122" target="_blank" rel="external">基础组件</a>，这些应该被称为“UI组件”（感觉是脱胎于<a href="https://mp.weixin.qq.com/wiki/2/ae9782fb42e47ad79eb7b361c2149d16.html" target="_blank" rel="external">WeUI</a>），最大意义在于提供统一的视觉风格，跟React的组件不是一个概念。还不是很完善，尤其是对比Ant Design之类的。不知道什么时候会有小程序的第三方UI KIT。</p>
<p>小程序在WXML中绑定数据的逻辑又和angular有点像。不过我挺喜欢<a href="http://mustache.github.io/" target="_blank" rel="external">Mustache</a>的语法的，有点像jsx表达式，但区别也很多。<br>WXML中的模版概念，感觉也是从angular中搞过来的。</p>
<p>总的来说，小程序开发框架（传说这个框架名字叫MINA？）就是个大杂烩，吸收了各种JS框架的理念，同时加入一些自己<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/?t=20161122" target="_blank" rel="external">特有的API</a>（我要吐槽微信的canvas API真是超难用，跟标准的canvas完全不一样，让我找到了小学用logo语言画图的感觉。。。）。<br>如果你之前使用过一些MVVM框架，那小程序完全没啥学习成本，直接就能上手。<br>就算之前没有接触过，相对于让人望而生畏的厚厚一本《Angular JS实战》/《深入React技术栈》，小程序对新手无疑也要友好很多。</p>
<h1 id="一些思考">一些思考</h1>
<p>由于工作原因，我接触过一些<a href="https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html" target="_blank" rel="external">JS-SDK</a>。在我看来，使用了JS-SDK的H5页面已经可以很接近原生app的体验了，可以调用各种原生app的能力，除了慢点。参考微信自带的理财通。</p>
<p>那问题来了，微信小程序就是加强版的JS-SDK么？小程序和普通的H5区别在哪里？为啥微信要再造个轮子？</p>
<p>我的感觉：<br><strong>1.运行时&amp;效率的不同</strong><br>这是最重要的区别。之前有消息说小程序使用了ReactNative。我以为是编译成native代码执行，但目测不是啊。摘自微信官方文档：</p>
<blockquote>微信小程序运行在三端：iOS、Android 和 用于调试的开发者工具<br><br>在 iOS 上，小程序的 javascript 代码是运行在 JavaScriptCore 中<br>在 Android 上，小程序的 javascript 代码是通过 X5 内核来解析<br>在 开发工具上， 小程序的 javascript 代码是运行在 nwjs（chrome内核） 中</blockquote>

<p>看来小程序的代码还是要有一个JS运行时环境去支持的。但微信应该有做过一些优化，坊间传言视图层（WXML中的块级元素）的渲染都是native的。否则打开微信小程序=扫码打开一个网页，那也太low了吧。。。至于是否有其他优化策略，还不得而知。<br>而普通的H5么，因为是用浏览器打开，效率明显会低一些。iOS上微信会调用系统自带的浏览器内核，Android上会使用内嵌的QQ浏览器X5内核（所以一直被吐槽是手机上的IE6）。</p>
<p><strong>2.简化&amp;规范开发流程，约定大于配置</strong><br>相比开发一个H5页面，开发一个小程序的难度是很低的。摘自微信官方文档：</p>
<blockquote>小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。</blockquote>

<p>如果想用H5+JS-SDK实现类似于原生APP的体验，无疑是超级麻烦的，光是各种设备的适配就能搞个半死。。。而且使用标准的HTML时，要去关注很多跟业务逻辑无关的东西，比如各种<code>&lt;meta&gt;</code>标签、<code>&lt;script&gt;</code>的顺序、CSS属性的各种特定前缀之类的。<br>而小程序将这些复杂的事情都交给框架去做，同时对工程结构做了很多约定，简化了开发流程。从某种意义上说，JS-SDK只是个“工具”，而小程序才是真正的“框架”，就是jquery和react的区别。<br>这也是所谓的DRY原则。</p>
<p><strong>3.重新整合微信特有的API</strong><br>小程序提供了各种微信特有的API，比如登录/微信支付/照片/设备信息等等。我对比了下JS-SDK提供的API，发现二者是互相交叉的，小程序去掉了JS-SDK中很多用不到的API，而且小程序的API也好用很多。或者说，原来的JS-SDK的API设计的太烂了。。。用过的没有不吐槽的。</p>
<p>不过小程序应该也从JS-SDK借鉴了很多经验。</p>
<p><strong>4.增加对生态的控制力</strong><br>微信的生态一直是封闭的。而H5很难控制，你不知道一个页面是做什么用的，打开之后会发生什么，请求哪些服务端，也很难封杀。同样的页面内容，完全可以换个马甲就出来了。。。从战略上来说，对整个生态是不利的。<br>而小程序请求哪些域名、能做什么事、呈现什么内容，可以说完全在微信的控制之下。尤其是上架还要经过审核，想改就改，想封杀就封杀。越来越像老大哥了啊。。。对于所有的权利集团而言，当然是权利越集中对自己越有利啊。</p>
<p><strong>5.渠道的问题</strong><br>微信小程序的入口现在还不清楚。有说是二级菜单的，有说是像公众号一样的，甚至有说可以直接放在系统桌面的（估计只有android能做到这种吧，桌面widget）。不过不管怎样，相比只能在朋友圈里以url形式传播的H5页面，小程序的渠道肯定更丰富吧，离用户更近，也就更容易获得流量。</p>
<p>说到底，大家为什么这么看好小程序，还不是因为微信巨大的流量，9亿的注册用户，5亿的月活，还自带社交渠道的推广属性，怎么想都是很诱人。关键就看腾讯爸爸怎么分配入口和流量了。。。如果能拿到更核心的社交关系数据，想象空间更是无限大，不过这个腾讯肯定是不会给的，毕竟隐私策略也是个大问题。</p>
<p>个人感觉，小程序的关键在于“小”。小就意味着简单：开发简单，不需要投入太多；使用简单，用户进入后很快找到需要的功能，不会有太多的干扰因素；功能上也应该简单，即开即用，用完就走，不需要有什么顾虑。很多公司开发小程序，就是把自己已有的APP原样照搬过去，俺对此持保留意见。。。<br>感觉上，用户在打开一个小程序之前，就应该知道要干什么，知道要打开哪个程序。程序被打开后，让用户做完想做的事就可以了，而不要提供各种乱七八糟的额外功能。小程序应该专注于特定的本职功能。<br>所以我觉得一些工具类/游戏类的小程序会比较契合主题，一些“大而全”的小程序反而是理念有问题。可以参考下小程序的<a href="https://mp.weixin.qq.com/debug/wxadoc/design/index.html?t=20161109" target="_blank" rel="external">设计指南</a>。</p>
<p>还有啊，为啥大家默认小程序就是H5页面？各种视觉、交互都是按照网页的风格去设计，很多原来的在线H5设计工具，改一改就号称是小程序在线设计了。。。如果打开小程序就等于是打开了一个浏览器，那还有啥意思。<br>我理想中的小程序，应该是体验和native app一样的，用户打开app时，不应该明显的感觉到从app进入到了一个网页。用户都不傻的，“画风突变”还是能分别出来的。<br>我在使用一些APP时，碰到这种画风突变的情况，也会很蛋疼。。。不管你背后的技术是native还是H5还是hybird，至少体验要一致吧。</p>
<p>小程序一出来，很多人就叫嚣着“H5要取代app”，“H5开发需求要爆发”，“微信将统一所有APP”，“ios/android开发要失业”。。。嗯，开心就好。。。<br>这让我想到Facebook Messenger刚推出<a href="https://developers.facebook.com/docs/messenger-platform/product-overview" target="_blank" rel="external">Bot平台</a>时，大家也是各种激动，号称以后各种APP都将消亡，很多用户需求都将在Bot上满足，人工智能将迎来春天。甚至Bot上将形成自己的appstore。<br>乐观是好的，但忽悠人就不对了。客观的说，冲击肯定是有的，但说取代APP还为时过早。微信对APP的冲击从公众号时代就开始了。现在我们试水一个新业务，很多都是先做一个公众号而不是APP。至于小程序会带来哪些改变，谁知道呢，上帝的归上帝，凯撒的归凯撒吧。对个人而言，多关注些业界，多了解些技术总是不会错的，但也没必要过度反应。</p>
<p>之前不是也有好多人担心微信能不能过appstore审核。如果微信小程序真的能发展到威胁appstore的程序，苹果也不会坐视不理吧。之前为啥ios封杀flash，安全/性能只是一方面，更大的原因是flash“不受控”，adobe完全可以在flash上发展出自己的生态，flash生态中的应用/用户/数据，都完全不受控制。</p>
<p>不管怎样，拭目以待吧。</p>
<h1 id="Hybird">Hybird</h1>
<p>我对APP开发的经验是0，仅有的一点点经验来自React Native。但平常跟各个APP的同学打交道还是比较多的，也知道一些概念。对Hybird这个概念一直比较模糊，正好顺道google下。</p>
<p>Hybird也就是所谓的混合开发，一个APP中，部分使用native实现，部分使用H5实现。一般而言展示性强的页面偏向于H5，功能性强的页面偏向于native。但也没有定式。好处嘛就是降低开发成本，但出现问题调试也比较麻烦。<br>我以前一直以为所谓的Hybird APP就是一个浏览器。。。所有的页面都是H5的，app本身只负责提供一些底层的接口。看了<a href="http://www.infoq.com/cn/articles/hybrid-app-development-combat" target="_blank" rel="external">这篇文章</a>才知道，Hybird也分很多种，H5甚至可以只负责局部的渲染。</p>
<p>感觉上，React Native应该不算Hybird吧，毕竟它是编译成原生代码。有点像编译型语言和解释型语言的区别。</p>
<p>H5和native通信的组件被称为JsBridge，但似乎没有一个标准的规范？各家APP都有自己的实现，个人没事也可以写一个玩，基本就是在原生的WebView上各种hack，拦截H5页面请求的一些特殊的url（比如<code>weidian://methodName?k1=v1&amp;k2=v2</code>）再做出相应的处理。微信的JS-SDK调用native API也是同样的道理。<br>通过JS调用java方法，想想还是挺带感的。。。</p>
<p>话说，我最早记住的Hybird开发工具是<a href="https://www.xamarin.com/" target="_blank" rel="external">Xamarin</a>，忘了是从哪里看到的了。我一看这名字，“厦门人”，哎呦有个性啊。。。</p>
<h1 id="参考资料">参考资料</h1>
<p>小程序现在不需要去看第三方的破解资料了，直接看<a href="https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=20161122" target="_blank" rel="external">官方文档</a>就好。</p>
<p>腾讯云的小程序解决方案，能解决很多问题，session/websocket/https证书/域名之类的，但要有内测资格才能使用，而且收费：<br><a href="https://www.qcloud.com/solution/la.html" target="_blank" rel="external">https://www.qcloud.com/solution/la.html</a><br><a href="https://github.com/tencentyun/weapp-solution" target="_blank" rel="external">https://github.com/tencentyun/weapp-solution</a></p>
<p>两个用于小程序界面设计的在线工具：<br><a href="http://www.coolsite360.com/wxapp/" target="_blank" rel="external">http://www.coolsite360.com/wxapp/</a><br><a href="http://jisuapp.cn/" target="_blank" rel="external">http://jisuapp.cn/</a></p>
<p>一个小程序论坛，有很多开源代码：<br><a href="https://weappdev.com/" target="_blank" rel="external">https://weappdev.com/</a></p>
<p>对小程序比较透彻的分析：<br><a href="https://github.com/phodal/weapp-quick" target="_blank" rel="external">https://github.com/phodal/weapp-quick</a></p>
<p>一个比较好的小程序教程：<br><a href="https://segmentfault.com/a/1190000007033827" target="_blank" rel="external">https://segmentfault.com/a/1190000007033827</a></p>
<p>两个纯用canvas做的小游戏，当作canvas入门挺好的：<br><a href="https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript</a><br><a href="http://www.w3schools.com/graphics/game_intro.asp" target="_blank" rel="external">http://www.w3schools.com/graphics/game_intro.asp</a></p>
<p>CSS布局教程，对我这样CSS苦手的人是一大福音：<br><a href="http://zh.learnlayout.com/toc.html" target="_blank" rel="external">http://zh.learnlayout.com/toc.html</a></p>
<h1 id="碎碎念">碎碎念</h1>
<ol>
<li>JS真是无所不在，不光能写移动端的，还能写桌面端的。。。微信官方的开发工具其实就是个react应用，见<a href="https://www.phodal.com/blog/weapp-demo-process-webkit-app/" target="_blank" rel="external">这篇文章</a>的分析。这种技术被称为<a href="http://nwjs.io/" target="_blank" rel="external">node-webkit</a>，感觉就是桌面版的Hybird啊，有空研究下。</li>
<li>canvas是个好东西。理论上在canvas中可以做任意事情，发挥自己的想象力。Flipboard甚至搞出个<a href="https://github.com/Flipboard/react-canvas" target="_blank" rel="external">react-canvas</a>，所有UI都在canvas上绘制，真是有毅力。据说是为了避免DOM的性能问题？有空研究下。</li>
<li>强烈要求微信改进开发者工具，至少要可以自定义背景色和字体，白背景看得眼睛好痛。而且字体也太小了，也不支持html/css的格式化。</li>
<li>最近手贱<code>rm -rf /</code>了一下。。。这种事我一直是当作段子来看的啊，没想到居然会发生在我身上。看来不能高估自己的san值。</li>
<li>无论什么语言、框架、工具，甚至无论什么事情，生活中/工作上，<strong>想象力</strong>都是最重要的，它决定了一个人的上限。做出有想象力的作品是很难的，只会循规蹈矩很难有出路。为啥会有这个感慨呢，因为组里有个树莓派，在想能拿来干点啥。。。google的过程中惊叹于各种神奇的作品。有时候脑洞大点真不是坏事。</li>
<li>最近稍微看了些<a href="https://zh.wikipedia.org/wiki/%E5%B0%BD%E7%AE%A1%E5%8E%BB%E5%81%9A" target="_blank" rel="external">GTD</a>相关的东西，在想要不要搞下“规范的”时间管理。这种方法论呢，<a href="http://www.mifengtd.cn/articles/do-you-need-a-complete-gtd.html" target="_blank" rel="external">没有定式</a>，不要沦为单纯的使用工具，适合自己的才是最好的。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>又一次不务正业，研究了下微信小程序。</p>
<p>其实微信小程序已经火了好久了。几个月之前内测的时候，很多人就迫不及待去研究，各种破解资料、教程满天飞。公司内部也专门组织人去学习了下。<br>可惜当时我事情比较多，只是打了个酱油，等公测开始才真正去研究了下。<a href="https://github.com/jiangxy/wxapplet-canvas-demo" target="_blank" rel="external">写了个简单的小游戏</a>，算是对小程序有了个大概的了解。话说最好的学习方式果然还是实践。古人云：“纸上得来终觉浅，须知此事要躬行”。</p>
<p><strong>本文不是一个教程</strong>，只是总结下学习过程中的感想。</p>
]]>
    
    </summary>
    
      <category term="小程序" scheme="http://jxy.me/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[壹〇二四]]></title>
    <link href="http://jxy.me/2016/10/24/1024-festival/"/>
    <id>http://jxy.me/2016/10/24/1024-festival/</id>
    <published>2016-10-24T14:22:19.000Z</published>
    <updated>2016-11-06T09:03:39.000Z</updated>
    <content type="html"><![CDATA[<p>据说今天（2016-10-24）是程序员的节日？不过没啥过节的气氛嘛，大家还是该干啥干啥。<br>懒得想题目了，随便借用一下。题目这种东西嘛，不是很重要，反正是无主题随意吐槽。<br>不过1024是开篇的日子，等写完估计是十一月了。。。</p>
<a id="more"></a>
<h1 id="PM小课堂？">PM小课堂？</h1>
<p>最近在持续跟进一些项目，每天都是鸡飞狗跳的，搞的自己心力交瘁。。。过程中发现了各种槽点，不吐不快。我的观点未必是对的，只是总结下自己的想法。</p>
<p>首先明确项目中的几个角色：需求方，就是使唤你干活的人，上至CEO下至运营都可能是需求方；产品，通称PD（似乎这是阿里系的叫法），负责细化需求，把控产品走向，通俗点说就是写PRD的人；技术，根据PRD出技术方案并实现，一般每个项目会有一个技术方面的负责人，通称PM，负责推进整个项目的进度。注意这里的PM指的是“项目管理”，而不是“产品经理”。其他角色还有交互、视觉、测试、运维之类的，暂时按下不表，因为他们一般不是专职针对某个项目，不会背相应的KPI，而只是给项目“打工”。<br>简单点来看，项目的进行过程就是需求方 vs PD vs PM的三方角力。</p>
<p>PM一般是开发来做，因为能比较好的把控全局。如果让一个非技术的人来做PM，可能会比较惨，容易被人忽悠。。。PM不需要了解所有的技术细节，但至少要知道大概，整体的技术方案都需要他来把控。<br>PM的工作职责是啥？如果说的官方一点：把控开发进度/及时处理风险/和各方沟通/保证按时交付之类的。但这都是正确的废话，真实答案就是——啥都要干，PM的工作没有边界，只要是跟项目相关的，可能影响进度的，都需要你去搞定。要会编码，会催进度，更要会撕逼。于是我的日常大概是这样的：<br>“你这边进度怎么样啊，有没有啥问题”<br>“这里体验不好，修改下”<br>“这个数据还没好？我去找相关的人，明天给你搞好”<br>“这个改造的方案，我们一起找XX看下”<br>“用户说有bug？你在哪里我去看下”<br>每天跑来跑去，找各种各样的人，解决各种奇奇怪怪的杂事。任何问题都会找到我，用户有问题我要解答，其他系统接入我要去对接，视觉进度慢我要去催，联调有问题也要我想办法。。。很难有整块的时间去写代码，往往要等到下班了，没人找我了，才能写自己的代码。要不怎么说每天都是鸡飞狗跳呢。。。</p>
<p>为啥会这样？因为如果项目延期/失败了，锅一定是PM的，这个逃不掉。需求方都是大老爷，当然不能背锅；至于PD，要看项目的不同，有些项目中PD主导的比较多，也有些项目中PD就是个打工的，帮你写文档而已，所以PD可能背锅也可能不背；视觉/交互/测试也没有背锅的理由，人家只是帮忙的；只有PM的锅，是绝对逃不掉的。</p>
<p>所以PM确实要去操心各种琐碎的事情，因为这是PM的职责。我作为项目对外对内的唯一接口人，对外要保证各种问题/bug/需求得到及时处理，就算不能立刻搞好也要有个回复，给出时间点，有点类似运维。。。对内要保证成员工作进度，不至于block，解决他们的任何问题，保证技术上整个流程是通的。很多时候我要先有技术方案，然后告诉他们如何去做。如果技术方案不通，我要负责找各种人，想出可行的方案。</p>
<p>如果说项目是一艘航行的船，一般来说PD就像船长，要负责船在驶向正确的方向；而PM就像大副/管家，要负责船上的人往同一个方向划水，才能形成合力。不至于有的人向左有的人向右，船就只能原地打转。如果你身兼PD&amp;PM，那就呵呵了，只能自求多福。<br>而且不得不说，很多人都是不催就不会动的，完全没有自己是项目中一员的自觉，一副事不关己的态度。就好像船已经漏水，你拼命往岸边划，船上其他人却在一边吃瓜一边围观，间或给你叫个好加个游。。。</p>
<p>更悲催的是，往往你手上不会只有一个项目，而是多个项目并行。。。如何协调，如何排期，这就是考验你智商/情商的时刻了。这比研究hadoop难多了好嘛。</p>
<p>既然已经是PM了，职责已经逃不掉了，能不能让自己更舒服些呢？我胡乱总结了下：</p>
<ul>
<li>善用制度和工具。根据项目的不同，适当使用评审/周会/文档/jira/wiki等方法，但千万不要生搬硬套，要根据项目的特点。人越多的项目越需要各种制度的约束，如果只是几个人的小项目，制度反而会带来额外的负担。一般来说，定期的周会/周报就能解决很多问题了，要让大家养成定期总结、定期review的习惯，提需求/提问题/吐槽都尽量集中到周会上，而不要随时随地提，搞的很烦。</li>
<li>善用工具保证开发质量。其实这条和上一条差不多的，但是专门针对开发而言。比如单元测试、代码静态检查、code review、持续集成、完善的发布系统、遵循统一的git分支模型等，反正尽量不要出现低级bug。曾经有同学代码编译不过都敢提交，也是醉了；还有同学合并分支时，把另一个分支上的修改全部抛弃了。。。出现一些业务逻辑上的bug可以忍，这种低级bug不能忍。同样也是要根据项目的情况去选用的。其实这里有个悖论，就是“NB的个人 vs 完善的制度”。如果团队能力足够强，可能不需要额外的措施去保证质量。据说amazon里各种系统/制度非常完善，就是因为它里面新人开发很多？总之要自己权衡。</li>
<li>规划好自己的时间。因为会有各种各样的人“打上门来”，如果碰到问题立刻就去解决，很快就会疲于奔命。可以了解下<a href="http://www.jianshu.com/p/6355411392e6" target="_blank" rel="external">四象限法</a>，合理安排各个事情的优先级。我现在啊，就有点像是一个MQ，你有问题过来了，我会先ack一下，确认收到，然后消息暂存，但不保证什么时候去消费。。。现在就是一个异步处理，处理完成去调你的callback。。。另外，现在也越来越离不开便签之类的东西了，事情太多太杂，只凭脑子根本记不住。</li>
<li>拒绝二手需求，从我做起。啥叫二手需求？<strong>老板和PD说，我要A；PD和我说，老板要A、A+、AAA、∀、Å、Д。。。</strong>看着好像都是A，但已经偏离原始需求很多了，就是蜗牛跟天牛的区别。所以啊，千万别傻乎乎的直接开始编码了，要真正的坐下来和需求方聊下，看下真实的需求是什么样的。“这是老板要的”似乎就是尚方宝剑，也是一些PD的护身符，似乎这句话一说所有人都只能乖乖听话。。。但很可能只是拿着鸡毛当令箭罢了。</li>
<li>拒绝一句话需求。其实是拒绝所有模糊的需求。有运营跟我说，“这个页面我们要改下，突出商品属性”，然后就问我什么时候改好。我tm怎么知道你要怎么突出啊？字体加粗？改背景色？大图？多图？倒是说清楚啊。对于这种需求，只能拜拜了您呐。另外一种常见的需求就是“和XXX一样就可以了”，这tm也是个坑。以前电商很火热的时候，各个小公司都想做自己的电商网站。一问需求，“和淘宝一样就可以了”。。。</li>
<li>拒绝“伪需求”。其实很多需求都是需求方一拍脑袋就提出来的，三分钟热度而已。我见过很多，“这里帮我改一下吧，不改要死了啊”/“想想办法，必须要上的啊”/“不就这里加个图片么”，更有甚者甚至语带威胁，不改就如何如何。当初需求评审/视觉评审的时候怎么不说？我废了很多口舌去解释，他们翻来覆去就是那句话“要改，不改不行”。结果呢，放置一段时间再问，“那就下期再改吧”/“那就当bug修复吧”/“不改也可以”。。。</li>
<li>别怕闹事，该吵就要吵。PM是要代表项目组去和各方PK的，摩擦在所难免，尤其是涉及到和其他组的一些利益分割时。这种情况下，独善其身是不可能的，怎么办，只能硬着头皮上了啊。有句话怎么说的，“没事别找事，有事别怕事”。关键时刻要敢于邮件@所有人，拉更多的人进来一起撕，最后总会有个结果的。不过就像我之前说的，大多数人负责，就等于是没人负责。对项目整体而言未必是好事。</li>
<li>Keep Calm。PM可能会碰到很多让人气愤的事，你有时会忍不住想说去年买了个表，尤其是有些人一副居高临下的态度找到你，“老子怎么说你就怎么做我才是大爷”时。要么放置play，要么就只能撕起来了。但吵架只是一种态度而已，真为这种事生气就很傻了。NBA里的教练为啥会冲过去找裁判理论然后吃T？难道他真的生气？其实有很大的表演成分在里面，给裁判施加压力而已，表明态度“我很生气你丫判罚尺度注意点这tm是我主场”。PM同理，所以好的PM都是很腹黑的么。。。</li>
<li>明确自己的边界。知道哪些是自己的系统该做的，哪些是应该交给其他外部系统的；哪些是现在该做的，哪些可以留到下期。不能所有的需求不加思索就吞下。是否会破坏系统已有的结构？是否有特殊的业务逻辑在里面？</li>
<li>不要高估别人的下限，敬nc而远之。和这种人辩论一定会输，因为他们听不进去你说的任何话，只会翻来覆去讲自己的道理，复读机一样，任何摆事实讲证据的逻辑都是无效的。但是他们又会崇拜“权威”，甚至可以说是跪舔。。。所以不得不撕的话，一定要拉上他们老大。。。</li>
</ul>
<p>PM是个挺锻炼人的活，你会见到形形色色的人，碰到各种各样的事。<br>最大的收获是，我以为我情商已经够低了，没想到有人比我还低，顿时觉得生活又充满了希望啊。。。</p>
<h1 id="50th_&amp;_100000">50th &amp; 100000</h1>
<p>写这篇文字的时候，突然意识到这是我的第50篇blog。于是写了段程序统计下字数（只计算汉字），正好是10w字多一点，算上这篇估计有11w了吧。能坚持下来敲这么多文字，还是有点开心的。</p>
<p>其实写blog的初衷很简单，我希望把工作相关的事情都沉淀下来，回头看自己过去几年的时候，不至于觉得虚度光阴。而且一些技术点记录下来，也方便自己以后查找。<br>大多数文章，都是以前在网易的时候写的，很多是纯技术向的。那时候工作内容比较“单一”，安心研究hadoop就好了，顺带着各种大数据技术都了解了下，真的是两耳不闻窗外事。在网易的几年最大的收获是培养了一种技术上的“素养”或者说“习惯”、“思维方式”，这种感觉很难说的清。离职后，各种杂事多了起来，更新频率大大降低，而且各种吐槽也多了起来，越来越不正经。。。不过至少开阔了眼界，了解了各种业务上的东西。</p>
<p>偶然的机会，google到自己以前的文章，突然有点伤感。以前俺还是个严肃的人啊，写各种技术文章，厚着脸皮说质量还算可以吧。。。也能帮到一些人。但最近越来越有玩票的感觉，其实有点怕。。。技术这种东西呢，不进则退。如果不能在某个领域深耕，那个人价值在哪里？在不同的业务逻辑上一遍遍重复着同样的技术？那还有啥意思啊。最近面试了几个工作7、8年的人就是这种情况，毫无悬念的挂掉了。。。<br>旁边搜索的同学在研究ES，我也很口水啊。身不能至心向往之。</p>
<p>如何从繁杂的日常事务中抽身去研究一些东西，真是一个很难的问题，精力终究有限。而且我所说的研究不是那种跑个docker，搭个kafka就好像自己掌握了宇宙真理一样，然后到处吹逼，这些人没听说过奈何姓万的故事么？研究一门技术/工具/系统，最重要的是掌握原理，其次是使用场景、可能遇到的问题，能深入到代码最好。有些同学天天git push/git pull就号称“熟练使用git”，分支怎么合并都不知道好意思么。。。<br>而且仅凭个人兴趣的研究和公司层面所支持的研究，能达到的高度是完全不同的。就像我如果业余去研究下Lucene，也能大概了解原理，说不定还能看看源码，但应用起来肯定还是一堆坑，跟搜索那边天天搞这玩意的同学根本没法比。又比如hadoop，如果不是有一线的运维经验，很多坑你根本想象不到。坑这种东西，不是看代码能看出来的。</p>
<p>不过反过来想想，“业务”和“技术”根本不是对立的，二者应该是相互驱动的。良性的循环是业务需求催动技术水平的提升，技术的提升又反过来给业务更多想象空间，这种循环的典型就是bigdata；恶性的循环就是业务半死不活，技术毫无成长。如何进入良性循环才是每个人都要思考的。<br>当然有人说可以纯搞技术，不沾任何业务逻辑，比如DBA、比如运维、比如各种中间件。如果能有这种外部环境，公司能提供一个良好的氛围/待遇/考核制度，我举双手双脚赞成，其实我tm也想这样。。。如果可以安心搞研究还照样发薪水，每天的工作就是往开源社区提交feature/patch，公司鼓励你成为contributor/committer，根据你对社区的贡献设定KPI，我可能立刻就会跑过去投简历。。。但就我看到的公司而言，大都是业务驱动的。哪个部门手里有业务，哪个部门就有发言权，就更强势，其他部门负责支撑性的工作，也负责背锅。。。这跟公司的“基因”真的关系很大，是业务导向还是技术导向。<br>而且就算某些公司能提供这种环境，这种赔本赚吆喝的事又能持续多久呢？毕竟公司是要赚钱才能活下来的，有多少公司愿意养着一个不产生收益，纯研究性质的部门？就算养了这样一个部门，这个部门的待遇和其他部门是一样的么？前段时间有个<a href="https://www.zhihu.com/question/27598510" target="_blank" rel="external">知乎帖子</a>也讨论过这个问题。</p>
<p>好像扯远了。。。本来是在说个人成长。但个人成长这个问题真的很复杂，我上面发了这么多牢骚，其实也没有答案，只能不断摸索吧。</p>
<p>anyway，至少我还没有停止思考。<br>但行好事，<del>莫问</del>略问前程。</p>
<h1 id="又是校招季">又是校招季</h1>
<p>赵忠祥老师：<del>春天</del>秋天到了，万物<del>复苏</del>了，这是个校招的季节。。。</p>
<p>前段时间校招如火如荼，各种改卷子、面试，曾经一天之内电面了7个同学，稍微总结下感想。</p>
<p>总的印象就是：好的很难招，跟大公司抢人是很难的；差一点的呢，老大又不愿意招。。。导致成果寥寥。不过这不是我要说的重点，我只是总结下笔试、面试的感想。</p>
<p>校招么，当然不会很看重项目经验，毕竟都是刚毕业。最看重的是基础，各种基础知识必须要扎实，算法/数据结构/java之类的，如果能有工程经验更好；其次是学习态度，是否积极主动，是否有探究精神，是否能快速的学会新知识，这是判断新人潜力的重要标准。扎实的基础+积极的态度，即使面对陌生的环境和工作也能很快适应，这样的新人才值得培养。</p>
<p>对于笔试，只要尽自己所能就可以了。有题目答不出是正常的，笔试题最大的目的是区分不同的档次，所以题目都会很有层次。如果你所有题都能答出来反而是有问题的。。。但答不出来最好也写写想法，关键是要有自己的思考。对于有些交白卷就夹个简历上来的同学，我也只能呵呵了。。。<br>面试也是一样的道理，注重基础。注意自己简历上的每一个字，都必须是真实可信的，面试官不一定会从哪里开始问。如果有什么虚假/夸大的经历/项目被发现，一般直接gg了。</p>
<p>有些同学啊，面试时总是喜欢扯各种业务逻辑，把实习时参与的一些系统的整个业务给我描述了一遍，但其实我根本不关心。。。我关心的是你在这个系统里扮演什么角色，做了什么事情，用了什么技术，碰到什么问题。如果能讲清楚技术细节，为什么用这些技术，就更好了。<br>其实，社招时很多人也有这个毛病，描述一大堆业务逻辑。确实业务很庞大很复杂，但毛线用都没，问起技术实现和细节还是一无所知。我只能认为那是心虚的表现了。。。<br>可能跟我个人有关吧，我更关注对技术本身的理解和实践，抛开那一堆业务逻辑。</p>
<p>还有些同学总是举着一块挡箭牌，或者叫遮羞布，“我是做算法的”。因为是做算法的，所以可以不会java/没用过多线程/不会spring/没听说过maven/不会git/工程经验0。我说搞算法的hadoop/spark总应该知道吧，要不咱们聊聊mapreduce？回答是：不知道，只会用Caffe。。。研究机器学习/深度学习/神经网络固然高大上，但一些基础的开发知识还是要知道的吧。“算法”和“工程”从来都不是对立的，不知道为什么很多人觉得只能取其一。<br>社招中也有这种情况，只不过挡箭牌变成了“我是做业务开发的”，所以不了解分布式/大数据/高并发/Linux/运维是可以的。确实有些人经手的系统比较简单，这些技术也用不到，但你要去学习啊，要能看到远方啊，看到系统规模变大会发生哪些问题，瓶颈在哪里。有句话说的好，“兜揣2块钱，心怀500万”，我觉得这种心态用在学习技术上正合适，虽然夸张了些。。。</p>
<p>另外还见过一些同学，各种项目经验，还有自己创业好几次的，甚至都融到天使轮，但问起基础来还是一团糟。就像我之前说的，校招不会太看中你的经验，关键还是基础，简历上的项目经验/实习经历再光鲜又有何用。</p>
<p>最后一个感想：面试也是挺累的。。。不比写代码简单多少。。。</p>
<h1 id="KPI？">KPI？</h1>
<p>起因是看了zhihu<a href="https://www.zhihu.com/question/51142219" target="_blank" rel="external">一个帖子</a>。</p>
<p>因为最近面试比较多，往往会涉及到一个给面试者定级别的问题。当然我给的级别不是最终的，仅供参考，最终结果还是老大说了算，只是用于评估面试者一个大概的能力范围。那如何区分不同的级别呢？其实我的标准很简单：</p>
<ul>
<li>1档：需要被告诉做什么事，并且指导怎么做。</li>
<li>2档：告诉做什么事就可以，不用什么指导，最多code review下。</li>
<li>3档：能独立维护一个系统，自己去优化并对接需求。</li>
<li>4档：能从无到有做一个系统出来，担任项目PM。并且能做些工作之外的事，扩展技术深度和广度。</li>
<li>5档：能自己找到需求，从无到有做活一块业务。在某些技术领域能有深耕。</li>
</ul>
<p>当然这是个很粗略的分类，再高的级别我也应该碰不到了。。。关键字：独立、从无到有。<br>各个级别之间也不是泾渭分明的，边界不是特别清晰，也不是像打怪一样必须要一级一级上升。每个级别，除了有技术上的要求，更重要的是对各种“软实力”的要求，比如沟通/协调/组织/眼界。相对而言，技术水平的提升是最容易的，“软实力”的提升才是最难的，要看自身情况。<br>那个帖子里有句话说的很好：“很多中国教育的方式让人过度注重 technical，比较有可能忽略了其它领域”。</p>
<p>评级和KPI一直是个比较敏感的话题，也被人诟病很多，确实这种制度在执行时有很多问题，搞得大家怨声载道。。。不过我感觉这不能怪制度本身，就像minzhu一样。。。印度和美国都是minzhu，为啥印度的minzhu一直被人骂，美国的就一直被夸？制度是死的，执行制度的是人，是人就可能有偏差，可能有漏洞，有猫腻。</p>
<p>对于大公司而言，貌似还真的少不了KPI，因为没有更好的管理方式。大公司追求的已经不是快速扩张了，而是平稳发展。KPI就像是给马套上缰绳，确实平稳了，容易驾驭了，但也失去了冲劲和野性，从赛马变成了拉车的马。总之是把双刃剑，是否用/怎么用，都要视实际情况而定。<br>不过KPI制定的合不合理，执行的又如何，是否会被某些人滥用，就是另一回事了。<br>最糟糕的情况就是：做的越多，错的越多，导致大家都畏首畏尾，小心翼翼的维持现状。</p>
<p>关于升级再提一句，其实升级是个很玄学的事情，很多时候也要看运气，没人能告诉你怎么做。大多是挑战一些难度很大的事，不成功则成仁。。。就算这件事难度上达到了级别，但做不成也不算，不会有所谓的“苦劳”。</p>
<h1 id="杂七杂八的研究">杂七杂八的研究</h1>
<p><a href="https://www.v2ex.com/t/310767" target="_blank" rel="external">在 2016 年学 JavaScript 是一种什么样的体验？</a>：前端领域吐槽的集大成者。印象深刻的是一些评论：“jquery: 你大爷永远是你大爷”，“前端现在是面向issues编程”。。。<br>对二手前端而言嘛，纯粹是吃瓜看戏。如果一定要我在js框架中站队，我当然会选react，其次是vue，最次是angular。</p>
<p><a href="http://www.infoq.com/cn/articles/urls-development-history-domain-name-protocol-and-port" target="_blank" rel="external">URL的发展历史：域名、协议和端口</a>：科普考古文，以前也研究过DNS，觉得挺好玩。</p>
<p><a href="https://tomcat.apache.org/tomcat-7.0-doc/class-loader-howto.html" target="_blank" rel="external">Tomcat 7 Class Loader HOW-TO</a>：起因是一个同学问我怎么看java程序启动后加载了哪些jar，我说<code>ps -ef</code>看java进程的classpath参数，后来发现这招对tomcat完全不灵。。。</p>
<p><a href="http://www.infoq.com/cn/articles/mvc-web-architecture-polymorphism" target="_blank" rel="external">多形态MVC式Web架构的分类</a>：MVC已经是一个有些混乱的概念了，别纠结概念，能解决问题就好。</p>
<p><a href="https://www.patreon.com/" target="_blank" rel="external">Patreon</a>：一个好玩的网站，可以让各种创意工作者得到捐助。我只知道vue的作者在上面募捐。</p>
<p>前端时间研究ML时，看了斯坦福的公开课，顺便也整理下常见的在线教育平台。对我来说，选择平台最重要的因素是看视频时能不能加速。。。比如2倍速播放。毕竟视频太长，很浪费时间，对于一些熟悉的领域，即使2x语速也完全能理解。</p>
<ul>
<li><a href="https://www.coursera.org/" target="_blank" rel="external">Coursera</a>：MOOC的鼻祖，自带Andrew Ng的大神光环，课程丰富，可惜国内访问会比较慢。视频支持加速。</li>
<li><a href="http://www.imooc.com" target="_blank" rel="external">慕课网</a>：似乎是专门针对程序员的，内容很丰富。视频支持加速。</li>
<li>老东家的<a href="http://study.163.com" target="_blank" rel="external">云课堂</a>和<a href="http://open.163.com" target="_blank" rel="external">公开课</a>：良心出品，各种类型的课程都有。可惜现在云课堂部分课程要收费，而且二者都不支持视频加速。</li>
<li><a href="http://www.icourse163.org" target="_blank" rel="external">中国大学MOOC</a>：似乎是官方背景的机构和网易公开课联手推出的，都是各种大学中的课程。支持视频加速。</li>
<li><a href="http://www.duobei.com" target="_blank" rel="external">多贝网</a>：界面舒服，内容丰富，尤其各种互动印象深刻。不支持视频加速。</li>
<li><a href="http://www.ted.com" target="_blank" rel="external">TED</a>：也不用多解释什么了，名声在外。不支持视频加速。</li>
<li><a href="http://www.hubwiz.com" target="_blank" rel="external">汇智网</a>：似乎用户不多，课程也比较少，没有视频教学。但我很喜欢这种偏实践的教学方式。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>据说今天（2016-10-24）是程序员的节日？不过没啥过节的气氛嘛，大家还是该干啥干啥。<br>懒得想题目了，随便借用一下。题目这种东西嘛，不是很重要，反正是无主题随意吐槽。<br>不过1024是开篇的日子，等写完估计是十一月了。。。</p>
]]>
    
    </summary>
    
      <category term="杂谈" scheme="http://jxy.me/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker与虚拟化]]></title>
    <link href="http://jxy.me/2016/10/02/docker-for-mac/"/>
    <id>http://jxy.me/2016/10/02/docker-for-mac/</id>
    <published>2016-10-02T11:32:32.000Z</published>
    <updated>2016-10-05T05:09:31.000Z</updated>
    <content type="html"><![CDATA[<p>其实docker也火了好久了。<a href="/2015/09/04/some-messy-thought/">一年之前</a>我就想试下，结果在mac上安装太麻烦了，由于不支持<a href="https://linuxcontainers.org/" target="_blank" rel="external">LXC</a>，还要搞个VirtualBox的虚拟机过渡，感觉很不爽。既然要用虚拟机，不如直接选择<a href="https://www.vagrantup.com/" target="_blank" rel="external">Vagrant</a>。<br>但最近<a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="external">Docker for Mac</a>发布了，据说不再需要VirtualBox了，赶紧来试下，顺便总结下自己对于虚拟化的一些理解。</p>
<a id="more"></a>
<h1 id="Docker_for_Mac">Docker for Mac</h1>
<p>首先要知道docker中的一些基本概念：</p>
<ul>
<li>docker daemon：用于管理容器的进程，对外暴露接口</li>
<li>docker client：用户端的命令行工具，可以通过unix socket（unix:///var/run/docker.sock）或tcp协议与daemon进程通信。与daemon进程其实是一对多的关系。</li>
<li>image：镜像，就是一个预先定义好的环境，可以直接载入容器中运行。只读，由Dockerfile定义。Dockerfile某种意义上类似linode中的的<a href="https://www.linode.com/stackscripts" target="_blank" rel="external">StackScripts</a>，都是一堆命令的集合，在环境初始化的时候执行。</li>
<li>registry：仓库，存放各种镜像，有点类似maven中的仓库概念。docker提供一个官方仓库<a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>，也可以自己搭建私服。</li>
</ul>
<p>更多的docker相关知识还是看<a href="https://docs.docker.com/" target="_blank" rel="external">官方文档</a>，各种第三方教程可能比较落后，毕竟docker现在版本迭代非常快。</p>
<p>由于历史原因，要在mac上使用docker，有几种选择：</p>
<ul>
<li><a href="http://boot2docker.io/" target="_blank" rel="external">boot2docker</a>：基本原理是自带一个最小化的VirtualBox的Linux镜像，在虚拟机中运行docker daemon，然后本机的docker client通过网络与deamon交互。这是一个<a href="https://github.com/boot2docker/osx-installer/releases" target="_blank" rel="external">已经废弃</a>的项目，不要被一些老的文章误导。</li>
<li><a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="external">Docker Toolbox</a>：boot2docker的继任者，<a href="https://blog.docker.com/2015/08/docker-toolbox/" target="_blank" rel="external">去年8月发布的</a>。基本原理是一样的，都是利用了一个VirtualBox的虚拟机，但Docker Toolbox同时封装了其他一些常用的工具，让使用更方便。也是官方推荐的安装方式之一。</li>
<li><a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="external">Docker for Mac</a>：<a href="https://blog.docker.com/2016/03/docker-for-mac-windows-beta/" target="_blank" rel="external">今年6月发布的</a>最新工具，解决了Docker Toolbox的很多痛点，用起来更爽了。基本原理还是内嵌一个虚拟机，但是从VirtualBox换成了xhyve（这个我在文末会讲），而且对虚拟机做了很多定制化，反正就是很好很强大就对了。对于新老虚拟机的一些区别可以参考<a href="https://docs.docker.com/docker-for-mac/faqs/#/what-is-hyperkit" target="_blank" rel="external">FAQ</a>。</li>
</ul>
<p>Docker for Mac虽然好用，但是有一些限制条件：</p>
<ul>
<li>mac必须是2010年之后的型号。其实就是CPU要支持Intel VT-x。</li>
<li>系统10.10.3以上。我正好是10.10.3 Yosemite，但安装之后提醒我10.10.3下有一个已知bug，可能吃满CPU，目前只能重启Docker for Mac来解决。</li>
<li>至少4GB内存。</li>
<li>系统中不能安装有VirtualBox 4.3.30之前的版本。我之前为了用Vagrant，正好安装了VirtualBox 4.3.30。用<code>brew cask</code>安装的，显示为<code>virtualbox4330101610</code>。不过也没发现啥问题。</li>
</ul>
<p>能满足这些条件的话，尽量用Docker for Mac，否则只能用Docker Toolbox了。关于二者的一些区别，可以参考<a href="https://docs.docker.com/docker-for-mac/docker-toolbox/" target="_blank" rel="external">官方文档</a>。</p>
<p>Docker for Mac安装过程还是挺简单的，和安装普通的mac应用一样，对着<a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="external">官方文档</a>一步步来就可以了，如果最后能启动一个nginx的容器，正常访问<code>http://localhost</code>的话，就算成功了。说下我碰到的一些问题：</p>
<ol>
<li>拉取nginx镜像的时候，死活拉不下来。似乎我的DNS被污染了，一直报错<code>dial tcp: lookup index.docker.io on 192.168.65.10:53: no such host</code>。<code>index.docker.io</code>这个域名也是ping不通，似乎使用了AWS的服务，被墙了？于是满世界找国内的镜像，最后使用了<a href="https://www.daocloud.io/mirror" target="_blank" rel="external">DaoCloud</a>，它的文档还挺新的，已经有针对Docker for Mac的配置方法了。</li>
<li>配置好DaoCloud的镜像后，居然还是报错<code>dial tcp: lookup dao-booster.daocloud.io on 192.168.65.10:53: no such host.</code>，但是<code>dao-booster.daocloud.io</code>是可以ping通的，真是见鬼。无奈在<code>/etc/hosts</code>里手动写死ping到的IP，加了两条记录<code>106.75.18.185 m.daocloud.io</code>和<code>183.131.208.55 dao-booster.daocloud.io</code>，终于正常了。</li>
<li>如果点击Docker for Mac菜单栏中的<code>Open Kitematic</code>（<a href="https://kitematic.com/" target="_blank" rel="external">Kitematic</a>是一个管理容器的图形界面工具，很好用，如果你用Docker Toolbox的话会自动安装，但用Docker for Mac的话就要自己下载），它会给你一个<a href="https://download.docker.com/kitematic/Kitematic-Mac.zip" target="_blank" rel="external">下载链接</a>，并跟你说下载解压之后放到<code>/Applications</code>下就可以使用了。结果我下载后解压出一个<code>Kitematic (Beta).app</code>，居然打不开，mac会提示说文件已经损坏。。。google了一下应该是个bug，解决方法见<a href="https://github.com/docker/kitematic/issues/1637" target="_blank" rel="external">这里</a>。</li>
</ol>
<p>Docker for Mac安装成功后，命令行会多几个工具：</p>
<ul>
<li>docker：其实就是docker client</li>
<li><a href="https://docs.docker.com/compose/overview/" target="_blank" rel="external">docker-compose</a>：似乎是用于部署分布式服务的，同时启动多个容器之类的，没用过</li>
<li><a href="https://docs.docker.com/machine/overview/" target="_blank" rel="external">docker-machine</a>：非Linux平台如果想用docker都要用到虚拟机，这个工具就是用来管理虚拟机的。以前boot2docker也会自带一个类似的命令<code>boot2vm</code>（好像是这个名字），功能上差不多。但Docker for Mac中应该用不到这个命令了，除非你想蛋疼的搞多个虚拟机，或者让Docker Toolbox与Docker for Mac<a href="https://docs.docker.com/docker-for-mac/docker-toolbox/#/docker-toolbox-and-docker-for-mac-coexistence" target="_blank" rel="external">共存</a>。这个命令可能是为了将虚拟机从Docker Toolbox迁移到Docker for Mac才存在的。</li>
</ul>
<p>总的来说，Docker for Mac已经完善很多了，用起来很接近原生的体验了。以前用Docker Toolbox很蛋疼的一点就是网络问题，借用官方的一张图：<br><img src="docker-toolbox.png" alt=""><br>首先我必须要设置一堆环境变量，才能让<code>docker</code>命令知道去连接那个虚拟机。其次如果我部署了一个nginx容器，我要用<code>http://12.34.56.78</code>才能访问（12.34.56.78是虚拟机的IP），而不能直接用<code>http://localhost</code>访问。<br>反正就是处处都会透出“虚拟机”的存在，很蛋疼。那我还不如直接去用虚拟机。。。<br>Docker for Mac就好很多了，让你感受不到虚拟机，像原生docker一样直接使用。</p>
<p>最后截图留念：<br><img src="dockersay.png" alt=""></p>
<h1 id="虚拟化">虚拟化</h1>
<p>虚拟化（Virtualization）实在是一个很学术的词，并非我们通常意义上所理解的虚拟机，摘录一段<a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96" target="_blank" rel="external">Wiki</a>上的说明：</p>
<blockquote>虚拟化是一个广义的术语，对于不同的人来说可能意味着不同的东西，这要取决他们所处的环境。在计算机科学领域中，虚拟化代表着对计算资源的抽象，而不仅仅局限于虚拟机的概念。例如对物理内存的抽象，产生了虚拟内存技术，使得应用程序认为其自身拥有连续可用的地址空间（Address Space），而实际上，应用程序的代码和数据可能是被分隔成多个碎片页或段），甚至被交换到磁盘、闪存等外部存储器上，即使物理内存不足，应用程序也能顺利执行。</blockquote>

<p>从这个角度来说，只要能提供一个抽象层并屏蔽底层细节的技术/工具，都可以被算作“虚拟化”的范畴？“进程”是不是虚拟化？JVM呢？以前的各种虚拟光驱（谁还记得Alcohol 120%）也算是虚拟化吧。不过不要纠结这些细节，学术之争不影响使用。能抓到耗子就是好猫。<br>大多数时候我们谈论的虚拟化，还是特指虚拟机。</p>
<h2 id="虚拟机">虚拟机</h2>
<p>我对虚拟机最早的接触，就是Win下用Vmware Workstation 4安装红旗Linux。。。这货现在都没人记得了吧，安装光盘好像还是买什么杂志送的。后来陆续用过VirtualPC、VirtualBox、Vmware Fusion。以前用linode的时候，也了解一些<a href="https://zh.wikipedia.org/wiki/Xen" target="_blank" rel="external">Xen</a>、<a href="https://zh.wikipedia.org/zh-cn/OpenVZ" target="_blank" rel="external">OpenVZ</a>之类的概念。但一直没有系统的研究过，趁着研究docker的机会一起整理下。</p>
<p>首先要明确的一个概念，就是<a href="https://zh.wikipedia.org/wiki/Hypervisor" target="_blank" rel="external">Hypervisor</a>，又叫做VMM（Virtual Machine Monitor）。通俗的说，就是一个创建、运行、管理虚拟机的程序。上文提到的各种软件，无论VirtualBox、Vmware，还是Xen、OpenVZ，都可以算作Hypervisor。Hypervisor这个词只是限定了软件的功能，而没有限定实现方式。就像所谓的“文本编辑器”一样，可以有多种实现，vim/emacs/nano/sublime之类的。根据Hypervisor的不同实现方式，大致可以分为2类：</p>
<ul>
<li>Type 1：Hypervisor直接运行在裸硬件上。从某种意义上来说，这种Hypervisor就是一个微型的操作系统，要自己跟各种硬件打交道，处理上层OS的请求。典型的就是Xen。</li>
<li>Type 2：Hypervisor运行在OS之上，只是OS中一个普通的应用程序。这个很好理解，我们常用的VirtualBox，Vmware Workstation都是这种。</li>
</ul>
<p>一般来说，Type1型的效率会更高，毕竟指令可以直接到达硬件，而Type2型中还要经过“GuestOS -&gt; Hypervisor -&gt; HostOS”的一个“转译”过程。但Type2可以利用宿主OS的内存管理/进程调度/资源管理等，实现上应该会简单些。</p>
<p>另一个要理解的概念，就是“全虚拟化”和“半虚拟化”。个人理解：</p>
<ul>
<li>全虚拟化（Full Virtualization）：就是通常意义的虚拟化，所有GuestOS中的操作，都由Hypervisor处理。GuestOS不用做任何修改，也不知道自己是运行在虚拟机中的。</li>
<li>半虚拟化（Partial Virtualization）：在全虚拟化的基础上，与GuestOS做了一些“约定”。GuestOS知道自己运行在虚拟机中，一些特殊的操作，可以绕过Hypervisor直接执行（需要和Hypervisor约定好，不过这是我猜的）。这样可以大幅度提高效率，代价就是GuestOS必须修改内核，才能对虚拟机做特定的优化，应该叫做“虚拟机专用版OS”。</li>
</ul>
<p>有人说全虚拟化/半虚拟化的区别在于是“用软件模拟所有硬件”还是“用特定硬件辅助模拟（比如<a href="https://zh.wikipedia.org/wiki/X86%E8%99%9A%E6%8B%9F%E5%8C%96" target="_blank" rel="external">Intel VT-x</a>）”，我觉得是错的。如果硬件上提供了优化，确实能提高效率，但GuestOS本身还是不知道自己是运行在虚拟机中。这种技术在<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96" target="_blank" rel="external">Wiki</a>中称作“硬件辅助虚拟化”（Hardware-Assisted Virtualization），很多人都会混淆这个概念。</p>
<p>一个典型的例子是在Vmware Workstation中安装虚拟机时，一般还要安装Vmware Tools，能大幅提高虚拟机的性能。我觉得这就是一种半虚拟化，让系统知道自己运行在Vmware虚拟机中，进而一些操作可以利用Vmware Tools去优化。当然你不装也可以，虚拟机也能正常用，就是用着卡点，很多硬件特性（比如3D加速）也不能用。</p>
<p>早期广泛使用的Hypervisor，大多是半虚拟化的，因为这样可以提高虚拟机的性能，比如Xen。在Xen上运行的GuestOS，必须使用特定版本的内核，根据不同的发行版还要自己编译，比较麻烦。由于协议的问题，也不能虚拟Windows，因为要修改Windows内核才行。后来随着CPU厂商逐步提供硬件级别的虚拟化支持（Intel VT-x、AMD-V），全虚拟化的成本大大降低，性能损失也可以接受了，而且GuestOS不需要做任何修改，逐渐成了主流。Xen也开始支持了硬件辅助的全虚拟化（<a href="https://wiki.xen.org/wiki/Xen_Project_Software_Overview#HVM" target="_blank" rel="external">Xen-HVM</a>），可以虚拟Windows了。可见全虚拟化才是大势所趋。</p>
<p>一个经常拿来和Xen对比的Hypervisor，就是<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="external">KVM</a>。KVM是基于硬件的完全虚拟化（补充一下，这里所谓的“硬件”，特指CPU，要支持Intel VT-x/AMD-V之类的指令集，目前只有CPU能提供硬件级别的虚拟化支持，其他硬件，硬盘/网卡之类的，暂时没有），但它的特殊之处在于它是集成在Linux内核之中的，通过Linux内核去做资源调度、硬件管理之类的，而它本身只负责管理虚拟机。<br>KVM很大程度上模糊了Type1和Type2的分类。它不是Linux内核之下硬件之上的一个“微型OS”，也不是Linux上的一个应用程序，应该说它就是Linux内核本身。这个Hypervisor不但可以像常规的Linux一样使用（这个Linux到底是HostOS还是GuestOS呢？鸡生蛋蛋生鸡。。。），还可以创建/管理虚拟机，而且像管理进程一样管理虚拟机。很神奇，有点波粒二象性的感觉。。。</p>
<p>关于Xen和KVM的对比，摘录几段话：</p>
<blockquote>从架构上讲，xen是自定制的hypervisor，对硬件的资源管理和调度，对虚拟机的生命周期管理等，都是从头开始写的。KVM是一个特殊的模块，Linux kernel加载此模块后，可以将Linux kernel 变成hypervisor，因为Linux kernel已经可以很好的实现对硬件资源的调度和管理，KVM只是实现了对虚拟机生命周期管理的相关工作。 KVM的初始版本只有4万行代码，相对于xen的几百万行代码显得非常简洁。<br></blockquote><br><blockquote>在以前没有vt-x的时候，xen致力于不依赖硬件，也不依赖qemu，一步一步把虚拟化做了起来<br>现在都是xen的历史包袱了</blockquote>

<p>另外提到KVM，就不得不提<a href="http://wiki.qemu.org/Main_Page" target="_blank" rel="external">QEMU</a>，这两个名词总是一起出现。QEMU本质上是一个用软件支持全虚拟化的Hypervisor，可以模拟各种CPU、各种硬件，本来跟KVM没啥关系。由于KVM本身只提供了CPU和内存的虚拟化，但一个完整的虚拟机还要有其他硬件；而且KVM只是一个内核模块，也需要一个用户空间的工具去调用。于是它利用了QEMU已有的代码（反正都是开源的嘛），改造下，成了所谓的<a href="http://wiki.qemu.org/KVM" target="_blank" rel="external">qemu-kvm</a>，这样才形成了完整的解决方案。</p>
<p>常见的开源Hypervisor就是Xen和KVM了。从现在的趋势来看，目测KVM会逐步取代Xen，毕竟是Linux官方支持的。<br>除了开源的Hypervisor，也有一些商业化Hypervisor，最出名的就是Vmware了吧，目前在企业市场主推的是<a href="http://www.vmware.com/products/esxi-and-esx.html" target="_blank" rel="external">ESXi</a>（话说它的产品线真是乱，vSphere/vCenter/ESX/ESXi）。此外还有微软的<a href="https://en.wikipedia.org/wiki/Hyper-V" target="_blank" rel="external">Hyper-V</a>（据说这货就是以前的VirtualPC？）。</p>
<p>最后再提一下<a href="http://libvirt.org/" target="_blank" rel="external">libvirt</a>。由于有这么多种Hypervisor，每种Hypervisor都有自己的虚拟机规范，大家觉得要管理这么多种Hypervisor好麻烦啊，于是有聪明人（好像是红帽？）想出了一个办法：提出一套统一的管理虚拟机的API和工具（比如命令行的virsh/图形界面的virt-manager），这样就可以对上层用户屏蔽各个Hypervisor的具体实现了。借用Wiki中的一张图：<br><img src="libvirt1.png" alt=""><br>或者这张图更清楚一些：<br><img src="libvirt2.png" alt=""></p>
<h2 id="容器">容器</h2>
<p>容器算是虚拟化中的另外一个潮流，跟Hypervisor的思路完全不同。</p>
<p>关于容器的讨论也有很多了，一些技术细节我也不打算复述，比虚拟机好懂多了。。。有人说容器是“轻量级的虚拟机”，个人感觉这种说法是有点问题的。容器本质上是一种资源隔离机制。普通的进程也可以做到资源隔离，只不过隔离的强度比较弱罢了。容器并没有什么新技术，只是利用Linux内核已有的一些机制，比如<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="external">namespace</a>/<a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="external">cgroup</a>/<a href="https://en.wikipedia.org/wiki/Aufs" target="_blank" rel="external">AUFS</a>，做到了更好的资源隔离。这里所说的资源包括CPU/内存/IO/带宽等等。</p>
<p>容器相关的技术，其实可以追溯到<a href="https://zh.wikipedia.org/wiki/Chroot" target="_blank" rel="external">chroot</a>/<a href="https://zh.wikipedia.org/wiki/FreeBSD_jail" target="_blank" rel="external">FreeBSD jail</a>，更关注于“在已有的系统里创造出一个完全隔离的环境”，而不是“创建一个新的系统”，所以说跟Hypervisor是完全不同的思路。应该称作“沙盒”更合适些？也有点像用于引诱黑客的“蜜罐”。</p>
<p>容器不等于docker。虽然docker是现在最火的容器相关项目。其实docker只是一个容器管理的工具，而不是实现容器的关键技术。早期的docker可以认为就是<a href="https://linuxcontainers.org/" target="_blank" rel="external">LXC</a>之上的一层“皮”，但它能火起来是有原因的：</p>
<ol>
<li>做到极端好用。LXC虽然提供了命令行工具，但用起来<a href="https://www.ibm.com/developerworks/cn/linux/l-lxc-containers/" target="_blank" rel="external">很复杂</a>。docker极大的降低了使用门槛，一行命令就部署一个服务，一台机器上跑上百个容器，几年前你能想象嘛？</li>
<li>提出镜像&amp;仓库的概念。激发了广大人民群众的创造力，每个人都可以创建自己的docker image并分享给其他人。减少了很多重复造轮子的工作。事实证明，立足于群众才是取胜之道啊。</li>
<li>将系统与应用解耦，顺应了当前的DevOps潮流。而且向群众们灌输了“App-Centric”的观念，用docker串联开发/测试/交付，对于敏捷开发也有很大好处。</li>
</ol>
<p>所以，个人感觉，docker的胜利更像是用户体验的胜利，是营销/运营的胜利，而不是传统意义上的，技术突破的那种胜利。。。<br>docker应该说是很大程度上解放了运维的生产力吧，从侧面也能反应出运维有多么苦逼。。。另外docker也带了一波go语言的节奏？似乎现在的运维都非常喜欢go。</p>
<p>docker不等于LXC。虽然早期的docker只是LXC之上的一层“皮”，但随着docker的火爆，当然也要搞自己一点“原创”的东西（0.9版本之后），不能总是寄人篱下啊。借用一张图：<br><img src="docker.png" alt=""><br>通俗的说，docker要定义容器的标准，将底层实现都抽象化为libcontainer接口，和libvirt有些类似。到时候LXC只是一种可选的实现而已。不过现在还是只能依赖LXC。</p>
<p>自从容器技术火爆以来，很多人就在争论容器和Hypervisor孰优孰劣。很多人宣称<a href="http://dockone.io/article/1388" target="_blank" rel="external">容器将取代Hypervisor</a>。这里面有几句话讲的很好，摘录下：</p>
<p><blockquote>容器作为基础设施 vs 容器作为以应用程序为中心的打包与管理工具<br>容器具有两个视角：它们是基础设施（即“轻量级虚拟机”）？或是应用程序管理与配置系统？事实是，它们两者皆是。如果你是基础设施人员，你可能会将其视为前者，如果是开发人员，则可能会将其视为后者。</blockquote></p>
<p><blockquote>Hypervisor唯一的价值在于使用PV驱动支持多种操作系统，下一代数据中心并无此需求</blockquote><br>孰优孰劣我也不敢妄言，还是要看场景的。如果容器能满足需求就尽量容器吧，毕竟用着简单省事。如果我是运维，我宁愿牺牲些性能换取运维的便利性。<br>而且二者也不是非此即彼的关系，有一个<a href="http://www.infoq.com/cn/news/2015/06/Hyper-Hypervisor-Docker" target="_blank" rel="external">神奇的东西</a>，可以用Hypervisor去运行docker image，这个思路感觉挺好玩的。</p>
<p>不过想要用容器只能用新版本的Linux内核，导致可移植性比较差，而且Linux容器里总不可能跑Windows吧。。。Ubuntu里也不可能跑CentOS。这在某些情况下算是一个劣势。Hypervisor一般没这个问题。<br>macOS想用docker就很蛋疼。。。也许以后libcontainer更完善的话会好些。</p>
<h1 id="Term_Storm">Term Storm</h1>
<p>google的过程中找到了各种各样的专有名词，头都大了，总结下。<br>一些上文中已经解释过的名词就不再重复了。</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Chroot" target="_blank" rel="external">chroot</a>：我一直觉得chroot是个很神奇的命令，最早接触它是在linode挂掉需要Rescue Mode时。chroot可以形成一个简单的沙盒，算是容器概念的雏形了。</li>
<li><a href="https://zh.wikipedia.org/wiki/OpenVZ" target="_blank" rel="external">OpenVZ</a>：感觉上是一种Type2的Hypervisor，需要宿主OS做特定的修改。特色是“一台OpenVZ物理服务器的拥有者（root）可以看见所有虚拟环境的进程和文件”。反正当初买VPS的时候大家都推荐Xen的，说OpenVZ不好，超卖严重，而且受邻居影响很大。</li>
<li><a href="https://linuxcontainers.org/" target="_blank" rel="external">LXC</a>：linux container的简称，docker的基础。话说LXC要比docker早出现5年。。。</li>
<li><a href="https://www.openstack.org/" target="_blank" rel="external">OpenStack</a>：开源IaaS平台的事实标准。我没用过，感觉上是对虚拟机管理的一堆技术的整合，底层可以支持KVM/Xen/Vmware等各种虚拟机，但社区似乎推荐KVM。</li>
<li><a href="http://www.intel.com/content/www/us/en/virtualization/virtualization-technology/intel-virtualization-technology.html" target="_blank" rel="external">Intel VT-x</a>：若干年前很火热的概念。感觉上就是一套CPU指令集（类似SSE/MMX？），可以对CPU/内存的虚拟化提供硬件级别的支持，AMD对应的技术叫做AMD-V。VT-x只是提供了内存和CPU的虚拟化，提供IO虚拟化的技术称作VT-d，AMD对应的技术叫做AMD-Vi。但感觉VT-d说的较少，一般都是VT-x，因为软件支持较少，一般都是企业级软件才支持VT-d，比如Vmware ESXi。CPU是否支持VT-x/VT-d，可以去<a href="http://ark.intel.com" target="_blank" rel="external">Intel官方</a>查询。</li>
<li><a href="https://software.intel.com/en-us/articles/best-practices-for-paravirtualization-enhancements-from-intel-virtualization-technology-ept-and-vt-d" target="_blank" rel="external">Intel EPT</a>：实现内存虚拟的关键技术就是地址转换，因为GuestOS中的内存地址都是虚拟的，一般要维护一个虚拟地址到真实地址的映射关系。Intel EPT可以让这个转换过程用硬件去做，提高效率。AMD也有类似的技术。</li>
<li><a href="http://www.linux-kvm.org/page/Virtio" target="_blank" rel="external">Virtio</a>：针对KVM的半虚拟化驱动，有点类似Vmware Tools，只能用于Linux。有一些KVM的最佳实践中提到最好要安装Virtio。</li>
<li><a href="https://wiki.freebsd.org/bhyve" target="_blank" rel="external">bhyve</a>/<a href="https://github.com/mist64/xhyve" target="_blank" rel="external">xhyve</a>：bhyve是FreeBSD上的一个Hypervisor，感觉上是Type2，全虚拟化。特点在于体积小，轻量，而且支持很多新特性（VT-x/Virtio不用说了，居然支持VT-d）。xhyve是它在macOS上的移植版，也是Docker for Mac的核心，docker针对xhyve专门包装了一个组件叫做<a href="https://github.com/docker/HyperKit/" target="_blank" rel="external">HyperKit</a>。使用简介见<a href="http://www.vpsee.com/2015/06/mac-os-x-hypervisor-xhyve-based-on-bhyve/" target="_blank" rel="external">这里</a>。</li>
</ul>
<h1 id="参考资料">参考资料</h1>
<p><a href="http://virtual.51cto.com/art/201102/245920_all.htm" target="_blank" rel="external">Intel虚拟化技术-从VT-x到VT-d</a><br><a href="https://www.oschina.net/question/2548918_2149938" target="_blank" rel="external">KVM 虚拟化技术之Hypervisor 架构</a><br><a href="https://my.oschina.net/qefarmer/blog/386843" target="_blank" rel="external">qemu,kvm,qemu-kvm,xen,libvirt的区别</a><br><a href="http://linux.vbird.org/linux_enterprise/xen.php" target="_blank" rel="external">鸟哥的Xen教程</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-vt/" target="_blank" rel="external">虚拟化技术漫谈</a><br><a href="http://www.ibm.com/developerworks/cn/linux/l-hypervisor/" target="_blank" rel="external">剖析 Linux hypervisor</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-using-kvm/" target="_blank" rel="external">使用 KVM 虚拟化技术</a><br><a href="http://www.cnblogs.com/xusongwei/archive/2012/07/30/2615592.html" target="_blank" rel="external">全虚拟化和半虚拟化的区别</a><br><a href="http://www.infoq.com/cn/articles/docker-container-management-libcontainer-depth-analysis" target="_blank" rel="external">Docker背后的容器管理——Libcontainer深度解析</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>其实docker也火了好久了。<a href="/2015/09/04/some-messy-thought/">一年之前</a>我就想试下，结果在mac上安装太麻烦了，由于不支持<a href="https://linuxcontainers.org/" target="_blank" rel="external">LXC</a>，还要搞个VirtualBox的虚拟机过渡，感觉很不爽。既然要用虚拟机，不如直接选择<a href="https://www.vagrantup.com/" target="_blank" rel="external">Vagrant</a>。<br>但最近<a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="external">Docker for Mac</a>发布了，据说不再需要VirtualBox了，赶紧来试下，顺便总结下自己对于虚拟化的一些理解。</p>
]]>
    
    </summary>
    
      <category term="docker" scheme="http://jxy.me/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[真・二手前端]]></title>
    <link href="http://jxy.me/2016/09/06/zhen-second-hand-qianduan/"/>
    <id>http://jxy.me/2016/09/06/zhen-second-hand-qianduan/</id>
    <published>2016-09-06T09:26:58.000Z</published>
    <updated>2016-09-15T16:44:48.000Z</updated>
    <content type="html"><![CDATA[<p><a href="/2015/09/21/second-hand-frontend/">《二手的前端开发》</a>续集，继续折腾，跳了React的大坑。。。</p>
<a id="more"></a>
<p>掐指一算，已经近3个月没更新了，再创新纪录，可喜可贺。<br>这段时间呢，可以说是忙，做着各种奇奇怪怪的事，跟各种各样的人打交道，写着各种“片段式”的代码。感觉很忙却又说不清自己在做什么。总是感觉时间很零碎，很久没有整块的时间去潜心做一件事了。这个有机会再单独写一篇去吐槽吧。<br>但也可以说是懒，毕竟还是有时间把《权利的游戏》1~5季追完。。。<br>人啊，总是会有“去tmd工作我什么都不想干就想宅着”的时候。</p>
<p>言归正传，本篇的主角是React。<a href="/2015/09/21/second-hand-frontend/">之前</a>我也搞过一点前端的工作，但是比较low，大多是jquery+bootstrap之类的东西，感觉就是在逆时代潮流而动啊。。。也听说过React，一直很口水，身不能至心向往之。尤其是<a href="https://facebook.github.io/react-native/" target="_blank" rel="external">React Native</a>出来之后，感觉就是“卧槽这也行”，颇有点当年java的“write once, run everywhere”的风范。不过java的这个牛皮是吹破了，react的口号也跟这个不太一样，“learn once, write everywhere”，后文再详细说。<br>正好之前有点空闲时间，新项目还没开始，于是就研究了下React和<a href="http://ant.design" target="_blank" rel="external">Ant Design</a>。初衷很简单，如果我能自己写前端，那做项目就不用求人了，前端资源真是很紧张。</p>
<p>一边学一边写，最后搞了<a href="https://github.com/jiangxy/react-antd-admin" target="_blank" rel="external">这么个东西</a>出来。本意是想简化下各种后台页面的开发，尽量做的通用一点，欢迎各种吐槽。</p>
<p>注意，本文<strong>不是一个React教程</strong>，只是总结下学习过程中一些个人的感想。React教程实在太多了，遍地都是。。。</p>
<h1 id="最佳实践？">最佳实践？</h1>
<p>首先我要抱怨下前端开发的现状，对于新人，对于二手前端，真是太不友好了。。。因为乱。</p>
<p>引用一张图片：<br><img src="/2016/09/06/zhen-second-hand-qianduan/1.png" alt=""></p>
<p>原图在<a href="http://fefe.jeroenheijmans.nl/" target="_blank" rel="external">这里</a>，列举了前端的大部分框架和相关的工具。反正我第一眼看到感觉就是“日居然要学这么多东西”。。。</p>
<p>之前我就觉得前端很乱。不是难，是乱。技术么，不管多难，只要肯下功夫总能学会的。但是工程化的标准、开发风格、开发框架之类的，前端一直没有一个“业界标准”，太多框架、太多工具可以选择。我用react，能实现需求；你用angular？也行啊；什么他要写原生js？貌似也可以。。。</p>
<p>一个很让人头疼的问题就是工程结构。一个典型的java工程，一般都会有<code>src/main/java</code>、<code>src/test/java</code>之类的目录放置源码，<code>target</code>目录放置构建结果，可以很清楚整个工程结构是什么样的，其他人接手也很简单。这就是maven提倡的“约定优于配置”的理念。但前端世界完全没有这种规范，编译后的目标目录，有人叫<code>build</code>，有人叫<code>dist</code>，也有<code>target</code>/<code>result</code>的。。。源码目录的结构更是一团糟，完全取决于开发者的个人兴趣。每次看别人的工程都很头疼。这时才感受到maven的可贵啊。</p>
<p>至于css/js/html/兼容性上的各种混乱，更是无力吐槽了。。。不过值得欣慰的是，至少比以前的洪荒时代好多了。</p>
<p>还有啊，为什么某个组件我升级个小版本就导致整个项目挂了啊，你们这版本号也太乱来了吧。。。</p>
<p>前端开发另一个怪现象就是很喜欢自己造轮子，即使有可用的工具也要自己重新造一套，我觉得大概有几个原因：</p>
<ul>
<li>确实现在前端生态圈还不完善，各个领域没有一个决定性的优胜者，只能说各擅胜场</li>
<li>因为没有标准，每个人都觉得自己掌握的才是宇宙真理。。。看别人的工具总是不爽，“文人相轻”比较严重，各种“派系”林立</li>
<li>js语言太灵活。一门语言如果表达力很强，就意味着不同的人写同样的功能，写出来的代码可能天差地别。而且你总觉得有更好的写法。。。所以说，太灵活的语言不适合协作，但适合炫技。。。</li>
</ul>
<p>不要说专业前端了，我这个二手前端都会一遍遍重构自己的代码。我会特意去用ES6的各种新特性，class/箭头函数之类的，不用不舒服斯基。说实话挺头疼的，尤其是对于强迫症。</p>
<p>唠叨了这么多，对“混乱”抱怨了这么久，所以，前端领域到底有没有所谓的“<strong>最佳实践</strong>”？<br>恐怕我无法回答这个问题。但在学习react的过程中，我总结了一些规则，仅供参考：</p>
<ul>
<li>抱着HTML5的大腿</li>
<li>写<a href="http://less.bootcss.com/" target="_blank" rel="external">less</a>，不要写原生css。话说css真是难，前端同学你们是怎么记住那么多样式的。我只能抄其他人的，或者找些开源的，再对着<a href="http://www.w3school.com.cn/cssref/index.asp" target="_blank" rel="external">css手册</a>一点点改，有时候调css能花上一天。。。</li>
<li>依赖管理都用<a href="https://www.npmjs.com/" target="_blank" rel="external">npm</a></li>
<li>js都用ES6的写法，但也要能看懂ES5。至于各种方言，CoffeeScript/TypeScript之类的，注定是历史的垃圾堆</li>
<li>一切以DOM为基础。虽然大家都说DOM慢，而且很多框架都会屏蔽DOM操作。但它是最底层的操作，理解之后有很多好处。不要上来就搞一堆框架专有的概念，没错我说的就是angular。。。</li>
<li>怎么熟悉DOM？先把<a href="https://jquery.com/" target="_blank" rel="external">jquery</a>/<a href="http://zeptojs.com/" target="_blank" rel="external">zepto</a>用熟吧少年</li>
<li><a href="http://babeljs.io/" target="_blank" rel="external">Babel</a>真是神器，可以让你提前使用ES6甚至ES7的特性。大部分特性是编译时的优化，可以认为是语法糖，但注意有些特性可能需要运行时的polyfill。</li>
<li><a href="https://webpack.github.io/" target="_blank" rel="external">Webpack</a>是React绝配，有各种神奇的loader和插件，后文详述</li>
<li>React全家桶（React+ <a href="https://github.com/ReactTraining/react-router" target="_blank" rel="external">React Router</a> + <a href="https://github.com/reactjs/redux" target="_blank" rel="external">Redux</a>）看情况是否采用。一般而言React Router是必须的，但是否用Redux就取决于你的需求了</li>
</ul>
<p>大概就是这样了。最佳实践不能帮你写代码，但可以少踩些坑。</p>
<p>话说，前端的混乱也是有历史原因的。因为以前的前端都很简单，我记得以前还用记事本写html和js，那时候写前端约等于“写脚本/写样式/做一些动态效果”。但现在前端越来越重了，越来越多的业务逻辑转移到前端，又赶上了移动互联网的大潮，复杂化/工程化是不可避免的。但却缺少约束和规范，野蛮生长，再加上一些先天的缺陷（比如原生js的各种坑爹设计），造成了如今的局面。</p>
<p>不过前端真的是很有活力的一个领域，有各种好玩&amp;吊炸天的东西。比如<a href="http://codepen.io/" target="_blank" rel="external">CodePen</a>、<a href="https://jsfiddle.net/" target="_blank" rel="external">JSFiddle</a>、<a href="http://threejs.org/" target="_blank" rel="external">three.js</a>、<a href="https://github.com/d3/d3/wiki/Gallery" target="_blank" rel="external">D3.js</a>、<a href="http://rap.taobao.org" target="_blank" rel="external">RAP</a>、<a href="http://periodic.famo.us/" target="_blank" rel="external">famo.us</a>、<a href="http://moebio.com/" target="_blank" rel="external">Moebio Labs</a>等等很多。</p>
<h1 id="React印象">React印象</h1>
<p>说实话，react给我的第一印象实在不咋地。因为我先看到的是JSX语法，感觉很难受，比如像下面这种：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Hello extends React.Component {</div><div class="line">  render() {</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">h1</span> <span class="attribute">className</span>=<span class="value">"testStyle"</span>&gt;</span>Hello, React!<span class="tag">&lt;/<span class="title">h1</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>;</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在js里写html，你特么在逗我吧？这是什么鬼？还记得以前的各种<code>xxx.innerHTML=</code>/<code>document.write(xxx)</code>的痛苦么。用js写html早就被证实是不可行了吧，极难维护而且扩展性堪忧，就跟JavaEE早期直接用servlet输出html代码一样。<br>我不喜欢angular一个原因就是它把太多逻辑揉到html里了，各种<code>ng-xx</code>标签。结果react反其道而行之，把html搞到业务逻辑代码里去了。。。</p>
<p>直到我看了<a href="http://www.hubwiz.com/class/552762019964049d1872fc88" target="_blank" rel="external">这个教程</a>，颇有茅塞顿开的感觉。这个教程从传统的DOM操作一步步过渡到react，很赞，很多教程上来就是一大堆react的概念，头都晕了。</p>
<p>原来React的<strong>本质还是DOM操作</strong>，它只不过额外做了几件事：</p>
<ul>
<li>提出虚拟DOM的概念，解决DOM操作效率低的痛点。至于它是如何做到DOM diff，如何将虚拟DOM渲染到真实DOM上的，完全不用关心。</li>
<li>在虚拟DOM的基础上，提出react元素/react组件的概念，强调高内聚，强调封装性，强调复用。React组件的本质就是一组DOM元素，这组DOM元素的样式和操作逻辑都被封装到组件中，并且可以被渲染到虚拟DOM上。围绕组件又会产生状态/props/生命周期等一系列概念。</li>
<li>提出JSX语法，解决DOM操作繁琐、不易读的痛点。JSX虽然看起来像html，但是一些细节的写法还是有区别的。只是一种语法糖，但习惯之后就再也离不开了。</li>
<li>在“一切皆组件”这个概念基础之上，提出各种“设计模式”，比如下文中的单向数据流/flux等，解决在大型项目中如何应用/解耦的问题。当然这些模式不是强制性的，算是react给出的最佳实践吧。</li>
</ul>
<p>可以说，react的本质就是对<strong>传统DOM操作的一个封装</strong>，使之更易用更易规模化。理解这点非常关键。如果对react的认识只停留在组件的层面，出现问题时就很容易懵，不知如何入手去解决。如果知道它背后其实是DOM，知道了react组件的渲染过程，很多概念都好理解了，包括对React的设计哲学也更容易理解。<br>python有“<a href="https://www.python.org/dev/peps/pep-0020/" target="_blank" rel="external">The Zen of Python</a>”，不知react有没有“The Zen of React”之类的啊。。。<br>此外，理解<a href="https://facebook.github.io/react/docs/component-specs.html#lifecycle-methods" target="_blank" rel="external">生命周期</a>也非常重要，可以帮助理解react的设计理念。</p>
<p>话说，大公司真是有底气自己造轮子啊，JSX这种奇怪的语法，说搞就搞。个人自己造轮子的话，很容易死掉。</p>
<p>虚拟DOM算是react的一大创新吧，也是react能喊出“learn once, write everywhere”的关键。react给我们画了一个大饼：<br><img src="/2016/09/06/zhen-second-hand-qianduan/2.png" alt=""><br>大意就是虚拟DOM能被不同的平台渲染，就像JVM一样，我们只要针对虚拟DOM去写程序就可以了。看着很美好是吧，但<strong>太美好的东西注定不会实现的</strong>。首先跨平台的代码肯定要有些修改的，据说facebook自己用React Native也只能做到70%复用。其次DOM这种抽象结构真的能应付所有情况么？我看悬。</p>
<p>很多人喜欢对比react和angular，但其实二者并不是对等的。angular是典型的google风格，all in one，非常重量级，你前端开发需要的所有东西都能在angular中找到。它是一个封闭的圈子，有自己发明很多奇怪的概念，对你的编码方式/思路侵入性很强。react则如我之前所说，只是对DOM操作的一个封装，而且非常轻量级，抽象层次很浅，DOM做不到的东西，它也做不到。很多事情都要借助第三方。react上手很快，像我这种用惯了jquery的很容易就能理解它的思路。React Native也是大杀器啊，是不是以后我也可以说自己会开发app了😄。<br>而且，angular还有一个很大的劣势，就是1和2不兼容。。。而且2居然是用TypeScript写的。。。感觉这是邪路啊。微软在开源界的口碑可一向不怎么样。</p>
<h1 id="单向数据流">单向数据流</h1>
<p>单向数据流是react中很重要的一个哲学。我的理解，一个组件被渲染成什么样子，取决于：</p>
<ol>
<li>组件自身的状态。根据封装性原则，每个组件内部维护自己的状态，外界不能也不应该去干涉</li>
<li>外界传过来的props。就是组件对外界因素的响应，也是外界干涉组件的唯一方式</li>
</ol>
<p>一个是内因，一个是外因。<br>不知为何，写这段时我总是会想到草履虫。。。想到生物课上讲的“应激性”。。。</p>
<p>所谓单向数据流，就是指props只能从父组件流向子组件。这样，每个组件要做的事情就很简单了：1. 维护自己的状态；2. 接收外部的props并做出反应；3. 看情况是否更新子组件的props。<br>这样看来，每个组件的职责都很明确，非常利于解耦。</p>
<p>这样的设计很简单很美是不是？如果大家都能遵从这样的原则，世界就和平了。可惜，看着很美的设计往往都是有缺陷的，不能覆盖所有情况。就像不可变对象，能减少线程同步的问题，那就把所有对象都做成不可变的？are you kidding me ？<br>这个设计最大的问题是假设子组件与子组件之间不需要通信，并且父组件也无需获知子组件的状态。一些简单的应用确实可以这么假设。但只要稍微复杂一点的应用中，组件之间往往需要共享状态/互相传props，甚至子组件可能修改父组件的状态，为了达到这个目的，就只能写一些<a href="https://github.com/jiangxy/react-antd-admin/blob/master/src/components/DBTable/index.js" target="_blank" rel="external">很恶心的代码</a>：</p>
<ol>
<li>很多子组件自身的状态要“提升”到父组件中，只是为了能和其他子组件共享</li>
<li>props搞得很重，有很多不必要的属性在里面，因为是跟子组件交互的唯一方式</li>
<li>父组件必须传回调函数给子组件，这样子组件状态变化时才能通知到上层</li>
</ol>
<p>写这种代码很头疼，完全破坏了组件的封装性。而且状态的变化很难搞清楚，经常写着写着思路就乱了，要停下来想想。。。</p>
<p>为了解决这种问题，facebook提出了<a href="https://facebook.github.io/flux/docs/overview.html" target="_blank" rel="external">Flux</a>模式，可以类比常见的MVC模式。为啥facebook不套用MVC模式而要重新发明个轮子呢？好像跟react自身的特点有关，网上也有很多讨论。<br>注意这只是一种思路，可以有很多种具体实现，最著名的实现就是Redux，也算是React全家桶中的元老了。我没实际用过Redux，但我写过那种恶心的代码，知道它要解决的痛点是什么。。。我的理解，它提供了一个统一的状态存储的地方，而且数据变化时会有消息通知到对应的组件，有点类似消息队列？</p>
<p>当然Flux/Redux也不是万能的。引入这种模式必然会增加你的应用的复杂度，而且可能连带的引入一些其他的问题，是否使用还是要看自己的需求。如果你像我一样，写组件的过程中觉得组件之间通信太恶心了，别犹豫了快试试吧，人生苦短何必为难自己。。。</p>
<h1 id="状态是万恶之源">状态是万恶之源</h1>
<p>现在越来越觉得，在设计一个系统/模块的时候，“状态”才是优先要考虑的事，无论是前端/后端，无论什么需求，无论什么开发语言。</p>
<p>没有状态的东西（所谓“东西”，可能是一个对象/API/进程/模块/机器，甚至可能是更抽象的概念），就意味着可以快速复制出一个一模一样的。不用为状态操心，也可以避免很多潜在的坑，在解耦、可用性上会有很大的便利。一个例子是不可变对象；另一个印象深刻的例子是storm的nimbus进程，无状态所以随时重启；REST风格API也要求请求是无状态的；MapReduce的<code>share nothing</code>理念也是这样一个思路。与之相对的就是Oracle RAC，share everything，就会导致出问题时非常难处理。</p>
<p>状态让一切变得复杂。在函数式编程中，也会一再强调不可变/幂等性/无副作用的函数，一个道理。</p>
<p>但状态也不可能完全避免，否则这个系统还有啥用，就像人没了记忆一样。如何设计状态、如何设计状态之间的变化、如何设计系统对不同状态的响应，就是我们要思考的事情了。安利下一位大牛的文章：<a href="https://segmentfault.com/a/1190000005704433" target="_blank" rel="external">舌尖上的状态机</a>。</p>
<p>说回react。状态在react中是尤其重要的一件事，因为每个组件都可以有自己的状态，而状态的变化会自动触发render方法。所以，先整理好状态的变化是很重要的，不然写着写着代码就懵了。。。</p>
<p>一般的设计原则就是“最小化”，使用尽量少的状态，参考<a href="https://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html#what-components-should-have-state" target="_blank" rel="external">官方文档</a>。facebook甚至专门提出了“<a href="https://facebook.github.io/react/docs/reusable-components.html#stateless-functions" target="_blank" rel="external">无状态组件</a>”的概念。总之状态越少越好维护，但也不能矫枉过正。</p>
<h1 id="关于Ant_Design">关于Ant Design</h1>
<p>口水<a href="http://ant.design" target="_blank" rel="external">Ant Design</a>（简称antd）很久了，一直想研究下，终于得偿所愿。</p>
<p>对antd的第一印象就是“哎呦这个界面看着不错哦”。其实围绕React的UI KIT也有很多了，比较出名的是<a href="https://react-bootstrap.github.io/" target="_blank" rel="external">React-Bootstrap</a>和<a href="http://www.material-ui.com/#/" target="_blank" rel="external">Material-UI</a>。但antd最大的优势是语言，无论文档还是issues，都是中文，方便了很多。如果有几个差不多的开源项目摆在我面前，我当然选中文的那个啊。无论你英文多熟练，也还是中文看着舒服对不。而且antd社区也很活跃，版本更新很快，提出问题也能很快有人解答，用的人也算比较多。希望国内能有更多的这种开源项目啊。</p>
<p>最近antd又发布了<a href="http://mobile.ant.design/" target="_blank" rel="external">Ant Design Mobile</a>（简称antd-mobile），可以写移动端的H5了，对二手前端来说真是喜大普奔，我也写了个简单的<a href="https://github.com/jiangxy/react-antd-mobile-demo" target="_blank" rel="external">DEMO</a>。简单的需求都不用去求前端同学了，自己搞定。而且antd-mobile似乎也准备支持React Native，持续关注中。</p>
<p>antd对我而言，最大的意义就是不用写样式了（当然也不可能完全避免）。。。毕竟它已经封装好各种各样的组件，直接用就可以了。就像我之前说的，前端开发中最痛苦的事情就是写css。js好歹还算一门语言，对于标准的engineer来说都能很快上手，写各种业务逻辑驾轻就熟。但css就不一样了，每种样式在不同浏览器下有什么区别？常用的布局属性？各种overflow、display搞的头都要炸了。。。搞好css需要大量的经验和实践，不是我这种半路出家的二手前端能很快掌握的。<br>最关键的，我对自己的审美没什么信心。。。我觉得不错的界面，其他人觉得一般；我觉得还可以的界面，其他人一般觉得丑。。。</p>
<p>so，antd真是大救星啊。就像以前jquery时代的Bootstrap/Metronic/AdminLTE一样，但是好用了很多。而且也能追赶下React的潮流不是。</p>
<p>但我还是要吐槽下，<a href="http://ant.design/components/form/" target="_blank" rel="external">Form组件</a>实在是难用。。。这个组件跟其他组件的用法截然不同，各种东西都要从props里取，antd搞了很多黑盒的操作。但这也不能说是antd的锅，而是react的痼疾。react处理各种input元素，本来就很麻烦，见官方文档<a href="https://facebook.github.io/react/docs/forms.html#controlled-components" target="_blank" rel="external">Controlled Components</a>。这种设计会导致表单中输入项一多，很有可能会卡，因为每输入一个字符都要重新render。希望antd能想办法优化下吧。</p>
<h1 id="Webpack是个好东西">Webpack是个好东西</h1>
<p>有人说，前端开发一半的时间都在搭环境。其实很有道理，尤其在前端现在的混乱情况下，对于一个强迫症而言，想搭一个顺手的开发环境，真是各种纠结。</p>
<p>刚开始接触antd时，我直接使用了<a href="http://ant.design/docs/react/getting-started#标准开发" target="_blank" rel="external">官方的脚手架</a>。但我讨厌黑盒，很多东西如果我不了解基本的原理，用着心虚。官方的脚手架就是一个黑盒，在npm + webpack的基础上各种包装，搞出一些奇奇怪怪的东西，比如<a href="https://github.com/ant-design/antd-tools" target="_blank" rel="external">antd-tools</a>/<a href="https://github.com/ant-design/antd-init" target="_blank" rel="external">antd-init</a>/<a href="https://github.com/dora-js/dora" target="_blank" rel="external">dora</a>（这个好像不是antd团队搞出来的，但也是支付宝的）之类的，美其名曰一站式解决方案。要不怎么说前端喜欢自己造轮子呢。</p>
<p>也许对新人而言这种方式确实比较好吧，毕竟可以很快开始投入编码。但碰到问题怎么办？去研究这些黑盒？就算花很大力气研究明白了，对自己又有什么益处呢？与其研究这些自己造的轮子，我为啥不去直接去研究“业界标准”webpack呢？webpack如果研究明白了，以后很长时间都会受益吧。</p>
<p>同理我也不想用各种react工程模版，比如<a href="https://github.com/kriasoft/react-starter-kit" target="_blank" rel="external">这个</a>还是WebStorm官方推荐的，感觉都是加了特技的啊，各种不需要的功能都duang duang duang的扔进去。</p>
<p>于是我就走上了绕过官方脚手架，自己搭建环境的不归路。。。纠结了好久啊，结果见<a href="https://github.com/jiangxy/react-antd-admin/blob/master/docs/Structure.md" target="_blank" rel="external">这里</a>。</p>
<p>说回webpack。最开始我以为这是跟maven类似的一个构建工具。但实际用下来发现不太一样：</p>
<ul>
<li>webpack对工程结构没有任何约定</li>
<li>maven的依赖管理，用npm去实现，跟webpack没啥关系</li>
<li>webpack有点像maven-compiler-plugin插件的加强版</li>
</ul>
<p>说白了，webpack就是一个编译工具，又兼一点打包的功能。但它的强大之处在于：</p>
<ol>
<li>各种loader可以支持特定语法。比如babel-loader可以让你使用ES6甚至ES7的语法，也可以支持react特定的JSX语法。loader还可以实现各种神奇的功能，比如react-hot-loader，发挥自己的想象力吧。</li>
<li>各种plugin，也能实现很多神奇的功能。常见的就是压缩&amp;混淆代码。</li>
</ol>
<p>loader + plugin的机制让webpack变得非常灵活，可以各种自由定制，也让强迫症多了很多纠结的地方。。。最后我的配置文件见<a href="https://github.com/jiangxy/react-antd-admin/blob/master/webpack.config.js" target="_blank" rel="external">这里</a>。<br>React + Webpack的搭配，写起代码来非常爽。如果不用webpack，你的JSX语法就要单独编译，调试起来也很麻烦。而使用webpack的babel-loader，编译过程对你而言是完全透明的。再搭配上<a href="https://webpack.github.io/docs/webpack-dev-server.html" target="_blank" rel="external">webpack-dev-server</a>和<a href="https://github.com/gaearon/react-hot-loader" target="_blank" rel="external">react-hot-loader</a>，调试也非常方便。写React的基本都是这么一套配置。</p>
<p>但webpack似乎更适用于SPA，对于一些多页面的应用似乎不太好用。</p>
<h1 id="ES6也是个好东西">ES6也是个好东西</h1>
<p>很早就知道ES6，但一直没有大规模的用过，最多用用<code>for-of</code>之类的语法。总的感觉，ES6不算是一次彻底的变革，更像是在ES5的基础上加了各种语法糖，让写代码的时候能够更舒服点，但底层其实是没啥变化的。虽然各大浏览器还没有完全支持ES6，不过有了<a href="http://babeljs.io/" target="_blank" rel="external">Babel</a>这种神器，根本不用担心兼容性，最多可能加些运行时的polyfill。</p>
<p>我最常用的ES6特性，无非是class/import/箭头函数之类的，确实很爽。值得庆幸的是终于不用再跟prototype打交道了。我一直觉得js的prototype是个很奇怪的设计。。。强行面向对象。但如果要兼容一些老的代码，还是要用prototype。</p>
<p>感觉以前写js真的是“写脚本”，跟写bash之类的没啥区别；现在写js就真的是“写程序”了。其中区别，自己体验过才能理解。话说js越来越像java了。。。也越来越规范了。ES7都快出来了，这样强行每年一个版本真的好么。。。</p>
<p>ES6的教程我推荐<a href="http://www.infoq.com/cn/es6-in-depth/" target="_blank" rel="external">InfoQ的</a>，讲解很详细，还有<a href="http://www.infoq.com/cn/minibooks/ES6-in-Depth" target="_blank" rel="external">PDF版本</a>。当然事先要对js有些基础。</p>
<p>React能很好的兼容ES6，但写法上要有些变化。参考<a href="http://babeljs.io/blog/2015/06/07/react-on-es6-plus" target="_blank" rel="external">这篇文章</a>和<a href="https://facebook.github.io/react/docs/reusable-components.html#es6-classes" target="_blank" rel="external">官方文档</a>。至于说是用ES5风格的<code>React.createClass</code>还是ES6风格的<code>extends React.Component</code>，完全看个人喜好，反正经过babel之后应该都是没差别的。但个人倾向于ES6的写法，包括模块/集合等，也尽量遵循ES6的标准。</p>
<h1 id="零散的知识点">零散的知识点</h1>
<p>一些零散的东西，记录下备忘：</p>
<ol>
<li>this.props对当前组件而言是只读的</li>
<li>props和state变化都可能引起重新render</li>
<li>很多时候，组件是“单例”的</li>
<li>注意JSX中的<code>className</code>，这是React的一个妥协，不那么优雅</li>
<li>JSX中，内联样式必须通过js对象实现</li>
<li>JSX中，可以为React元素设置一个JSON对象作为属性包，使用<code>{...obj}</code>的语法</li>
<li>mixin感觉是继承的简化版，但很少用到。而且React在ES6语境下是不支持mixin的。</li>
<li>使用this.props.children就可以访问React子元素</li>
<li><code>React.findDOMNode(this.refs.q)</code>也是一个不那么优雅的设计，但很有用</li>
<li>现在跨域请求都流行用<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">CORS</a>了，不用JSONP了，不过貌似safari对CORS的支持有点问题</li>
</ol>
<h1 id="总结">总结</h1>
<p>至此，算是把自己对前端&amp;React的理解总结完毕了。</p>
<p>其实这篇文章2个月之前就想写了，那个时候就开始研究React了。但拖了很久，最主要的原因是我想把之前做的<a href="https://github.com/jiangxy/react-antd-admin" target="_blank" rel="external">通用后台</a>扔到github上，但从自己的一个玩具到一个公开的项目，还是有很多事情要做的。要完善各种边角的功能、测试各种流程、补充各种文档等等。再加上工作上事情确实比较多，所以进度很慢。好在趁着G20放假的期间，终于基本搞定了。<br>题外话，正确写一个user guide文档的方法：interesting hello world -&gt; overview -&gt; 分块讲解，写文档过程中的一点小小感悟，虽然这次也没用上就是了。。。</p>
<p>以前我也尝试过学习React，大多半途而废，看了下教程就放弃了。没想到这次居然能坚持下来，还搞了个简单的<a href="https://github.com/jiangxy/react-antd-admin" target="_blank" rel="external">项目</a>，我想了想原因：</p>
<ol>
<li>一个好的入门教程非常非常重要。很多人推荐<a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="external">阮一峰的React教程</a>，但我看了还是感觉一头雾水。反而<a href="http://www.hubwiz.com/class/552762019964049d1872fc88" target="_blank" rel="external">这个教程</a>我感觉非常赞。教一个零基础的人和一个有基础的人，当然方法也不一样。所以适合自己的教程才是最好的。</li>
<li>Ant Design功不可没，要是没有antd，我估计写个Hello world就该干嘛干嘛去了。</li>
<li>根本原因：都是被逼的啊！没有前端来给我们写界面啊，只能自己上了啊。好在运营后台对前端性能一般没什么要求，易用性/用户体验上也可以商量，二手前端也能应付。。。</li>
</ol>
<p>话说，我身为一个java开发，第一次认真搞的开源项目居然React的，世界真是奇妙啊。。。<br>最后分享一个ppt吧，之前组内分享用的，<a href="https://pan.baidu.com/s/1geZkgsb" target="_blank" rel="external">《二手前端心得》</a>，不过技术人员做的ppt嘛，一般都不咋地。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="/2015/09/21/second-hand-frontend/">《二手的前端开发》</a>续集，继续折腾，跳了React的大坑。。。</p>
]]>
    
    </summary>
    
      <category term="react" scheme="http://jxy.me/tags/react/"/>
    
      <category term="前端" scheme="http://jxy.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ML门外汉的哀嚎]]></title>
    <link href="http://jxy.me/2016/06/10/machine-learning-outsider/"/>
    <id>http://jxy.me/2016/06/10/machine-learning-outsider/</id>
    <published>2016-06-10T05:40:38.000Z</published>
    <updated>2016-06-29T10:05:28.000Z</updated>
    <content type="html"><![CDATA[<p>每月总有那么几天，不吐不快。</p>
<a id="more"></a>
<p>最近机缘巧合，研究了一些人工智能相关的东西。发现了各种槽点。。。<br>研究的头昏脑胀，总算稍微有点眉目。记录下。</p>
<p>我的理解不一定是对的，只是吐槽而已。<br>但我必须给自己一个能自圆其说的解释，否则寝食难安啊。</p>
<h1 id="啥是智能？">啥是智能？</h1>
<p>说到底，到底啥是智能？人工我能理解，但怎样才算是智能？通过图灵测试就是智能了？会解方程是不是也是一种智能？会矩阵分解就是更高层次的智能了？AI(Artificial Intelligence)这个词的边界，到底在哪里？也许根本就没有边界吧。。。这更像是个营销词汇，让围观群众们不明觉历罢了。就像所谓的bigdata，也是个没有边界的词，适合营销，但不适合作为严格的定义。<br>所以我很能理解为什么70年代AI那么火，这名字听着就NB啊。不过火了一段时间就沉寂下来了，因为大家发现似乎也没有那么NB。。。机器还是只能做一些简单的事。莫非bigdata也要重复这条老路。。。</p>
<p>如果认为只要能解决问题就算AI，那我们是不是发明AI好多年了。。。各种软件都算是一定程度上的AI了。不过大家感情上可能很难接受。就像我小时候觉得，机器人一定是有手有脚，长得像人一样的。结果某天电视上指着一个机械臂跟我说“机器人生产线替代人类”之类的，我幼小的心灵受到了冲击——只有手臂连手指都没有，也特么能算机器人？</p>
<p>当然也可能AI有自已的严格定义，但是我不知道。不过话说回来，AI说是Computer Science的终极目标也不为过吧。就像统一场论，就像理想国，就像那啥主义一样，都是我们的美好愿景。毕竟不能只有眼前的代码，也要有诗和远方嘛。</p>
<p>而且人工智能的研究还有个特点，有点像个黑盒，学术点说就是“可解释性”不强。比如最近很火的深度学习，可能稍微改改参数效果就会提升很多，但是原因大家都说不清楚。。。光是调参数就能搞出很多paper来。“我不知道我是怎么做到的，反正就是做到了”。。。</p>
<p>不过也许AI确实应该是个黑盒。对于人类而言，我们碰到问题，会经过自己的“思考”、各种“推理”，再形成自己的答案。但我们自己也说不清中间的过程是怎样的。如果机器直接知道所有问题的答案，类似一个Map，每个问题它都能直接给出答案，那它算是有“智能”么？虽然它可以对所有问题给出正确答案，但却没有经过“思考”的过程。如果把它看作一个黑盒，确实应该算是有智能了。有点像大刘的“诗云”的赶脚。。。如果机器能穷举出所有可能的诗，我们就能说它会做诗么？<br>不过图灵测试是不管这些的，它不限制你的方法，无论是基于规则的还是基于统计的，反正表现的像个人就行。有点像python的duck-typing机制，“叫起来像鸭子，游起来像鸭子，那它就是鸭子”。</p>
<h1 id="名词控">名词控</h1>
<p>对于人工智能我是没什么基础的，只知道一些简单的机器学习算法，分类、聚类啥的。但是总是会听说很多高大上的名词：人工智能/机器学习/深度学习/神经网络。。。看着就晕，他们之间是什么关系？</p>
<p>也许大概是下面这样：<br><img src="/2016/06/10/machine-learning-outsider/1.png" alt=""></p>
<p>卧槽这图怎么这么大，还不能缩小。</p>
<p>人工智能，如上所述，是非常非常宽泛的一个概念。为了实现人工智能，人们尝试了很多种方法，所以这里面有很多派别。比较出名的就是基于规则的专家系统，把人类世界的各种“知识”作为规则灌输给机器人，这也是比较容易想到的一条路。所以很多新闻为了吸引眼球就会鼓吹“机器人已经学会了整套大英百科全书”。但是事实证明这条路是走不通的，因为“规则”是无穷尽的。这派很出名的人物就是<a href="https://en.wikipedia.org/wiki/Marvin_Minsky" target="_blank" rel="external">明斯克</a>，高中时我就从一些科普读物中知道这个人，不过是作为学术霸权的反面典型出现的。。。</p>
<p>机器学习，是人工智能比较成功的一个分支，很多时候可以甚至可以说是代表了人工智能。如果说专家系统是基于理想主义的，让机器去“理解”这个世界，那机器学习就是基于实用主义的，我不管机器是不是真的“理解”，反正它给我的结果能用就行。机器学习<strong>本质上是基于统计</strong>的，去发现数据的内部规律，进而预测一些未来的情况。但机器学习能做的其实也很有限，大多数情况下只是用一个函数去拟合训练数据，也就是所谓的“模型(model)”，或者是“假设(hypothesis)”，然后拿着这个函数去预测未来的值，当然实际上肯定没我说的这么简单。但有些问题是不能用这个方法解决的啊，比如“如何找到女朋友”这种问题。。。</p>
<p>神经网络，简称ANN，是机器学习理论中提出的一个模型。也有叫做“感知机(perceptron)”、“多层感知机(MLP)”的，都一个意思，历史遗留问题。是对人类神经系统的一种简单抽象，看着好像很高大上的样子，说到底其实就是用来模拟一些函数的工具。之前说过，机器学习通常都要用一个函数去拟合训练数据，怎样找到这个函数？如果我们假设这个函数是线性的，比如一条直线，那就比较好找到。如果是更高阶、更复杂的函数咋办？数学上可以证明，有一个隐层的神经网络就可以逼近任意复杂的函数。别问我咋证明的，我一介学渣怎么会知道。。。题外话，复杂的函数真的可以很复杂，经常在zhihu上看到一些诡异的函数图形。。。<br><img src="/2016/06/10/machine-learning-outsider/2.png" alt=""><br>如上图，整个系统分多个层次，一个输入层，一个输出层，中间还有多个隐层。按传统的定义，这是一个2层的神经网络，不算输入层。每个神经元接受上一层的多个输入值，经过自己的一些运算，再给出输出值。有几点要注意的：</p>
<ol>
<li>按传统的定义，每个节点的运算都只是简单的sum，然后经过一个“激活函数”，决定输出是0还是1，这个激活函数有很多种选择，比较常用的是sigmod函数。但我不是很清楚为何要这样设计，如果每个节点的计算过程更复杂会怎样？如果输出的不止是0和1又会怎样？也许数学上可以证明没必要的吧，我不清楚。每一层都可以指定激活函数，线性/非线性都可以，不知道同一层中是否可以选定不同的激活函数。</li>
<li>每个节点处理输入的时候是有权重的，或者说，上图中的“连接”是有权重的。确定权重的过程就是学习的过程。</li>
<li>每个节点不一定要接受上一层所有的输出，换句话说，上图不一定是“全连接”的。如何连接各个节点也是门学问。</li>
</ol>
<p>没有隐层的神经网络，最初被称为“感知机”。明斯克为啥被称作学术霸权，就是因为他写了本书把感知机批判的一无是处，最著名的一个黑点就是感知机不能解决异或(XOR)问题，因为这是无法用简单的线性函数来拟合的。他还断言多层的神经网络也没啥前途，因为计算量太大，无法训练。他的权威导致ANN相关的研究停滞了很久，直到BP算法被提出来，ANN才又火起来。</p>
<p>ANN最常用的地方是分类。很多机器学习中的常见算法，比如逻辑回归、SVM之类的，本质上都可以看作ANN的特例。<br>这个时候的ANN一般都只有一个隐层，因为理论上一个隐层的ANN就能模拟任意函数，而且层数太多的话不好训练，计算量大。BP算法是从后向前训练的，如果层数太多残差传到前面的层就会很小，出现所谓的梯度扩散，训练出来的模型就会不准。</p>
<p>另外我还有点不太明白，既然只是用来模拟复杂函数的工具，为啥会套上神经网络这么一个高大上的名词。也许最开始的感知机确实是在模拟神经元的运作机制，但发展到ANN后，已经跟神经系统没啥关系了。有句话说的好：“不再盲目模拟人脑网络是神经网络研究走向成熟的标志”。</p>
<p>ANN最为人诟病的一点就是“不可解释”，没有一个可靠的理论依据。隐层要用多少个节点？各个节点之间如何连接？为何这样连接的效果更好？很多时候只能凭经验。而且训练起来也确实很复杂，所以在SVM等算法提出后，ANN的研究又一次沉寂下去。</p>
<p>深度学习，ANN借尸还魂，新瓶装旧酒。2006年，又是<a href="https://en.wikipedia.org/wiki/Geoffrey_Hinton" target="_blank" rel="external">Geoffrey Hinton</a>（BP算法也是他提出的）在Science上发表了一篇论文，证明了多层神经网络的优越性，可以大幅提高准确率，而且训练上的复杂性可以用一些工程上/数学上的技巧克服。他给这种技术起了一个新的名字：深度学习，由此掀起了深度学习的热潮，至今未衰。我觉得深度学习能火爆的几个原因：</p>
<ol>
<li>从理论上证明了多层神经网络有更高的上限，换句话说可以更好的拟合，但也有可能过拟合。</li>
<li>可以用一些技巧克服训练上的难度。</li>
<li>大数据的发展，包括GPU运算的发展，数据量和计算能力都有了极大提升。原来一些不可能完成的计算量现在都是小儿科。</li>
</ol>
<p>通过研究发现，在参数数量一样的情况下，更深的网络往往具有比浅层的网络更好的识别效率。别问我为啥。。。反正DL很好很强大就是了。。。这种程度的研究，一般的学霸都搞不定，更何况我这种学渣了。<br>深度学习作为ANN的继任者，做出了很多创新，但是也继承了一些缺点，比如之前说的“不可解释”。</p>
<p>整个AI领域的发展过程大概就是这样了。AI是一门很古老的学科，很多工作从上世纪四五十年代就开始了，尤其是ANN，经历了很多起起落落。但真的不要对AI报太大希望，机器能做的事真的是非常有限的，AI发展了这么久，能做的也就是预测/分类/聚类。当然很多现实问题都可以抽象为这几种。“怎么找女朋友”的问题，估计它永远都解决不了。。。<br>感觉AI的发展过程和NLP有点像啊，最初大家都是试图基于规则去做，让机器去“理解”。但都走不通，最后回归到基于统计的方法上。</p>
<p>既然说到NLP，就再罗嗦几句。我一直奇怪NLP算不算是AI领域的？也许不算吧，感觉NLP是一个交叉学科，会用到机器学习的一些东西，但不全是机器学习，会用到很多其他技术。也许分词/文本分类算是机器学习，但词性标注之类的应该不算。<br>推荐系统也是一个交叉学科，会用到机器学习一些技术，但又不完全是。<br>数据挖掘同理。<br>这些学科，更像是各种技术的集合，就像计算机科学是电气/数学/物理等的集合一样。</p>
<h1 id="机器学习">机器学习</h1>
<p>扯了半天终于扯到正题了。。。下面只是我自己的理解，可能有些是错误的。</p>
<p>机器学习算法跟普通的算法设计不太一样。普通的算法，比如排序/DFS之类的，算法逻辑是“固定”的，可以应用到任意输入上，算法的行为不会因为输入的不同而改变。但机器学习的算法非常依赖数据，就像之前说的，它是用一个函数去刻画已有数据的内部规律（实际上不一定是函数），然后去预测未来的数据。如果输入的数据量不够大，或者质量不好，它生成的函数（或者说模型）效果就会很差。说到底，它还是脱胎于统计学的，如果样本数量不够，统计学是无能为力的。</p>
<p>其实“机器学习”这个词也很难定义，边界也很模糊。。。与其研究这些形而上的东西，不如直接看看机器学习中有哪些算法、能帮我们做到什么。</p>
<p>几个基本概念：</p>
<ul>
<li>特征(feature)：这是最关键的东西，通俗点说，就是从哪些维度去描述一个事物。比如“早上好”这句话，如果以词为特征，可能是[“早上”, “好”]；如果以字为特征，可能是[“早”,”上”,”好”]；如果以字数为特征，就是[“3”]。而且这些特征可以任意组合。特征选的好不好会直接影响算法效果。而且特征的选取是很难的，很多时候只能凭经验。特征一般会用一个向量表示。</li>
<li>目标(target)：就是要预测的值。对于有些算法而言其实没有target，比如聚类。</li>
<li>数据集：用于统计分析的样本数据。数据一般会分成训练集和测试集。所谓的数据，很多时候就是一个features-&gt;target的映射。</li>
<li>假设(hypothesis)：就是训练所得的函数，由于一些历史原因，被称作hypothesis。</li>
</ul>
<p>按训练数据集的类型分类：</p>
<ul>
<li>监督学习。输入的数据是有标注的，或者说，是有target的。监督学习最常解决的问题就是回归和分类。回归一般用于预测一个连续的值，分类用于预测一个离散的值。分类算法又可以分为二分类、多分类等等。其实现实世界中的很多问题都可以抽象为分类问题，所以分类算法应用很广。</li>
<li>无监督学习。输入的数据没有target，只有features。比如聚类。我只稍微知道一点k-means。</li>
</ul>
<p>但无论如何，数据都是必须要有features的，无论这个features是人工选取的，还是计算出来的。如果要为一个人选取特征，我们可以手工选取性别/年龄/身高/肤色之类的，这是因为我们有着“经验”，或者叫做“先验知识”/<a href="https://en.wikipedia.org/wiki/Inductive_bias" target="_blank" rel="external">Inductive_bias</a>，我们知道这些属性“足够”描述一个人。但对于未知的数据，我们该如何选取特征？比如我们预测一个人该去男厕所还是女厕所，明显可以根据性别分类，但训练数据中的特征却不包含性别，只有身高/肤色之类的，于是呵呵了。。。训练出来的模型可能跟实际偏差非常大。有一种方法是“乱枪打鸟”，把所有可能的特征都选出来，总会有一些特征能生效的。似乎深度学习中就是应用了这种思想。但过多的特征也会造成计算量增加，要自己权衡的。</p>
<p>前面说过，机器学习大多是用一个函数刻画数据的内部规律（或者说去拟合数据），得出这个函数的过程就是训练过程。但这个描述也不是很准确：</p>
<ol>
<li>数据的内部规律，未必能用一个函数来描述，还有各种树模型、XX模型之类的。其实数据到底有没有规律也不过好说。。。数据的内部规律是我们假设出来的，我们假设它是线性的，于是才会用一个线性函数去拟合。也可能数据根本是没有规律的，但我们也能强行搞出一个线性函数，只是效果很差罢了。</li>
<li>不是所有的机器学习算法都有训练过程。无监督的算法肯定都没有训练过程的，一些有监督的算法也没有训练过程，比如KNN。是否有训练过程，也是取决于我们对数据规律做了怎样的“假设”。</li>
</ol>
<p>关于Inductive_bias，<a href="https://www.zhihu.com/question/29271217/answer/45665100" target="_blank" rel="external">这个zhihu帖子</a>讲的很好。</p>
<p>一般过程：</p>
<ol>
<li>准备数据。特征选取、归一化。这是所有算法都要做的。特征的选取之前有说过，归一化是为了让特征更“规整”，不会让某些特征影响过大。</li>
<li>训练模型。如前所述，不是所有算法都有训练过程的。训练过程目的是为了让模型的误差最小，或者说是找到loss function（也有叫做cost function/error function的）的最小值，常用梯度下降法。这里有很复杂的理论，如何处理局部最优，如何处理过拟合等等。</li>
<li>使用模型。使用训练好的模型预测新的数据。</li>
</ol>
<p>机器学习的理论也很古老了。。。但受限于计算能力，似乎一直没有什么很成功的应用。也可能是我孤陋寡闻。好像之前有什么无人驾驶汽车就是用机器学习算法驱动的。近些年随着bigdata的火热，计算能力/数据处理能力大幅增加，各种开源的算法库的出现（mahout、spark mllib），感觉机器学习的门槛下降很多，相关的应用也多起来了。</p>
<h1 id="深度学习">深度学习</h1>
<p>这块我就更是不懂了。。。只是看了些资料。<br>上面已经说过，深度学习是在ANN基础上发展而来，摘录一段话：</p>
<blockquote>深度学习的实质，是通过构建具有很多隐层的机器学习模型和海量的训练数据，来学习更有用的特征，从而最终提升分类或预测的准确性。因此，“深度模型”是手段，“特征学习”是目的。区别于传统的浅层学习，深度学习的不同在于：1）强调了模型结构的深度，通常有5层、6层，甚至10多层的隐层节点；2）明确突出了特征学习的重要性，也就是说，通过逐层特征变换，将样本在原空间的特征表示变换到一个新特征空间，从而使分类或预测更加容易。与人工规则构造特征的方法相比，利用大数据来学习特征，更能够刻画数据的丰富内在信息。</blockquote>

<p>是不是特抽象？每一个字我都认识，但这段话到底是在说啥。。。</p>
<p>之前说过，选择特征是非常麻烦的事情。特征选的不好，算法效果就会很差。而人工选择特征又很麻烦，只能凭经验。所以能不能让机器自己选择特征？<br>深度学习可以部分达到这个目标。它可以将原始的特征，经过若干次变化，生成更多的特征。比如输入的特征是[x, y]，它可以将这个特征变成[x, y, sin(x), y^2, x*y]之类的，当然实际上没这么简单。这就是上文所说的“将样本在原空间的特征表示变换到一个新特征空间”，新生成的特征能更好的描述数据的本质，分类/回归的效果也就会更好。别问我为啥，我也不知道。。。<br>那原始特征如何产生呢？也许可以用一些简单的方法吧，比如字向量之类的，不清楚。<br>而且这种特征的变换不是一次性的，跟网络的深度有关。<br>深度学习又被叫做“无监督特征学习（Unsupervised Feature Learning）”，就是因为它实际上是一个学习特征的过程。</p>
<p>深度学习的训练过程，忘了摘录自哪里了：</p>
<ol>
<li>使用自下上升非监督学习，这个过程可以看作是feature learning过程（或者说，它只是学习获得了一个可以良好代表输入的特征，这个特征可以最大程度上代表原输入信号）</li>
<li>自顶向下的监督学习（就是通过带标签的数据去训练，误差自顶向下传输，对网络进行微调）</li>
</ol>
<p>深度学习的网络是逐层训练的(layer-wised training)，之前有个段子就是“专业卷积神经网络训练，每层5元”。。。在所有层都训练完之后，再进行一些微调(fine-tuning)。主要是通过这两种方式，克服传统ANN中训练的难度。</p>
<p>深度学习的训练过程可以是无监督/有监督的，而传统的ANN都是有监督的。但分类系统不可能是无监督的，即使是深度学习，输出的最后也要接一个分类器。</p>
<blockquote>虽说非监督（如DBM方法）是深度学习的一个优势，深度学习当然也可用于带监督的情况（也即给予了用户手动标注的机会），实际上带监督的CNN方法目前就应用得越来越多，乃至正在超越DBM。</blockquote>

<p>另外卷积神经网络（CNN）好像和深度学习其实没啥关系，93年就出现了，本质上还是传统的ANN。</p>
<p>深度学习还有个特点，训练时似乎没有分布式的版本，大家都是单机上搞一堆GPU去训练。似乎有人说分布式训练的效果还不如单机？已有的一些工具，比如<a href="https://www.tensorflow.org/" target="_blank" rel="external">TensorFlow</a>/<a href="http://caffe.berkeleyvision.org/" target="_blank" rel="external">Caffe</a>/<a href="http://torch.ch/" target="_blank" rel="external">Torch</a>，也都是单机。spark作为大数据领域集大成者，没有包含深度学习相关的工具，也是有点奇怪。。。<a href="http://geek.csdn.net/news/detail/82614" target="_blank" rel="external">Spark Summit 2016</a>中提到了一些，Caffe on Spark之类的，好像挺有意思。</p>
<h1 id="聊天机器人">聊天机器人</h1>
<p>聊天机器人的概念也有些年头了。。。但是这个概念似乎最近又火了起来，可能是各大公司带了波节奏吧，见<a href="http://36kr.com/p/5048193.html" target="_blank" rel="external">这里</a>/<a href="http://tech.qq.com/a/20160623/064924.htm" target="_blank" rel="external">还有这里</a>，连<a href="http://36kr.com/p/5047975.html" target="_blank" rel="external">盈利模式</a>都想好了。甚至有人说，Facebook Messenger可以变成App Store，大家都在上面开发bot，重现当年开发app的狂热。</p>
<p>其实语音助手也出现好多年了吧，比如siri。当年某个小伙伴还很自豪的跟我炫耀：“phone my little brother”——于是自动给某人打电话。为啥现在突然火了？是因为app太重了？于是想用bot去轻量级的承载各种服务？其实有点类似微信公众号，很多尝试性的业务都适合用微信公众号来做，直接做app成本太高，而且app获取用户太难了。<br>微信公众号也算是个简易版机器人了，就是看起来没那么智能。<br>大家都把前景描述的很美好，自动分析你的需求/个性化推荐/帮你叫外卖之类的。我倒是谨慎乐观，想想人工智能的前几波浪潮吧。</p>
<p>YY了机器人的几种做法：</p>
<ol>
<li>模式匹配。很简单，就是个问答系统，像是数据库的like语句。用户输入某个句子，系统尝试在已有的语料里寻找，命中则返回。这是最容易想到的方式。</li>
<li>机器学习。用一大堆已有的语料去训练，然后让机器人自己预测下一句。但是缺陷很大，语料都是死的，机器人只能严格匹配，换一种说法它就无法处理了。而且它也不能触发服务，比如语料中显示“明天下雨么”的下一句是“会下雨”，这只是个special case。正确的行为是根据天气预报给出答案，机器人却只会机械回复“会下雨”。</li>
<li>语义理解。让机器人去理解一句话的意思，再根据用户意图选择回答，这里还是要靠规则。我对NLP完全不了解，不知道能不能做到这种程度。有个很有趣的服务<a href="http://wit.ai" target="_blank" rel="external">wit.ai</a>似乎可以自动帮你分析语义，不知道实际效果如何。</li>
</ol>
<p>感觉上，模式匹配还是主流。。。虽然low，需要很多人工的工作，但对用户体验比较好。其他的实现方式都可能出现前言不搭后语、逻辑混乱的情况。。。最著名的开源机器人应该是<a href="http://www.alicebot.org" target="_blank" rel="external">A.L.I.C.E.</a>吧，大概看了下它的实现，本质上也是模式匹配。它最大的贡献是AIML标准。不过这个项目也很古老了。最近试用了老东家的客服机器人<a href="http://qiyukf.com" target="_blank" rel="external">网易七鱼</a>，也是模式匹配，需要自己录入各种关键词和对应的回答，不知宣传中的语义分析和深度学习用在哪里。。。</p>
<p>对机器人而言，录入语料是最大的麻烦事。如何结构化？结构化到什么程度？如何尽量减少人工的工作？如何平衡机器的“智能”和人工的规则？<br>我理想中的机器人，直接把一本书灌给它，它自己提取出其中的对话并学习，然后把这些对话应到到聊天中。或者直接灌一些聊天记录给它。当然这个有点太理想化了。。。</p>
<h1 id="一些资料">一些资料</h1>
<p><a href="http://www.andrewng.org/" target="_blank" rel="external">Andrew Ng</a>的机器学习公开课，经典中的经典，这门课在Coursera上还有<a href="https://zh.coursera.org/learn/machine-learning" target="_blank" rel="external">另外一个版本</a>：<br><a href="http://open.163.com/special/opencourse/machinelearning.html" target="_blank" rel="external">http://open.163.com/special/opencourse/machinelearning.html</a></p>
<p>给出了一些matlab中的使用实例，对于理解很有帮助：<br><a href="http://www.cnblogs.com/heaad/archive/2011/03/07/1976443.html" target="_blank" rel="external">http://www.cnblogs.com/heaad/archive/2011/03/07/1976443.html</a></p>
<p>讲了各种历史，非常赞：<br><a href="http://www.36dsj.com/archives/39775" target="_blank" rel="external">http://www.36dsj.com/archives/39775</a></p>
<p>非常详细的资料集合：<br><a href="http://blog.sina.com.cn/s/blog_6a1b8c6b0101h9ho.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_6a1b8c6b0101h9ho.html</a></p>
<p>关于ANN的衰落讲的较好：<br><a href="http://36kr.com/p/208510.html" target="_blank" rel="external">http://36kr.com/p/208510.html</a></p>
<p>PCA降维：<br><a href="http://blog.csdn.net/watkinsong/article/details/8234766" target="_blank" rel="external">http://blog.csdn.net/watkinsong/article/details/8234766</a></p>
<p>Google随tensor flow开源而开放的一个小玩具，可以帮助理解一些概念，很有意思：<br><a href="http://playground.tensorflow.org/" target="_blank" rel="external">http://playground.tensorflow.org/</a></p>
<p><a href="http://news.cnblogs.com/n/547170/" target="_blank" rel="external">各位大佬，别再拿人工智能当春药了！</a><br>确实现在人工智能有过度炒作之嫌，就像当初的云计算，现在的大数据一样。</p>
<p>其他一些<br><a href="http://hahack.com/reading/ann2/" target="_blank" rel="external">http://hahack.com/reading/ann2/</a><br><a href="http://deeplearning.stanford.edu/wiki/index.php/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C" target="_blank" rel="external">http://deeplearning.stanford.edu/wiki/index.php/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C</a><br><a href="http://nautidea.com/nautidea/articles/5694f6449eb5f06447e7a87b" target="_blank" rel="external">http://nautidea.com/nautidea/articles/5694f6449eb5f06447e7a87b</a><br><a href="http://blog.sciencenet.cn/blog-4099-785174.html" target="_blank" rel="external">http://blog.sciencenet.cn/blog-4099-785174.html</a></p>
<p>几篇访谈，了解大牛们的想法，很赞：<br><a href="http://www.infoq.com/cn/articles/interview-yann-lecun" target="_blank" rel="external">对话Facebook人工智能实验室主任、深度学习专家Yann LeCun</a></p>
<p><blockquote>人工智能的每一个新浪潮，都会带来这么一段从盲目乐观到不理智最后到沮丧的阶段。感知机技术、基于规则的专家系统、神经网络、图模型、支持向量机甚至是深度学习，无一例外，直到我们找到新的技术。当然这些技术，从来就不是完全失败的，它们为我们带来了新的工具、概念和算法</blockquote><br><a href="http://chuansong.me/n/362966942881" target="_blank" rel="external">原百度深度学习研究院创始人余凯谈人工智能大趋势</a></p>
<p><blockquote>其他的机器学习的方法可能随着数据的增加，性能提高到某一个点就饱和了。但目前为止对于深度学习我们还没有观察到这点，这可能是它最值得关注的地方</blockquote><br><a href="http://36kr.com/p/212692.html" target="_blank" rel="external">百度最强大脑在想什么？ —— 36氪硅谷专访百度首席科学家 Andrew Ng</a><br>Ng去了百度让人很意外。。。</p>
<h1 id="无关的读后感">无关的读后感</h1>
<p>其实跟本文没啥关系，只是最近读的一些文章而已，单独开篇也不值得，塞到这里好了。</p>
<p><a href="http://coolshell.cn/articles/17295.html" target="_blank" rel="external">让我们来谈谈分工</a>：有句话讲的很好：“作为工作的人，当你选择工作或任务的时候，你是选择做支持性的工作，还是做产出性的工作？你是选择做劳动密集型重复工作，还是做知识密集型的创新性的工作？”每个人都会有自己的答案，但很多时候这不是自己能决定的。创新性的工作失败风险会更大，如果失败，是否有退路？创新性的工作可能很久都没有产出，评KPI会很吃亏，自己是否能承受？</p>
<p><a href="http://www.freebuf.com/articles/web/29942.html" target="_blank" rel="external">SQL注入之SQLmap入门</a>：听了一个安全方面的分享才知道sqlmap，现在工具都这么智能了啊。。。我记得以前都要手动加单引号什么的，再一遍遍构造各种奇怪的url。</p>
<p><a href="http://www.infoq.com/cn/articles/exploration-of-distributed-mysql-cluster-scheme" target="_blank" rel="external">分布式MySQL集群方案的探索与思考</a>：数据库中间件是每个公司都会碰到的问题，本文详述了各种实现方案，很赞。</p>
<p><a href="http://www.infoq.com/cn/articles/https-difficult" target="_blank" rel="external">HTTPS之难</a>：运营商劫持太严重了，所以我们的一些系统也在做https改造。好在有统一的网关可以做掉。我觉得最难的地方是很可能考虑不周全。。。以为只要改掉系统A的接口就可以，结果又牵连到系统B，系统B又会牵涉到C。https改造是真正的牵一发而动全身。</p>
<h1 id="碎碎念">碎碎念</h1>
<ol>
<li>怎么又写了这么多。大概是拖的太久了。。。</li>
<li>最近领悟了一个原则：基础比什么都重要。招人的时候，即使对方没有任何业务经验，只要基础好，都不是问题。基础好的人可以快速切到其他领域，无论是新的技术还是新的业务。我就只能算是一个标准的engineer，说不上好也说不上坏。。。</li>
<li>所谓的“全栈”，不是说你什么都要会。而是需要你会的时候，你能很快的学会。所以基础很重要。</li>
<li>不要总想着高大上的做法，duck-typing，只要能达到效果就好。但也不能搞一堆if-else。。。有人跟我说写业务代码就是一堆if-else。。。还是要适度。</li>
<li>线性代数非常神奇，可以简化很多写法/计算，虽然我忘得差不多了。我特么就记得矩阵乘法了。</li>
<li>能把一门技术以通俗易懂的形式讲出来，是非常了不起的。我见过很多人/很多presentation，搞各种高大上的名词把人弄晕。要么是那个人确实有货，但表达不好，要么就根本是徒有其表。</li>
<li>工作烦躁的时候就去刷刷leetcode，冷静下，效果挺好的。不过刷题很快，写题解很慢啊。。。不知猴年马月才能写完。</li>
<li>ML真的不是make love的缩写么？无所谓了反正都是门外汉。。。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>每月总有那么几天，不吐不快。</p>
]]>
    
    </summary>
    
      <category term="杂谈" scheme="http://jxy.me/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="machine learning" scheme="http://jxy.me/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于数据库单元测试]]></title>
    <link href="http://jxy.me/2016/05/06/db-unit-test/"/>
    <id>http://jxy.me/2016/05/06/db-unit-test/</id>
    <published>2016-05-06T07:34:43.000Z</published>
    <updated>2016-05-06T12:05:49.000Z</updated>
    <content type="html"><![CDATA[<p>一般我们都会用JUnit写单元测试，但是如果测试涉及到数据库，就会有点麻烦。<br>总结下我的一些解决方法，当然未必是最好的。</p>
<a id="more"></a>
<p>单元测试的原则是尽量不要有外部依赖，每一个测试都是可独立运行的。“A good test set is self-sufficient and creates all the data it needs”。</p>
<p>如果测试中要连数据库，目前的做法一般是在配置文件中写死测试数据库的地址。如果我换了一个网络环境，比如说从办公网络切换回家里，就没办法跑测试了。对于项目开发而言这是完全可以接受的，但对于完美主义者而言就很别扭。。。我是希望单元测试能够“write once, run everywhere”。</p>
<p>如果测试依赖于数据库的状态，就更糟糕了。可能在某一时刻测试能通过，但谁更新了一条记录，就会fail，这种问题排查起来也很麻烦。如果测试代码本身就要修改数据库，但测试结束后没有改回来，可能会引起更多的隐形问题。理论上测试前后所有的状态应该是一致的。</p>
<p>综上，其实有两个问题：</p>
<ol>
<li>测试依赖于具体的数据库实例。这个实例只有在特定条件下能访问（内网/localhost）。</li>
<li>测试依赖于数据库的状态，而这个状态不可控。</li>
</ol>
<p>解决思路也有两种：</p>
<ol>
<li>每次测试都搞一个“空白”的数据库。</li>
<li>mock一个DAO层，将所有对数据库的操作用mock对象模拟。</li>
</ol>
<h1 id="Mockito">Mockito</h1>
<p>关于mock首先想到的就是<a href="http://mockito.org/" target="_blank" rel="external">Mockito</a>，我觉得这是用着最简单的mock框架，可以用来mock各种对象，当然也可以mock DAO。<br>Mockito的用法就不详细说了，而且Mockito的源码可读性很好，碰到问题看源码很方便。</p>
<p>问题在于，如果要把所有DAO的方法都mock一次，工作量也太大了。。。而且这些代码是不能复用的。<br>能用配置解决的尽量不要写代码。。。</p>
<h1 id="DBUnit">DBUnit</h1>
<p><a href="http://dbunit.sourceforge.net/" target="_blank" rel="external">DBUnit</a>是专门用来解决问题2的，用来维护测试前后数据库的状态。它的思路很简单：测试前备份数据库，准备测试需要的数据；测试后，从备份中还原数据库的状态。具体的用法不详细说了。</p>
<p>DBUnit的问题在于：1.不能解决多个人同时更新状态的问题。官方的最佳实践要求每个开发人员有自己测试数据库。2.没解决网络环境的问题。3.要写很多xml配置文件，很烦。。。</p>
<h1 id="HSQLDB">HSQLDB</h1>
<p>这个要重点说说。其实刚开始碰到数据库单元测试的问题时，我的想法很简单，问题的根源就在于所有的测试共用同一个数据库实例，那就搞个嵌入式数据库好了啊，每个测试初始化自己“专用”的数据库，自己创建schema/创建测试数据。这样可以保证这个测试在任何时间、任何地方都可以执行。正好以前调研WhiteElephant知道了hsqldb，就拿来试试。</p>
<p>其实嵌入式数据库有很多，最出名的应该是SQLite。还有derby，用过hive的人应该都知道。还有一个叫H2的。但<a href="http://hsqldb.org/" target="_blank" rel="external">HSQLDB</a>的优势在于：1.纯java写的，兼容性好；2.内存模式很强大，类似一个沙盒，很适合用于测试。</p>
<p>首先在maven中引入依赖：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">scope</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></div></pre></td></tr></table></figure>

<p>用hsqldb创建一个内存数据库非常简单，只要写入一个特殊的jdbc url即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Class.forName(<span class="string">"org.hsqldb.jdbc.JDBCDriver"</span>);</div><div class="line"><span class="comment">// 注意url中的syntax_mys参数，会让hsqldb兼容mysql的语法，虽然兼容的不完全。。。</span></div><div class="line"><span class="comment">// 对于oracle也有一个类似的参数，可以让hsqldb兼容oracle的varchar2之类的</span></div><div class="line">DriverManager.getConnection(<span class="string">"jdbc:hsqldb:mem:db;sql.syntax_mys=true"</span>,<span class="string">"sa"</span>,<span class="string">""</span>);</div></pre></td></tr></table></figure>

<p>拿到了Connection对象，就可以做自己的事了，可以任意按自己的业务逻辑操作。</p>
<p>我是把建表语句写到一个文件里，然后在测试用例初始化时加载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext ctx;</div><div class="line"></div><div class="line"><span class="annotation">@BeforeClass</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup</span>() <span class="keyword">throws</span> SQLException, IOException {</div><div class="line">    ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring/applicationContext.xml"</span>);</div><div class="line"></div><div class="line">    createSchema();  <span class="comment">// 创建schema</span></div><div class="line">    createData();   <span class="comment">// 创建本次测试需要的数据</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createSchema</span>() <span class="keyword">throws</span> IOException, SQLException {</div><div class="line">    Object obj = ctx.getBean(<span class="string">"dataSource"</span>);</div><div class="line">    <span class="comment">// 我们测试环境用了bonecp连接池，线上环境用了另一个连接池。。。</span></div><div class="line">    <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> BoneCPDataSource)) {</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"resource"</span>)</div><div class="line">    BoneCPDataSource ds = (BoneCPDataSource) obj;</div><div class="line">    String driver = ds.getDriverClass();</div><div class="line">    <span class="comment">// 如果不是hsqldb，就跳过创建schema的步骤。如果用mysql测试，应该是事先建好表的。</span></div><div class="line">    <span class="keyword">if</span> (!driver.toLowerCase().contains(<span class="string">"hsqldb"</span>)) {</div><div class="line">        System.out.println(<span class="string">"not hsqldb. skip createSchema."</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    Connection conn = ds.getConnection(); <span class="comment">// 直接取出数据库连接</span></div><div class="line">    <span class="comment">// 创建schema，注意hsqldb建表语句和mysql有些不同</span></div><div class="line">    Reader reader = Resources.getResourceAsReader(<span class="string">"hsqldb_schema.sql"</span>);  <span class="comment">// 建表语句都存在这个文件中</span></div><div class="line">    ScriptRunner runner = <span class="keyword">new</span> ScriptRunner(conn);  <span class="comment">// 利用了mybatis的ScriptRunner工具</span></div><div class="line">    runner.setLogWriter(<span class="keyword">null</span>);</div><div class="line">    runner.runScript(reader);</div><div class="line">    reader.close();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 数据库初始化完毕，接下来写自己的测试逻辑</span></div><div class="line"><span class="comment">// spring中所有涉及到数据操作的bean都是引用的同一个dataSource</span></div><div class="line"></div><div class="line"><span class="annotation">@Test</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExpireRule</span>(){</div><div class="line">	<span class="comment">// 省略</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>hsqldb_schema.sql例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- hsqldb的语法跟mysql有些不同，建表语句必须要修改下才能用</span></div><div class="line"><span class="comment">-- 不支持字段级别的comment</span></div><div class="line"><span class="comment">-- 字段名、表名不能用`</span></div><div class="line"><span class="comment">-- 不支持engine、charset之类的语法</span></div><div class="line"><span class="comment">-- 加索引的语法也不一样</span></div><div class="line"></div><div class="line"><span class="comment">-- 有效期规则</span></div><div class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> expire_rule (</span></div><div class="line">  <span class="comment">-- 基础字段</span></div><div class="line">  id <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">  type <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="keyword">status</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  tag <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  comment <span class="built_in">varchar</span>(<span class="number">256</span>),</div><div class="line">  extend_map <span class="built_in">text</span>,</div><div class="line"></div><div class="line">  <span class="comment">-- 其他</span></div><div class="line">  update_time <span class="built_in">bigint</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</div><div class="line">  create_time <span class="built_in">bigint</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line"></div><div class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (id)</div><div class="line">) COMMENT <span class="string">'有效期规则'</span>;</div></pre></td></tr></table></figure>

<p>这样每个测试都不会互相干扰，有自己专用的数据库，自己维护状态。感觉还是比较方便的。</p>
<h1 id="Liquibase">Liquibase</h1>
<p><a href="http://www.liquibase.org/" target="_blank" rel="external">Liquibase</a>其实跟单元测试没啥关系，只是我觉得比较有用，顺便记录下以备忘。<br>liquibase的本质就是一个数据库的版本管理工具。我们在项目中，经常涉及数据表schema的变更，比如加个字段/加个索引之类的，所以数据库也是有版本的概念的。以前的管理方法是直接保存所有的sql语句到一个文件中，然后不断追加，比如：</p>
<figure class="highlight sql"><figcaption><span>dbschema.sql</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># 先是一堆<span class="operator"><span class="keyword">create</span> <span class="keyword">table</span>语句</span></div><div class="line"></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> XXX ...</div><div class="line">cretae <span class="keyword">table</span> YYY ...</div><div class="line"></div><div class="line"># 然后记录每次的修改</div><div class="line"></div><div class="line"># <span class="number">2016</span>-<span class="number">05</span>-<span class="number">01</span> modified <span class="keyword">by</span> xxx</div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> XXX <span class="keyword">add</span> <span class="keyword">column</span> yyy</div><div class="line"></div><div class="line"># <span class="number">2016</span>-<span class="number">05</span>-<span class="number">02</span> modified <span class="keyword">by</span> xxx</div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> YYY ad <span class="keyword">column</span> zzz</div><div class="line"></div><div class="line"># <span class="number">2016</span>-<span class="number">05</span>-<span class="number">03</span> modified <span class="keyword">by</span> jjj</div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> ZZZ ...</div></pre></td></tr></table></figure>

<p>显然这种管理方式比较麻烦，很容易出错。更关键的是没有rollback过程。如果新版本上线了有bug，要回滚到旧版本，数据库也要回滚到旧版，就只能手动操作。</p>
<p>liquibase就是用来解决这种问题的，它使用一个changelog文件跟踪数据库的变化，每次变化可以抽象为一个changeset。通过changelog实现对数据库schema的管理，用户可以update到任意版本，可以回滚，也可以在不同版本之间diff。changelog一般是个xml文件，但也可以直接写sql语句，很方便。详细的用法参考官方文档，这里不列出了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一般我们都会用JUnit写单元测试，但是如果测试涉及到数据库，就会有点麻烦。<br>总结下我的一些解决方法，当然未必是最好的。</p>
]]>
    
    </summary>
    
      <category term="java" scheme="http://jxy.me/tags/java/"/>
    
      <category term="unit test" scheme="http://jxy.me/tags/unit-test/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GitBook开坑纪念]]></title>
    <link href="http://jxy.me/2016/04/16/gitbook/"/>
    <id>http://jxy.me/2016/04/16/gitbook/</id>
    <published>2016-04-16T05:40:42.000Z</published>
    <updated>2016-09-15T15:46:37.000Z</updated>
    <content type="html"><![CDATA[<p>这是个大坑。<br>不过挖坑一向是我的优良品德之一，记得填就好。</p>
<a id="more"></a>
<p>说到坑，印象最深刻的是高中时看的某期《九州》，封底上用超大的黑色字体印着“<strong>十载巨坑，一朝填平！</strong>”。。。当时就吓尿了，这种挖坑不填的事好意思这么高调宣传的？忘了是哪个大大挖的坑了，好像是碎石。。。一个外星人入侵地球的故事。</p>
<p>说回正事，一直想写些长篇大论，如果在blog上写，写一篇文章显得太长；如果分成多篇，又要在标题上加上“1/2/3”之类的序号，很low，想看时也不方便。正好最近发现了<a href="https://www.gitbook.com" target="_blank" rel="external">GitBook</a>，觉得这种写作方式很好，干脆在gitbook上写吧，类似写一本书的形式，相同主题的文章都聚合在一起，看起来方便。其实gitbook本来是用来多人协作的，被我用来当blog了。。。<br>blog本身就只写一些能单独成篇的文章，和一些思考吧。</p>
<p>本篇文章用来做个汇总，在menubar中新增个入口，开的坑都会列在这里，<strong>不定期更新</strong>。</p>
<p>另外要吐槽下NexT主题的图标，用的linecons，但居然把不用的图标都删除了。我本来想选个书籍的图标的，但没有合适的，只能选择个铅笔的。如果要自己新增图标，还要去编辑字体文件，实在懒得折腾了。</p>
<h1 id="《Guava豆知识》">《Guava豆知识》</h1>
<ul>
<li>地址：<a href="https://www.gitbook.com/book/jiangxy/guava-tips/details" target="_blank" rel="external">https://www.gitbook.com/book/jiangxy/guava-tips/details</a></li>
<li>进度：0%</li>
<li>备注：基于18.0版本</li>
</ul>
<p><a href="https://github.com/google/guava" target="_blank" rel="external">Guava</a>一直是我最喜欢的java类库，没有之一。但工作中却见得较少。所以打算总结下guava的各种用法。其实guava的很多思想已经被吸收进jdk了吧。<br>我不打算翻译官方文档，首先官方文档本身就不够详细，从google code迁移到github后，wiki的内容好像丢了很多。。。其次很多人已经翻译过官方文档了。我是打算看遍guava的源码，结合自身的一些使用经验，总结下常见的用法。看源码的过程也是自己学习的过程。<br>其实从源码中能翻出很多好玩的东西，很多工具类官方都没有文档。虽然API可能不稳定就是了。<br>如果这次搞guava顺利的话，打算以后把apache commons系列也这么搞一次。<br>基于18.0版本。</p>
<h1 id="《LeetCode_Gossip》">《LeetCode Gossip》</h1>
<ul>
<li>地址：<a href="https://www.gitbook.com/book/jiangxy/leetcode-gossip/details" target="_blank" rel="external">https://www.gitbook.com/book/jiangxy/leetcode-gossip/details</a></li>
<li>进度：10%</li>
<li>备注：基于java</li>
</ul>
<p>其实就是leetcode题解，总结下解题的思路，附加各种吐槽。其实主要是吐槽。。。本职不能忘。<br>但我本身是算法弱鸡，所以也不追求算法速度了，能AC就好，未必是最优的解法。<br>之前只刷了50多道题，还有很多水题，借这个机会，强迫自己把leetcode重刷一遍，复习下算法。</p>
<h1 id="分享一些书籍">分享一些书籍</h1>
<p>借着开坑的机会，分享我之前看过的一些书吧。书上有我的注释&amp;吐槽，这个是个人习惯。。。也是不定期更新。<br>另外我习惯看最新版的，所以会有很多是英文版的。</p>
<p>坑爹的是，很多注释是我以前用windows时用foxit reader加的，在mac下显示会有些问题。</p>
<ul>
<li><a href="http://pan.baidu.com/s/1bpE1KB1" target="_blank" rel="external">《HBase权威指南》中文版</a></li>
<li><a href="http://pan.baidu.com/s/1miTc4VA" target="_blank" rel="external">《Hadoop权威指南》英文第三版</a></li>
<li><a href="http://pan.baidu.com/s/1kVrkQbl" target="_blank" rel="external">《Hadoop.Application.Architectures》英文版</a></li>
</ul>
<p>以上是比较完整的看过的，注释也比较多，其他的还在整理。<br>另外因为是pirated edition，请低调。。。本来想放在dropbox的，但转念一想会不会被封啊，还是放baidu吧。。。</p>
<h1 id="一些文档">一些文档</h1>
<p>顺便分享自己写的一些文档吧，主要是一些内部分享和调研。有些简略，有些详细。</p>
<ul>
<li><a href="http://pan.baidu.com/s/1mipOESw" target="_blank" rel="external">Hadoop和Mapreduce</a></li>
<li><a href="http://pan.baidu.com/s/1jIgzsiE" target="_blank" rel="external">YARN代码分析</a></li>
<li><a href="http://pan.baidu.com/s/1kVGVcI7" target="_blank" rel="external">PowerDrill&amp;Tenzing</a></li>
<li><a href="http://pan.baidu.com/s/1skG2Cv7" target="_blank" rel="external">Tenzing</a></li>
<li><a href="http://pan.baidu.com/s/1eSa1QoE" target="_blank" rel="external">Muppet</a></li>
<li><a href="http://pan.baidu.com/s/1bpofh2v" target="_blank" rel="external">Twitter uni-log</a></li>
<li><a href="http://pan.baidu.com/s/1kVlgZyf" target="_blank" rel="external">Google Prediction API</a></li>
<li><a href="http://pan.baidu.com/s/1nvAfzrr" target="_blank" rel="external">Google Analytics</a></li>
<li><a href="http://pan.baidu.com/s/1bpDN9uv" target="_blank" rel="external">DNS原理&amp;安全</a></li>
<li><a href="https://pan.baidu.com/s/1geZkgsb" target="_blank" rel="external">二手前端心得</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是个大坑。<br>不过挖坑一向是我的优良品德之一，记得填就好。</p>
]]>
    
    </summary>
    
      <category term="gitbook" scheme="http://jxy.me/tags/gitbook/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[懒癌发作]]></title>
    <link href="http://jxy.me/2016/03/01/laziness-cancer/"/>
    <id>http://jxy.me/2016/03/01/laziness-cancer/</id>
    <published>2016-03-01T12:26:31.000Z</published>
    <updated>2016-03-13T17:22:23.000Z</updated>
    <content type="html"><![CDATA[<p>快2个月没写，也是创造了新纪录啊。。。</p>
<a id="more"></a>
<p>我曾下定决心下篇文章一定要写纯技术的，不要总是吐槽。结果发现最近也没研究什么新东西，没啥好写的。。。说实话最近技术上进步不大，只是更熟练而已。《Machine Learning in Action》只看了几章。《Spring in Action》出了第四版，想重新看遍，也只是开了个头。发现一个有意思的项目<a href="http://swagger.io" target="_blank" rel="external">Swagger</a>，也没时间仔细研究。由于要自己写后台界面，还想研究下React，发现了一个高逼格的组件库<a href="ant.design">Ant Design</a>，结果也没坚持下来。过年期间还说看下guava的代码，也是搁浅了。不要指望假期能干什么正事。。。</p>
<p>so，这期间到底在干啥？年前，赶进度，年前必须上线啊汗；去三亚开年会；然后回家过年，在家过着腐败生活；年后回来，长假综合征再磨蹭几天，然后项目开工了，继续赶进度。。。时间就这么不知不觉过去了。</p>
<p>刚开始写blog的时候，经常一周就能写一篇。不过那时候比较闲，而且写的是纯技术文章，所以能潜心去研究。还能研究很多跟工作无关的东西，自娱自乐一下。现在么，由于有排期，有deadline，有人催，会比以前压力大一些。</p>
<p>更悲催的是，接投影仪时插了下hdmi线，把mbp主板烧了。。。虽然借了台旧电脑应急，但hexo的工程都放在坏掉的mbp上，没法写blog了，连个备份都没有。。。以前有linode时候还会用git备份下，看来要去搞个私有仓库了。。。</p>
<p>其实以上都是借口，只是懒而已。。。</p>
<h1 id="半年有感">半年有感</h1>
<p>不知不觉已入职半年，老大递给我转正申请表我才反应过来。时间真的是很快。<br>坦白说，这半年技术上成长不多，搞的都是杂七杂八的事，毕竟是打杂工程师嘛。涨了不少见识，但都没什么深入钻研。还是以前搞hadoop、搞大数据听着更NB一点。前段时间接到某HR电话，“我们这边有个大数据相关职位，看你的简历比较符合，请问要不要考虑”，我一边嘴上客气拒绝，一边心里默默念叨：“我都好几个月没碰hadoop了。。。”<br>其实还是挺怀念的。纯搞技术当然不好；但搞业务太多，技术原地踏步也不是好事。<br>我虽然不是原地踏步，但心里还是有点虚的。。。以前是跑车，现在是买菜车。。。<br>离职前刷的那一点算法也快忘光了。。。</p>
<p>总结下，这半年真正的收获有三个。</p>
<ol>
<li>对电商业务有了更多了解。也能出去忽悠几个人了。。。呆在一家电商公司，想不了解也不行。其实电商还是挺复杂的，外行人可能觉得，“不就是卖东西”，但电商可以有很多玩法。都是卖东西，摆地摊和沃尔玛能一样么。。。而如何用一个大的平台去支持这些玩法，出现新的业务模式时能直接用已有的平台实现，就是我们要考虑的问题了。如果出现一个业务就重新做一套，真的会死掉的。好在我们这里有很多阿里的人，很多经验可以照搬，阿里踩过的很多坑就不用踩了；阿里摸索了很多年才总结出的概念、架构，直接用就可以。有老司机带就是不一样啊。也要庆幸遇到了很nice的同事，帮我从一无所知到略知一二。毕竟从1到100很容易，从0到1很难。</li>
<li>对所谓的“架构”有了更多认识。加引号是因为架构这个词是很模糊的，而且很多时候有水份。“架构师”这种头衔就跟“产品经理”一样，有时候水的令人发指。应届毕业就做产品经理，are you kidding me？同理，没几年一线开发经验就号称架构师，也是醉了。我不否认有天才，只是不相信我运气这么好能碰到，而且做产品不能把希望寄托到几个天才身上。又扯远了。。。我是因为参与了一些系统从无到有的过程，又经历了后期痛苦的迭代过程，深感一个扩展性好的架构是很重要的，不然就只能各种gross hack，到最后只能推倒重来。而且我一直觉得架构分2种，技术架构和业务架构。比如说hadoop的架构，我能说出一堆，比如yarn的RM、NM之类的，这种是纯技术的，只需要从技术角度出发去设计。而且大家都差不多，不都是分布式、高可用、Master-Slave、push/pull之类的。换句话说，是有业界标准的，虽然有时业界标准不那么明确。但如果揉入业务逻辑，就会更复杂，比如设计一个商品管理平台，如何拆分各种模块，如何考虑未来业务扩展。这种架构里扩展性是非常非常重要的，因为业务是变化很快的。而且每家公司业务总是有不同的，只能借鉴不能照抄。用我老大的话说，纯技术的结构都是“伪架构”。。。如何提升架构设计能力？其实跟学棋差不多，多看些棋谱，然后自己去推演。知道好的好在哪里，坏的坏在哪里，就OK了。另外做日常需求时，多想想背后的商业逻辑，想想他们之后可能的用法，这样才能在设计时留有余地，以满足日后需求。如果能像阿尔法狗一样，遍历人类所有棋谱，那就NB了。。。话说阿尔法狗又赢了。。。</li>
<li>学会了一种积极主动的态度。这个其实是最重要的。以前在网易的时候，安安心心当一颗螺丝钉就好了。像大学里一样，有人找的时候就解决问题，没人找就自己鼓捣hadoop，跟别人接触很少，有种“山中不知岁月”的感觉。。。但现在不同了，一方面是离业务更近，而业务瞬息万变，所以节奏很快；另一方面是制度不像大公司那么完善，没有那么多流程可以遵循。所以很多事情要自己主动去推才能有进展。自己去找各种各种的人、制定计划、监控进度、调度资源。真的要有一种owner的意识，对自己的项目负责。最难的是要主动和各种人撕逼。。。这一直是我的弱项，我也就吐个槽捧个哏还可以，撕逼一般都会输。。。不过也在锻炼。这也是成长必经之路嘛。</li>
</ol>
<p>anyway，至少还是向着好的方向前进的。</p>
<h1 id="去中心化？">去中心化？</h1>
<p>听了内部某个演讲有感。<br>我们一直在强调“去中心化”，这到底是啥意思。仔细想想，似乎就是社交+电商。就像阿里想做社交，腾讯想做电商一样，巨头们一直想把社交和电商结合起来，但种种原因都没做好。社交+电商到底应该是个什么样？似乎也没人能说清楚。简单的想想似乎就是垂直电商+社区+导购，但这样似乎又太肤浅了。</p>
<p>有个同事的比喻很精妙，借用一下：淘宝这种平台化电商就是“天上人间模式”，淘宝类似老鸨。。。用户想要买(zhao)东(xiao)西(jie)，必须要经过平台（大多数情况下是搜索和推荐）才能找到特定的卖(xiao)家(jie)，淘宝在这个过程中会收取费用，比如直通车什么的。其实淘宝就是靠卖流量赚钱的。这种模式下，大多数用户是没什么忠诚度的，每次想买东西时都会重新搜索一次。而且排在3页以后的卖家是没什么机会的，转化率低的可怜，卖家想提升自己的排名只能乖乖交钱。而我们要做的是“婚介所模式”，没有一个统一的平台入口，我们帮助卖家和买家认识，然后就没我们什么事了，以后你们爱怎么玩就怎么玩。。。在这个过程中我们鼓励卖家自己去推广、运营，去结识买家。我们只会在幕后推动，提供各种工具和建议，而不会直接给卖家导流量。每个卖家都是一个小小的“中心”。</p>
<p>为什么会这样？因为社交的一个关键就是“信任”，而信任很容易提升复购。所以我们希望卖家和买家能保持一个长期的关系。或者说，我们鼓励“口碑营销”，鼓励一种“小而美”的模式，而不是淘宝那种“大而全”。</p>
<p>这种方向上的差别会直接影响我们的工作。比如在淘宝里，运营（小二）的地位非常重要，说是能影响行业趋势也不为过。很多后台项目其实都是为了满足运营需求而存在的。但我们鼓励卖家自己去运营，所以做很多需求的时候还会从卖家的角度去考虑，很多工具要分成运营版/卖家版。<br>题外话，为什么运营这么重要：因为大家的技术同质化，产品同质化太严重了啊。如果能有颠覆性的技术（量子计算机啥的），或者颠覆性的产品形态（facebook刚出来的时候），就不用拼运营了。但在电商领域，大家的技术和产品都太相似了，只能拼谁的运营更精细了。另外据老大说，即使是淘宝，运营直接拉动的成交其实也很少的，个位数的百分比。但运营会带来长尾效应，带来很多潜在的可能性。</p>
<p>其实社交网络的力量非常可怕的，一旦找对爆点，流量往往会几何级数增长。所谓的病毒式营销，就是这么来的。但怎么利用这种力量，怎么和电商结合，大家都在摸索。</p>
<p>另外以上都是我的YY，只是个人理解，不负任何责任。。。</p>
<h1 id="还是项目管理">还是项目管理</h1>
<p>之前提到的<a href="/2016/01/10/methodology-sc/">那个项目</a>已经成为了我们这里经典的反面教材。。。如果有项目管理的课程必定要拿出来批判一番。。。</p>
<p>仔细想想还是有些东西要强调下。</p>
<ol>
<li>PRD评审/UC评审/TC评审，一个都不能少。这是为了保证产品/技术/测试三方的理解一致，统一思想。评审会议会增加个人的工作量，也确实很费时间，但会提升整个团队的效率。因为评审能暴露出问题，<strong>在需求阶段解决问题是成本最低的</strong>，开发完才发现问题就只能呵呵了。</li>
<li>要强硬。首先PM要强硬，坚持原则，敢于拍桌子，即使是面对leader，“你有理你怕啥的”。。。千万不要和稀泥，那是对所有人的不负责。PM还要时刻跟踪进度，确保真的进度正常，而不是成员自己说正常就算了。因为很多时候成员不了解全局，没感觉到问题在哪，没意识到风险。其次开发也要强硬，说多少天就是多少天，做不完就加人/加班，而不能因为leader的要求强行缩短工期。</li>
<li>估工作量时要给自己留有余地。真的不要那么实在。。。毕竟可能有很多种突发情况的。突然被老大叫去帮忙面试，半天就没了。。。</li>
<li>估时间时要考虑全面，不要只考虑自己开发的时间。还要考虑沟通成本、联调时间、测试时间。针对完整的功能去评估工作量，而不要只考虑主流程。</li>
<li><strong>不要轻易给出承诺。但给出的承诺一定要实现。</strong></li>
</ol>
<p>项目=需求+时间+资源，这是某个同事总结的，影响项目成败最关键的3个因素，还挺有道理的。</p>
<h1 id="面试の方法论">面试の方法论</h1>
<p>面试了一些人，总结下。<br>说实话工作以来也面过不少人了，但我其实不太擅长这种活。我大多会问一些确定性的问题，像是项目经验、算法、语言之类的，对就是对错就是错。一些太“虚”的问题我把握不好，关于具体业务领域的更是很少问。像是“你最有成就感的事是什么”这种问题，这辈子估计都不会问。。。所以只能负责第一面的技术面。。。</p>
<p>总结下套路（当然只是我的套路），特指java开发：</p>
<ol>
<li>我一般会先看简历问项目经验。主要关注做过些什么，碰到过哪些问题，是怎么解决的。如果有参与了架构上的设计，做过一些抉择，为什么要做出这些选择？是否有更好的方案？这部分主要是考察学习能力/解决问题的能力/设计能力，看思路是否开阔。<strong>学习能力尤其重要。</strong>如果在项目中只是“跟随”，没有自己的思考，或者做了很多项目但一直重复相同的技术，会减分。就像大学时能用一个“图书管理系统”应付好多课程的大作业。。。但工作中肯定行不通。</li>
<li>抛出一个/几个实际问题看如何解决。具体是什么问题要看情况的。可能是工作中实际碰到的，也可能是凭空想象的，我有朋友碰到过“设计一个微博系统”这种问题。。。我一般只会问些简单的。很多时候只是算法问题披了一层皮。这种问题答错也没关系，而且很多时候也没标准答案。但必须能讲清楚思考过程和理由。更多考察的是工程经验，考察思考问题是否全面。</li>
<li>数据结构与算法。这个也是常规项目了。我最近常问的是<a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="external">Invert Binary Tree</a>，因为我很期待有人能认出这个梗。。。那在我这里会加很多分。但考察算法也不一定只是纯算法，也可能是业务上的，比如负载均衡、调度算法、ML之类的。而且不同职位对算法的要求也是不同的，可能有些要求很高，有些要求熟悉特定领域的算法，看情况。</li>
<li>java基础。一般就是集合、多线程之类的。深入点可能是JVM、GC。一些更基础的东西应该在笔试中就体现出来的。前提是有笔试。。。</li>
<li>框架与工具。如果你说熟悉spring，那就问spring。如果用过hibernate，那就问hibernate。如果是面试大数据相关的，一定会问hadoop/spark。反正就是挑你会的往深了挖，不在乎广度而在乎深度，当然深挖的前提是我也会。。。如果能对常用的工具很熟悉，git/maven之类的，就更好了。</li>
<li>闲聊。真的是随便问了。比如数据库、sql、redis、缓存、nginx、脚本，前端的也可以问。如果能除了工作外，自己去学各种各样的东西，会加很多分。会fan|qiang也会加分。。。</li>
<li>最后一定会问对方有什么问题要问，能解答的我都会尽量解答。但有些真的回答不了，有人问我“杭州和上海哪里工资高”，这和面试有啥关系么。。。</li>
</ol>
<p>当然不会那么死板的。可能有些环节问得多些，有些环节问得少或不问，看情况。<br>技术面试最忌讳的是似乎什么都懂一些，但什么都不深入。至少我对这样的被试者印象会很差。<br>另外，关于简历，有篇blog讲的不错：<a href="http://coolshell.cn/articles/1695.html" target="_blank" rel="external">别的程序员是怎么读你的简历的</a>。</p>
<p>其实啊，面试很多时候还要看感觉。愿不愿意和面前这个人做同事？当然这里可能有个人主观因素了，这也是没办法避免的。好在搞技术的一般不会太奇葩，当然也有例外。。。我就碰到过一些装B侠，不懂装懂，乱扯一气，也只能呵呵了。。。</p>
<h1 id="END">END</h1>
<p>其实不一定要有个结尾的，但我是强迫症。<br>一些不能长篇大论，不足以单独为一节的想法/脑洞，会丢到这里。</p>
<p>我曾经说想做一些东西让用户发挥自己的创造力，仔细想想，有点类似UGC。<br>但UGC之间也是不同的。就像积木一样，有的积木表现力强（乐高），有的积木表现力差（若干年前有一款叫戴乐魔塔的积木）。想用七巧板拼一个星球大战，可能嘛？<br>但表现力太强就意味着不好设计，不好维护，增加系统复杂度。还是要trade off。</p>
<p>正好最近在做一个自助建站的项目。如果能鼓励用户分享自己的作品，并让用户基于分享的作品再次创作，就很有意思了。当然想做好也很难。<br>也许以后的项目都可以借鉴这种思路，鼓励用户自己去创作并分享，自己去“制定规则”。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>快2个月没写，也是创造了新纪录啊。。。</p>
]]>
    
    </summary>
    
      <category term="杂谈" scheme="http://jxy.me/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[大陨石之术]]></title>
    <link href="http://jxy.me/2016/01/10/methodology-sc/"/>
    <id>http://jxy.me/2016/01/10/methodology-sc/</id>
    <published>2016-01-10T14:33:17.000Z</published>
    <updated>2016-03-13T11:17:06.000Z</updated>
    <content type="html"><![CDATA[<p>生命不息，吐槽不止。<br>题目与内容无关。</p>
<a id="more"></a>
<h1 id="电商架构">电商架构</h1>
<p>只是开发相关的部门。<br>我一直对电商公司的架构缺少个整体的了解，近日一个同事给我讲了讲，感觉清晰了些，大概整理下。<br>随便画个图：<br><img src="/2016/01/10/methodology-sc/1.png" alt=""></p>
<p>有点像OSI的七层模型。。。但这个图很不严谨，只是个大概的分类。</p>
<p>偏向技术：<br>0.运维-关键字：SA/机房/监控和报警/docker/云主机，一切的基础，就是传说中的op。<br>1.基础工具-关键字：git/nexus/持续集成/文档中心/jira/自动部署，这块我们叫做技术保障部。可能也有叫做dev op的。<br>2.中间件-关键字：MQ/日志收集/db分库分表/搜索、算法、推荐？这是最大最模糊的一块，不是传统意义上的java中间件，凡是跟业务不直接相关的都可以丢到这里。<br>这三块也许应该叫业务支撑部门，很少有业务逻辑，更多关注技术。</p>
<p>偏向业务：<br>3.电商基础-关键字：商品中心IC/店铺中心SC/用户中心UC/交易/安全/支付，电商业务中的基础服务。<br>4.电商平台-关键字：选品/投放/运营工具/自动化建站，为实现业务需求提供平台化的工具，提高效率；直接和运营打交道。<br>5.具体业务-这里才是真正实现业务需求的地方。</p>
<p>有个假设，每一层只会跟下层打交道，只对上层提供服务。比如中间件不会来调用电商基础的接口，电商基础也不会去调用电商平台的接口。</p>
<p>以前，我大概是工作在第0层的，跟第2层也沾点边。现在工作在第4层，变化还是挺大的。<br>感觉嘛，以前可以专心研究技术，去研究源码，可以搞自己感兴趣的东西，像在学校一样。也跟网易的氛围有关系。但是没有业务，就没有话语权，在一些事情上就会非常被动。<br>现在，经常被运营赶着走，被各种吐槽。整天就是迭代、需求、开各种会议，也许技术上没以前进步那么快了，但也对业务有了更多的理解。<br>各有利弊吧。</p>
<p>另一个变化就是心态。以前是一种学院派的心态，做事前会想的很多，考虑各种细节，有十足的把握再动手；现在越来越草莽。。。凡事先从需求出发去考虑，以解决问题为最优先，不再那么完美主义。什么系统都敢做。。。不敢说做的多完美，至少能用。有种落草为寇的感觉。。。</p>
<h1 id="项目管理是个很复杂的东西">项目管理是个很复杂的东西</h1>
<p>作为开发参与了某个项目，历时两个月，中间出了各种各样的问题，深感项目管理真的是很难。<br>项目管理的目标说起来很简单，无非是协调进度、控制风险、保证产品按时完成。但然并卵，知道了不等于会做，不等于不会出错。<br>我不知道怎样才是正确的，只能说说自己看到的一些问题。</p>
<ol>
<li>每个人对需求的理解都不同。需求方提出需求，经过产品方的加工细化，再反馈到开发、测试。这中间就有很大风险，信息可能“失真”。但即使直接跟需求方对接，也很难保证需求、产品、开发、测试有相同的理解。往往是开发按自己的理解做事，但需求方却说“这不是我要的东西”；测试按自己的理解写测试用例，但跟开发出的系统背道而驰；甚至需求方自己也不能理解需求，他们往往只有一个模糊的概念，不同的时间去问他，可能会得到不同甚至相反的答案。。。所以要将需求落实到文档上，也就是PRD文档，一切以这个文档为准。这个文档必须得到各方一致认可。对于开发而言，不在这个文档内的功能，都是计划外的，如果一定要做，请走需求变更流程，项目延期也不是我的责任；对于测试而言，直接对照PRD文档写测试用例，如果某个用例无法通过，就是开发的责任。所以PRD文档是非常非常关键的，这个文档必须有绝对的权威性。</li>
<li>需求不详细。有PRD文档不代表万事大吉。写的烂的PRD和没有差不多。一般PRD是由需求方和产品先商量一致后给出初版，然后由开发和测试确认，经过必要的修改，最后存档，作为日后撕逼的基础。但即使是PRD中的描述，也未必足够详细，主要体现在一些细节上，比如文案、校验条件，总会有些模糊的地方。这些模糊的地方，又会导致各方理解上的偏差，那要PRD还有何意义？PRD就是为了“统一思想”而存在的。所以这里对产品经理要求很高，他们必须把需求理解透彻并写到PRD中。另外我不得不说，NB的产品经理是真NB，水的也是真水。。。两极分化很严重。一些人鼓吹“人人都是产品经理”，只能呵呵。好的PRD应该覆盖<strong>所有的用例</strong>，最好还有<strong>界面原型</strong>。另外对于开发而言，必须逐字逐句的去研究PRD，<strong>吹毛求疵也不为过</strong>，所有不合理的、模糊的地方必须指出并要求修改细化，并重新审核。即使冒着项目无法按时开工的风险，也不能让步。因为一旦确认PRD，所有风险都会转移到自己身上。如果日后因为需求模糊而出问题，只能自己背锅。但有个风险在于有时你不能自己决定，可能是你的技术leader/其他同事来决定，他未必会那么仔细，这就要自己好好去沟通了。</li>
<li>设计过分复杂。确认PRD后，一般会进入设计阶段。我不了解前端/视觉的设计，只说说后端的技术方案的设计。我只负责几个模块，但要上线的时候，得知居然整个产品分了10个子系统，还有依赖关系，我就震惊了。。。这就是“想太多”。开发在设计系统的时候，往往会考虑扩展性，考虑性能，考虑“通用”而过度设计。但对需求方而言，他才不关心你如何实现。他只关心时间，越快越好。如果能先做一些小系统满足他的需求，观察下这个产品确实有活下去的价值，再重构，也许会更好。随着产品的发展，<strong>架构上的推倒重来是不可避免的</strong>，不可能有一劳永逸的方案。总不能上线初期就非要按twitter的体量去设计，最后DAU只有几百。。。另外有些同学总是先设计数据库表，姑且叫做数据库驱动设计(Database Driven Design, DDD)吧，这是个很不好的习惯。他们往往先在mysql中建好表，再设计上层的系统，设计各种接口。这样思路不会受限嘛？而且为啥这么确定存储是mysql嘞。。。</li>
<li>过分乐观。定下技术方案后，需要预估工作量，这个时候往往会过分乐观。有很多原因，有时是有外部依赖，比如依赖于别人的工作，但估时间没有考虑到他人的进度；有时是只考虑编码时间，没有考虑联调/测试；有时就是自己经验不足，或者碰到技术难题，很难一概而论。根据测试那边的反馈，大多数项目预估的工作量都不准，甚至一周估成一天都可能。测试建议我们在自己估的时间基础上*1.4，还是有点道理的。但更大的问题在于leader可能直接拍板定下工作量是xx人日，这就不是乐观不乐观的问题了。。。</li>
<li>责任不明确。其实就是个分工合作的问题，解耦不够彻底。单独的模块应该由单独的人负责，不同的模块、系统如果有依赖，<strong>在设计时就应定好交互的接口</strong>，而不要在开发时再改来改去。如果你的接口变化，导致我的模块延期，这个风险不是我的责任，而且这个风险必须通知到项目中所有人。</li>
<li>非技术人员随便给出技术建议。“不就是加个按钮嘛”，“加个同步就ok”，“从标题就能取到数据”。这个没啥好说的，搞技术的都碰到过。对方讲道理的话就解释下，否则只能开撕了。</li>
<li>测试用例过度。开发中存在过度设计的情况，测试中也可能存在。很多测试用例都是针对一些corner case，比如输入长度，一些文案等。某人因为一个地方的文字应该是“图片”还是“头图”跟我争了半天。。。这当然说明测试很敬业，我很佩服。但在项目延期风险很大的情况下，是否应该有所变通？更关键的是，很多PRD中没有的东西，也会出现在测试用例里，测试会考虑各种“误操作”的情况。虽然说从做产品的角度来说，要把用户都当成白痴，但这是内部系统啊，都是同事在用，就那么信不过他们的智商嘛。。。</li>
<li>会议冗长低效。开了很多会议，需求评审、测试用例评审、xx评审，但效果很差。说实话，我坐在下面看他们讲，都不知道他们讲的是什么，昏昏欲睡。开会比写代码还累。只有到跟我相关的部分，才大概听进去一些。我讨厌开会，很多会议的意义在于“这件事已经通知你，别说你不知道，现在不仔细听以后出问题就是你的责任”。。。但有些会议又真的无法避免，只能想办法提高效率了。个人感觉，时间不要太长；事先把会议的内容发出来，让大家先看下有个准备，带着问题去开会；每次只跟特定的人开会，比如前端的需求就只跟前端的人开评审会，不要把所有人都叫上。其实“如何高效的开会”这个问题已经超出项目管理的范畴，是一个更普适性的问题了。</li>
<li>沟通问题。沟通真是人类亘古以来最大的难题。沟通成本随项目参与的人数呈几何级数上升，就像巴比伦塔的故事一样。而且我们还要经常和北京的团队沟通，有些问题面对面都说不清，何况电话/邮件。沟通的问题有很多种，比较突出的是：只在口头上达成一致，但过段时间对方又不认了；有些变化没有通知所有人，只是小范围知道。有个笨方法是每次都邮件@所有人，当然不是所有人都会看，但出问题时可以说“我之前邮件通知你了啊”，虽然个人觉得这样很不负责任。。。</li>
</ol>
<p>综上，大部分问题都出在需求阶段。如果需求能明确、详细，后面很多的问题其实都可以避免。<br>另外项目经理必须足够强势，统筹全局，该吵架就要吵，总是和稀泥是不行的。</p>
<p>在做这个项目的时候，几乎觉得这个项目已经在慢性死亡了。就像打dota，己方只剩基地，对面都神装了，但就是不推进。自己知道要输，出于职业精神还不能早退，就只能耗着。好在，经过2次延期后，这个项目终于结束了，虽然不如人意，砍掉了一堆东西，成品跟设计完全不一样，但也算阶段性胜利了。<br>经过这个项目，我现在很想尝试下敏捷开发，不知道如果用敏捷方法来做这个项目，会不会有更好的结果。但敏捷也不是银弹，不能解决上面的所有问题，只是另一个方向的尝试罢了。</p>
<p>其他一些教训：</p>
<ol>
<li>所以的一切都落实到文档上。IM上的沟通不算数。</li>
<li>出问题时，不要总是抱怨，要想解决办法。抱怨不解决任何问题。</li>
<li>加班能解决的问题都不是问题。</li>
<li>学会保护自己。换句话说，学会甩锅，但不能乱甩，要有理有据的甩。</li>
</ol>
<p>话说，虽然我上面写了这么多，但给其他人看，估计也不会有什么感悟。因为有些事情真的只能自己经历过才能理解，别人再怎么对你解释都没用。像我当初学软件工程、软件文档、软件测试的课程时，觉得这个真水，有毛线用啊，凑学分的吧，刷GPA的吧。但现在体会到了，真的是有用的。很多我觉得“水”的东西只是因为我不懂，以后吐槽要小心些了。</p>
<h1 id="运维思维">运维思维</h1>
<p>我发现运维经验在日常工作中还是很有帮助的。至少有问题时可以自己排查，而且一些任务也可以自己写脚本完成，不用找op。<br>做运维时，很多东西必须从底层去理解原理。现在也就养成了这样一种习惯，对于未知的库、未知的框架，总想搞明白原理，不一定要去看代码，但必须要有个能自圆其说的解释，这样开发时心里也就更有底。<br>看到一些同学，只会用ide，很少用命令行，maven/git之类的只在eclipse里用，其实这样不太好，出了问题大多数情况下还是要到命令行里排查。<br>正好最近看到一篇运维相关的文章，讲的还不错：<a href="http://www.infoq.com/cn/news/2015/12/linux-performance" target="_blank" rel="external">用十条命令在一分钟内检查Linux服务器性能</a>。</p>
<p>运维思维的另一个体现是开发时总是会考虑监控、报警、统计之类的运维需求。如果我做的系统完全没有监控，就会很心虚。。。虽然公司没有强调，但脑中总会有个SLA的概念。有些时候，写这些运维需求的代码，会比写业务代码更耗时间。。。因为现在我们的运维工具/平台很不完善，很多要自己做。</p>
<p>其实还有一个好处，但是不是技术相关的。由于做过运维，与op交流时也就会更高效，知道哪些事确实不是op的锅，不会强人所难。<br>可能的话，推荐大家都体验下做op的感觉。就像在某些公司里，技术也要经常轮值去做客服一样。<br>做OP/PE最重要的是服务态度，是及时响应、换位思考，技术反而是次要的。<br>只有体验过，才能互相体谅，甩锅的时候才不至于甩错。。。</p>
<h1 id="商品管理">商品管理</h1>
<p>工作中想到的一些问题。面对亿级别的商品，如何有效管理？<br>仔细想想，其实不止是商品，任何东西都是这样，比如管理一大堆图书，管理很多图片。所谓“管理”，另一个说法是“如何组织数据”。目的是为了快速检索，如何能快速找到想要的商品/图书/图片。否则我要遍历整个数据集才能确定哪些是我想要的。从这个角度说，有点类似索引。</p>
<p>一个不太恰当的比喻：商品管理就是面对一大堆object，我们要判断他们的class是什么，并且把class用一定的结构组织起来。比如java的package结构。</p>
<p>首先大家都会想到分类。比如把衣服分成男装/女装，上装/下装，图书分成英文/中文之类的。感觉这是人类的本能啊，见到陌生的事物都会尽量先套用到已有的认知模型里。分类的好处是天然的树状结构，便于理解，B+树不也就是按主键id的范围分类么。生物学中的界、门、纲、目、科之类，就是这样的产物。问题在于分类的标准是什么？不是每个人都是林奈。各个类别之间，总会有些模糊的界限，导致一些实体（姑且这么称呼），放在类别A可以，放在类别B似乎也没错。就像哥德尔的不完备性定理一样，总会有些不能证真也不能证伪的命题，分类系统中也总是会有些无法明确类别的实体。没办法保证所有类别是互斥的。简言之，就是逼死强迫症。而且分类的标准有时很难让人理解，我就一直很奇怪为什么蜘蛛不是昆虫，而要搞一个单独的蛛形纲。</p>
<p>回到电商，商品管理很重要的一块就是类目体系。这是一颗很大的树，但深度有限制（据说最多4级？），每个商品会唯一挂到一个叶子节点下面。这个概念很好理解，有点类似网站中的面包屑导航，只要一级一级点下去，就能找到你想要的商品。但电商们又在这颗树上搞出了一些新的玩法。首先，每个节点都会有特定的属性，称作类目属性。每个商品都必须对照模版去填对应的值。比如手机类目，会有“厂商/制式/系统”等属性（称之为属性模版），而一个iphone商品就会有对应的“apple/4G/ios”属性值，像class和instance。这只是一个虚构的例子，实际上系统这种属性都可以拿出去单独做一个类目了。类目和属性相辅相成，商品的某些特质，可以作为类目，也可以作为属性，要看运营如何抉择。属性有几种：关键属性，决定SPU，比如品牌+型号确定唯一款手机；销售属性，决定SKU，比如服装的颜色、尺码；简要属性：直接展示在商品详情页。属性的管理也非常复杂，包括属性的层次结构，属性和类目的关联等等，不比商品管理简单。其次，衍生出了前台/后台类目的差别。大意是前台用于展示给用户，经常改变，比如随季节变化；后台用于展示给卖家，比较稳定。前台类目是一个“虚拟的”类目体系，一个前台类目可以映射到多个后台类目，多个前台类目也可以包含同一个后台类目。这也是出于精细化运营的需要。有点类似React中的虚拟DOM？</p>
<p>为了弥补分类系统的不足，又出现了另一种组织方式：标签。这也很好理解，人们在日常生活中一直是这样做的。比如你说你是东北人，就会被某些人贴上“大男子主义”之类的标签。。。知乎上更是各种“XX癌”、“XX婊”的标签泛滥，这和所谓的“扣帽子”是一回事，有些是无心的，有些是恶意的。所以现在都在提倡no judge，不要随意下判断。扯远了。。。如果说分类系统是一棵树，那标签系统就是一个HashMap，可以快速把贴着某个标签的所有实体选出来。我见过一些完全用标签管理图片的系统，还挺好用的。标签系统的一大好处是标签库可以让用户自己去不断丰富，类似UGC。</p>
<p>电商中的标签，更多的是对类目体系的一些辅助。当然如果一定要较真的话，标签和类目概念上还是有重叠的。尤其是类目属性。商品的某些特性，可以表达为属性，也可以表达为标签，这个没有定式。另外，标签也是有类别的。可能有些标签是描述商品手感的（丝柔顺滑之类的），有些是描述风格的（小清新/复古），还有些干脆是从评论中提取的（质量好/发货快）。所以标签管理也是很复杂的一个问题。是否会有一个“标签树”？</p>
<p>总之，商品管理最常用的两种方法：类目和标签。以上只是我一些很初级的理解。也许还有其他形式，我就不清楚了。<br>当然没有完美的方法，只要能解决实际问题就可以，不要在意那些细节。<br>就像各种奇怪的物理理论，超引力/弦理论/P膜之类的，你相信这个世界真的是这样么？但它们能解决特定问题。数学模型能解释物理现象，就是好模型。如果能进一步，做出预测并被证实，就会被很多人奉为真理了。</p>
<p>商品管理是电商中非常基础的服务，会影响到所有环节，比如搜索会根据关键词预测类目，减少要检索的商品数量。<br>最近我常做一件事，就是在淘宝的搜索页看它给出的过滤条件，猜测哪些是类目，哪些是属性，哪些是标签，挺有意思的。</p>
<h1 id="linode再见">linode再见</h1>
<p>我的linode节点又一次被qiang，终于下定决心放弃了。懒得再折腾了，又要去提ticket，又要换ip。还要去改dns。本来还想换个机房试试，但ping了下速度也不咋样。<br>仔细想想，用了一年多，每月10刀，也没干啥，就偶尔用来翻翻qiang，搭了个gitlab，有点浪费啊。每月那么多的带宽根本用不了。</p>
<p>在某个高富帅的推荐下，换用了<a href="https://eurekavpt.com" target="_blank" rel="external">EurekaVPT</a>，顿时感觉逼格提升了很多。<br>速度很快，关键在mac上可以实现全局代理，ios也能用，很方便。<br>以前为了给iphone翻qiang，折腾过pptp、openvpn，各种蛋疼。<br>虽然说生命在于折腾吧，但有限的人生面对无限的折腾，总要有所取舍。</p>
<p>另外关于dns再提醒下，运营商自动分配的dns一般都有劫持，google的8.8.8.8又丢包严重。可以考虑阿里dns或v2ex dns。其实国内dns服务商挺多的，但有节操的不多。。。</p>
<h1 id="锁和一致性">锁和一致性</h1>
<p>研究ReentrantReadWriteLock时，脑洞大开，想到一些问题。</p>
<p>首先看到了读锁和写锁，由此想到乐观锁和悲观锁。但其实这根本不是同一个层次的东西。悲观锁就是我们通常说的锁，也叫排他锁/写锁，而乐观锁根本不是锁，是一种重试机制。基本原理是先读取当前数据的版本号，然后对数据做修改并写回，但写回的时候会判断版本号和之前的是否一致，如果不一致说明数据变化了，会重试“读取-修改-写入”的过程，直至写入成功。用过zookeeper的都知道，修改某个znode节点数据时必须带版本号的，感觉和那个有点类似。</p>
<p>由乐观锁想到CAS。我的理解就是处理器级别的乐观锁指令，原理上是一样的。话说这个缩写到底是Compare And Set还是Compare And Swap。。。google的过程中找到<a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank" rel="external">一篇文章</a>，讲了JVM里的各种锁。从来不知道锁分这么多类型，偏向锁我只在JVM启动时的参数里听说过。</p>
<p>由synchronized关键字又引申出<a href="http://ifeve.com/talk-to-my-understanding-of-the-java-memory-model/" target="_blank" rel="external">java内存模型（JMM）</a>，引伸出变量可见性和<a href="http://ifeve.com/easy-happens-before/" target="_blank" rel="external">happens-before语义</a>。大意就是由于编译器的优化和处理器的乱序执行，代码的执行顺序不一定是和源文件中一致的。而synchronized代码块却一定可以保证顺序。关于JMM，我以前研究volatile时了解过一点，但现在才知道所谓的working memory完全是逻辑上的概念，以前还奇怪gc的图上怎么没这块内存。</p>
<p>由乐观锁又想到mysql中的MVCC，据说这也是一种乐观锁。以前听登博讲过一点，但没听懂。。。于是google去，找到了<a href="http://blog.csdn.net/greencacti/article/details/12843345" target="_blank" rel="external">这个</a>，图画得挺清楚，内容上有点疑问。据说mysql中MVCC只在READ_COMMITTED和REPEATABLE_READ下有效，而且似乎只对读起作用？多个事务并发修改同一份数据时，没看出来mvcc有啥作用？关键是没看到重试机制，可能是我不了解。这个MVCC的原理就是在undo中保存数据的快照，读取的时候，根据当前事务选择特定的版本。有了mvcc，读肯定不会阻塞了，即使其他事务在某行上加了排它锁。摘录一段话：“理想MVCC难以实现的根本原因在于企图通过乐观锁代替二段提交。修改两行数据，但为了保证其一致性，与修改两个分布式系统中的数据并无区别，而二提交是目前这种场景保证一致性的唯一手段。二段提交的本质是锁定，乐观锁的本质是消除锁定，二者矛盾，故理想的MVCC难以真正在实际中被应用，Innodb只是借了MVCC这个名字，提供了读的非阻塞而已。”</p>
<p>可见，乐观锁的应用场景其实很有限。</p>
<p>关于undo和redo日志，我以前也有点模糊。redo log其实就是WAL，用于系统挂掉时恢复用的。undo log则是用于回滚的。其实undo功能上可以代替redo，也能恢复数据，但效率很差。而redo是顺序写，效率很高。这也是WAL的标准特性了。</p>
<p>MVCC又引出了mysql的事务隔离级别。mysql中的4种标准的隔离级别大家都知道，READ_UNCOMMITTED会读到未提交的数据，即脏读；READ_COMMITTED会读最新提交的数据，但同一个事务中，同样的查询可能读到不同的值，因为其他事务会修改数据，这个叫不可重复读还是幻读？REPEATABLE_READ是mysql默认的隔离级别（可能和版本有关），保证在同一个事务中，同样的select语句，读到的数据肯定都是相同的，无论字段值还是行数；SERIALIZABLE最好理解，所有事务串行执行。模糊的地方在于到底什么是幻读？网上有种说法是READ_COMMITTED下读到的数据值会变，叫做不可重复读；REPEATABLE_READ下读到的数据行数会变，叫做幻读。但根据我亲自测试，REPEATABLE_READ读到的行数不会变啊，即使其他事务新插入了几行数据，在当前事务中也看不到，测试方法见<a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" target="_blank" rel="external">这里</a>。读不会产生幻觉，反而写会产生幻觉，主键跟一条不存在的记录冲突。。。也许跟mysql版本有关？</p>
<p>我甚至觉得不可重复读跟幻读根本就是同一个东西。。。但根据<a href="https://zh.wikipedia.org/wiki/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2" target="_blank" rel="external">wiki</a>的说法，确实是有区别的。只能说mysql的REPEATABLE_READ实现比较特殊了？</p>
<p>由隔离性想到ACID，其实这里的C我一直都不太理解，这个东西太抽象了。什么保证各种约束的完整性，这个各种约束到底是啥。还有分成读一致性/写一致性的，还有nosql中的最终一致性。<a href="http://blog.csdn.net/chen77716/article/details/6166675" target="_blank" rel="external">这篇文章</a>讲的比较有道理，“一致性”这个词，在不同的系统中有不同的含义。不要过于纠结。</p>
<p>由ACID又会牵扯到CAP。其实CAP有<a href="http://blog.csdn.net/chen77716/article/details/30635543" target="_blank" rel="external">很多争议</a>，至少这两个词里的C的含义是不同的。我一直都觉得hbase很难套用到CAP理论里：hbase是强一致性（写入的数据马上就能读到）；数据肯定是分区的（那么多regionserver呢）；高可用（虽然我觉得不算真正的高可用）。似乎C/A/P三个条件都能满足啊，于是就凌乱了。。。话说，这些理论，听听看看就好了，很多都不是“真理”，甚至可能被证实是“谬论”。我们做工程的，要把主要精力放在解决实际问题上。</p>
<p>既然提到两阶段提交，我就又<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4" target="_blank" rel="external">google了下</a>，但没太懂。如同那个作者说的“本质上就是锁定”，而且这个算法一眼看去就觉得有很多问题。。。看上去很美，但实现起来肯定一堆坑要填。话说，有哪些系统实现了两阶段提交？如果能实际使用下可能就理解了。</p>
<p>两阶段提交又会引出paxos，这货太难懂了，实在不想碰它。而且这个东西和多线程一样，当时你觉得自己完全懂了，已经是天下无敌了，过段时间再看，又是一堆问题。。。</p>
<p>既然提到MVCC，不可避免的涉及到锁。mysql提供了表级/页级/行级的锁，但我不想再深究了，暂时脑容量不够了。。。</p>
<h1 id="微服务">微服务</h1>
<p>看<a href="http://www.infoq.com/cn/articles/basis-frameworkto-implement-micro-service" target="_blank" rel="external">某篇文章</a>有感。</p>
<p>微服务的好处到底在哪里。也许从单独一个模块看确实清晰好维护，但整个系统看来不会更复杂么，是一个互相交错的网。以前是同一个系统中的模块互相调用，现在是各个系统之间通过RPC/REST互相调用，效率肯定会变差吧。而且很难搞清楚调用关系，从我们的dubbo使用经验来看，调用链很长，一旦出问题调试起来还是挺麻烦的。<br>所以微服务需要一个强大的中心管理者角色，梳理整个系统的调用关系，监控各个系统的状态之类的。没有这样一个角色，微服务就会很坑爹。所以实践微服务才需要那么多的基础服务。这会带来额外的开销。这种开销是否值得，就要权衡了。<br>但微服务有个实实在在的好处就是分批发布，不会说有个模块功能变化，就要重新发布整个系统。<br>其实很多公司在实践中已经不自觉的用到微服务了吧，但都是手工做的，没有形成系统的规范、框架罢了。换句话说，没有形成方法论。</p>
<p>重构一个系统时，我们都会提到水平切分/垂直切分，那微服务算啥？网状切分？。。。<br>也许算作垂直+水平吧。<br>不管怎么切，不要过度设计。很多时候没必要切的那么细。</p>
<h1 id="一些读后感">一些读后感</h1>
<p><a href="http://blog.codingnow.com/2015/11/rpc.html" target="_blank" rel="external">RPC之恶</a>。“单看 RPC 给编程实现带来的方便性，其实最终是增加了，而不是减少了系统的复杂度”。RPC只是看着很方便，很容易被滥用。像dubbo这种，编码的时候真的感觉不到是RPC，就当普通的方法用了，但一跑起来就一堆问题。对RPC请求应该更谨慎处理的。</p>
<p><a href="http://www.infoq.com/cn/news/2015/12/Hadoop-HDFS-DAS" target="_blank" rel="external">将Hadoop的计算和存储分开能有效的提升性能</a>。很有趣的观点，这么搞的前提是有足够的带宽。以前强调数据本地性，是因为在机房中带宽才是最宝贵的资源，最多就千兆网络。如果未来万兆网络能普及，也许真的不用考虑本地性了。</p>
<p><a href="http://www.infoq.com/cn/articles/wechat-banma-dmp" target="_blank" rel="external">微信斑马系统</a>。我关注的是对于数据如何使用。用户画像-&gt;人群聚类-&gt;精准推广，这个过程很有意思。另外它的隐私策略也值得思考，各种数据产品很少去考虑隐私，而PII(Personal Identifiable Information)数据理论上是不能被使用的，有法律风险。另外，这是一个去中心化的系统，由商家自己去运营、分析，也有些借鉴意义。</p>
<p><a href="http://www.infoq.com/cn/news/2015/12/soa-v-microservices" target="_blank" rel="external">SOA与微服务的比较和对比</a>。概念上的模糊不影响使用，不要纠结于学术之争。感觉微服务就是SOA的一种实现方式。</p>
<p><a href="http://www.infoq.com/cn/news/2015/12/Wix-MySQL-NoSQL" target="_blank" rel="external">Wix是如何把MySQL当NoSQL用的</a>。把mysql当作KV来用，很有意思。若干年前我听雷火的一个分享，也提到把mysql当作key-value来用。实际中的很多工程里，我们也是这么做的，比如存一个大json进去，需要的时候再去解析。当数据量不大的时候，mysql作为KV挺好用的。当然也要看业务，OLAP之类的就算了。</p>
<p><a href="http://www.infoq.com/cn/articles/2015-Review-Spark" target="_blank" rel="external">Spark 2015</a> AND <a href="http://www.infoq.com/cn/news/2016/01/spark-16-release" target="_blank" rel="external">Spark 1.6</a>。spark这一年的发展，说是“恐怖”也不为过。记得几年前还是个实验室项目，却这么快变成业界标准。就像每年都有人给出下一代iphone的概念设计图，看上去很美，大家都知道是假的，结果特么居然成真了。。。1w+的contributor是什么概念。。。可惜由于工作原因，不像以前关注那么多了。听说RDD要退出历史舞台了，继续感叹发展速度。。。</p>
<h1 id="如何选择开源项目">如何选择开源项目</h1>
<p>只是作为用户发一些牢骚。<br>选择开源项目最重要的是什么？我最关注的是活跃度。包括社区的活跃度、commit频率等。如果碰到问题，作者/社区是否能很快的修复？如果一个项目都好几年没人维护了，这怎么敢用？没错我说的就是dubbo。。。据说dubbo本来是阿里云的人搞的，后来要统一切换到淘宝的HSF，dubbo放弃了可惜，于是就开源了。。。<br>但有些时候是没得选的，像dubbo这种，没什么好的替代品，只能硬着头皮用，踩到坑也要自己填，于是就很痛苦。。。<br>还有velocity，也是好久没人维护了，我很不想用。但要维护一些已有的系统就不得不用。。。</p>
<p>这就是个技术倾向性的问题。不会有啥大问题，就是影响心情。<br>将精力花在一些过时的技术上，也很不值得。</p>
<p>另外一定要避开所谓的toy project，尤其是一些个人开源的，没什么实际应用案例的。最近看到了一个系统，作者没用spring mvc或是jersey之类的，而是自己发明了一个mvc框架。虽然美其名曰开源框架但其实也只是自己用。。。看这种代码异常痛苦啊。而且这个代码很奇怪，本来想说奇文共欣赏摘录一段给大家看看的，但一时找不到。大概就是把java写成汇编的感觉，各种奇怪的缩写/下划线，什么camelcase都靠边站。一眼望去，真的看不出来是java的代码。。。</p>
<p>反过来说，怎样才是一个负责的开源项目？不是把代码扔上去就不管了，要有详细的用户文档和实例，良好的反馈机制，及时修复问题。更进一步，测试覆盖率/设计文档/注释/项目管理等等。除非真的是没得选，我会更关心这些“软实力”。</p>
<h1 id="其他">其他</h1>
<p>写到最后才发现，怎么这么多字，刷新了我的记录了吧。<br>我的习惯是脑中出现什么念头就先记下来，有空再慢慢整理成文字。所以这篇文章其实是断断续续写了大半个月的，内容也很杂。</p>
<p>关于题目。解释下大陨石之术：小说写到最后，作者编不下去的时候，往往会搞一些突发事件，让角色挂掉，于是就可以顺理成章的完结了，这被称为“天降大陨石”。。。当然所谓的陨石可能是意外/疾病之类的。如果有读者非要较真，还可以美其名曰“开放式结局”。。。<br>这篇文章本来叫做《方法论SC》的，是<a href="/2015/10/30/methodology/">《方法论？》</a>的续篇。某天凌晨3点多读完了<a href="http://book.douban.com/subject/3259440/" target="_blank" rel="external">《白夜行》</a>，惊觉大陨石之术重现江湖，甚感欣慰，久不能平，决定改下标题以示纪念。。。<br>其实当时我的心情是：are you kidding me??</p>
<p>扯回正事。最近写工作总结和规划，我写到想做一些有趣的事，不要一直重复日常。怎样才是有趣的？我仔细想了想，研究新的技术当然算有趣，但我更想做一些东西，让用户发挥自己的创造力，不要受我的限制。如果用户能在我的系统上找出我意想不到的玩法，我也会很开心。用游戏来比喻的话，可能是《恶魔城》的出城，或者《马里奥制造》《Minecraft》之类的。<br>像暴雪爸爸一样，买地图编辑器送游戏。。。<br>还只是很模糊的想法，希望以后能有机会吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>生命不息，吐槽不止。<br>题目与内容无关。</p>
]]>
    
    </summary>
    
      <category term="杂谈" scheme="http://jxy.me/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Maven豆知识]]></title>
    <link href="http://jxy.me/2015/12/17/maven-tips/"/>
    <id>http://jxy.me/2015/12/17/maven-tips/</id>
    <published>2015-12-17T10:21:51.000Z</published>
    <updated>2016-01-03T08:22:30.000Z</updated>
    <content type="html"><![CDATA[<p>好久没有写豆知识系列了。<br>记录下使用中的一些问题。</p>
<a id="more"></a>
<h1 id="eclipse中maven项目的bug">eclipse中maven项目的bug</h1>
<p>两个项目同时在开发，在同一个workspace，项目A依赖项目B。项目A会直接使用项目B中的代码（B的最新代码还没有install或deploy），而不是maven repository中的jar包。<br>换言之，我在项目B中加了一些新的类，eclipse中的项目A也可以使用，正常编译。<br>但如果在命令行中<code>mvn clean package</code>，就肯定会失败，ClassNotFound。</p>
<p>对于正常的项目而言，改下版本号就可避免。项目A依赖的项目B版本和项目B正在开发的版本不同，就会直接依赖repo中的jar包。<br>但我碰到的情况是项目A依赖了一个SNAPSHOT版本。而项目B也正在这个SNAPSHOT版本上开发。有点蛋疼。<br>只能记着多deploy了。</p>
<p>不确定这是bug，也许有配置可以改，但我没找到。</p>
<h1 id="skipTests与maven-test-skip">skipTests与maven.test.skip</h1>
<p>首先要知道<a href="https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" target="_blank" rel="external">maven生命周期</a>。<br>skipTests只是maven-surefire-plugin插件的一个参数，这个插件是maven自带的，默认绑定到test阶段。设置这个参数后，test阶段不会执行测试。<br>而maven.test.skip会影响更多插件，包括maven-resources-plugin（testResource阶段），maven-compiler-plugin（testCompile阶段），maven-surefire-plugin（test阶段）。换言之，和测试有关的所有阶段都会起作用。</p>
<p>所以maven.test.skip是更彻底的跳过测试的方法。<br>直观的感受，就是如果src/test/java下的代码编译有问题，加上maven.test.skip就能防止整个项目构建失败。而只用skipTests则会在testCompile阶段失败。<br>但maven.test.skip也可能造成一些奇怪的问题，见<a href="http://stackoverflow.com/questions/24727536/maven-skip-tests" target="_blank" rel="external">这里</a>。</p>
<h1 id="report插件">report插件</h1>
<p>maven本质上来说就是个插件的集合。<br>而插件分为两种，build插件和report插件。build插件会在default生命周期生效，配置在POM中的<code>&lt;build/&gt;</code>元素里；report插件会在site生命周期生效，配置在POM中的<code>&lt;reporting/&gt;</code>元素里。<br>根据配置的插件不同，<code>mvn site</code>命令会在target目录下生成不同的html报告，帮你了解项目的一些概况。<br>虽然大多数项目用不到，但挺好玩的。所以研究了下。</p>
<p>常见的report插件（有一些插件既是build插件也是report插件）：</p>
<table>
<thead>
<tr>
<th>插件名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>maven-project-info-reports-plugin</td>
<td>这个其实是自带的，有很多内置的报告</td>
</tr>
<tr>
<td>maven-pmd-plugin</td>
<td>代码静态检查</td>
</tr>
<tr>
<td>maven-jxr-plugin</td>
<td>将代码以html方式呈现</td>
</tr>
<tr>
<td>findbugs-maven-plugin</td>
<td>另一个代码静态检查，但findbug是分析class文件，而不是java文件</td>
</tr>
<tr>
<td>jdepend-maven-plugin</td>
<td>一些统计信息</td>
</tr>
<tr>
<td>taglist-maven-plugin</td>
<td>汇总代码中的TODO，也可自定义其他的tag</td>
</tr>
<tr>
<td>maven-surefire-report-plugin</td>
<td>生成单元测试的报告</td>
</tr>
<tr>
<td>cobertura-maven-plugin</td>
<td>检查单元测试覆盖率，配置可以很复杂</td>
</tr>
<tr>
<td>maven-javadoc-plugin</td>
<td>生成javadoc</td>
</tr>
<tr>
<td>maven-checkstyle-plugin</td>
<td>强迫症福音，检查代码风格，比如方法名/变量名/空格/每个方法不超过多少行</td>
</tr>
</tbody>
</table>
<p>每个插件都有自己的配置，可以去看相应的官方文档。</p>
<p>另外对于多模块的项目而言，<code>mvn site</code>只会在各个模块的target目录下生成报告，而不会汇总起来。可以用<code>mvn site:stash</code>命令汇总到父项目的target目录，方便查看。<br>但这个命令要求POM中做些修改：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">distributionManagement</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 没有这个配置site:stage会报错 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">site</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="title">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="title">id</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>site<span class="tag">&lt;/<span class="title">name</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- 只是随便看看报告，不需要真的部署到某个站点，所以随便写个url --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="title">url</span>&gt;</span>http://dummy<span class="tag">&lt;/<span class="title">url</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="title">site</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">distributionManagement</span>&gt;</span></div></pre></td></tr></table></figure>

<h1 id="jetty_plugin的配置">jetty plugin的配置</h1>
<p>jetty plugin用来调试很方便，但网上很多文章给的配置都是6.x老版本的。<br>jetty现在已经由eclipse基金会维护了。新版的配置项和6.x很不一样，见<a href="http://www.eclipse.org/jetty/documentation/current/jetty-maven-plugin.html" target="_blank" rel="external">官方文档</a>。<br>例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- jetty Plug-in --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">plugin</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>jetty-maven-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- jetty9需要至少jdk7 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">version</span>&gt;</span>9.2.8.v20150217<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">configuration</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt; --&gt;</span></div><div class="line">		<span class="comment">&lt;!-- 我习惯手动reload，按回车即可重新部署 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="title">reload</span>&gt;</span>manual<span class="tag">&lt;/<span class="title">reload</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="title">dumpOnStart</span>&gt;</span>false<span class="tag">&lt;/<span class="title">dumpOnStart</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="title">webApp</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="title">contextPath</span>&gt;</span>/<span class="tag">&lt;/<span class="title">contextPath</span>&gt;</span></div><div class="line">			<span class="comment">&lt;!-- 配置额外的资源路径，一般用于测试 --&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="title">resourceBases</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="title">resourceBase</span>&gt;</span>${project.basedir}/src/main/webapp<span class="tag">&lt;/<span class="title">resourceBase</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="title">resourceBase</span>&gt;</span>${project.basedir}/../misc/swagger<span class="tag">&lt;/<span class="title">resourceBase</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="title">resourceBases</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="title">webApp</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- 开启访问日志 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="title">requestLog</span> <span class="attribute">implementation</span>=<span class="value">"org.eclipse.jetty.server.NCSARequestLog"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="title">logDateFormat</span>&gt;</span>yyyy-MM-dd HH:mm:ss<span class="tag">&lt;/<span class="title">logDateFormat</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="title">logTimeZone</span>&gt;</span>GMT+8:00<span class="tag">&lt;/<span class="title">logTimeZone</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="title">logServer</span>&gt;</span>true<span class="tag">&lt;/<span class="title">logServer</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="title">logCookies</span>&gt;</span>true<span class="tag">&lt;/<span class="title">logCookies</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="title">requestLog</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- 设置一些系统属性 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="title">systemProperties</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="title">force</span>&gt;</span>true<span class="tag">&lt;/<span class="title">force</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="title">systemProperty</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="title">name</span>&gt;</span>dubbo.application.logger<span class="tag">&lt;/<span class="title">name</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="title">value</span>&gt;</span>slf4j<span class="tag">&lt;/<span class="title">value</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="title">systemProperty</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="title">systemProperties</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></div></pre></td></tr></table></figure>

<h1 id="依赖版本冲突">依赖版本冲突</h1>
<p>如果在项目中引入同一个依赖的不同版本，会发生什么情况？<br>maven会自动帮你选择一个版本，这里又分两种情况：</p>
<p>如果是直接声明的依赖，后声明的生效。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--调整这两个依赖的顺序，再执行dependency:tree，可以看到不同--&gt;</span></div><div class="line"><span class="comment">&lt;!--注意不但1.6.0的slf4j-jdk14会覆盖前面的，1.6.0引入的间接依赖也会覆盖前面的--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!--相当于pom里根本没有这个1.6.1的配置--&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>slf4j-jdk14<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>slf4j-jdk14<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></div></pre></td></tr></table></figure>

<p>如果是间接引入的依赖，规则会更复杂，参考<a href="http://blog.csdn.net/bluishglc/article/details/6584678" target="_blank" rel="external">这个</a>。<br>简言之，深度较小的优先；如果深度相同，先声明的优先。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--最终1.6.1版本的slf4j-api生效--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!--这个依赖会引入slf4j-api-1.6.1--&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>slf4j-nop<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!--这个依赖会引入slf4j-api-1.6.0--&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>slf4j-jdk14<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></div></pre></td></tr></table></figure>

<p>如果上面两种情况混合起来，就更蛋疼了。。。例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>slf4j-jdk14<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>slf4j-jdk14<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>slf4j-nop<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></div></pre></td></tr></table></figure>

<p>最终生效的依赖是slf4j-jdk14-1.6.1、slf4j-api-1.6.1、slf4j-nop-1.6.0。</p>
<h1 id="enforcer_plugin">enforcer plugin</h1>
<p>上面说过依赖版本冲突时maven会自动帮你选择一个版本，但这样可能有隐患。例如某个模块依赖于guava 18.0的一些新功能，而maven却自动选择了guava 15.0。运行的时候很可能会报错，比如ClassNotFound或NoSuchMethod。如果编译正常，但运行时出现这两种异常，很可能是jar包版本冲突。<br>版本冲突还可能导致其他很多奇怪的问题。</p>
<p>所以最佳实践是不要有版本冲突。检测版本冲突就要用到enforcer plugin，maven的<a href="http://maven.apache.org/enforcer/maven-enforcer-plugin/index.html" target="_blank" rel="external">爱之铁拳</a>。。。</p>
<p>简言之，可以配置一些强制性的规则，如果规则不满足，build会失败。不光可以用来检测版本冲突，还可以做很多其他事情，还可以自己编写规则，又一个强迫症福音。。。</p>
<p>例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">plugin</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-enforcer-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.4.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">executions</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="title">execution</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="title">id</span>&gt;</span>enforce<span class="tag">&lt;/<span class="title">id</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="title">configuration</span>&gt;</span></div><div class="line">			<span class="comment">&lt;!-- 规则不满足时，只输出warning日志，不会导致构建失败 --&gt;</span></div><div class="line">			<span class="comment">&lt;!-- 看场景，我个人喜欢只输出日志；更严格的场景下可以去掉这个配置。 --&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="title">fail</span>&gt;</span>false<span class="tag">&lt;/<span class="title">fail</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="title">rules</span>&gt;</span></div><div class="line">				<span class="comment">&lt;!-- 检测依赖版本冲突 --&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="title">dependencyConvergence</span> /&gt;</span></div><div class="line">				<span class="comment">&lt;!-- 版本号的写法：http://maven.apache.org/enforcer/enforcer-rules/versionRanges.html --&gt;</span></div><div class="line">				<span class="comment">&lt;!-- 至少maven3 --&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="title">requireMavenVersion</span>&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="title">version</span>&gt;</span>3.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="title">requireMavenVersion</span>&gt;</span></div><div class="line">				<span class="comment">&lt;!-- 至少jdk6 --&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="title">requireJavaVersion</span>&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="title">requireJavaVersion</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="title">rules</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="title">goals</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="title">goal</span>&gt;</span>enforce<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="title">goals</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="title">execution</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="title">executions</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></div></pre></td></tr></table></figure>

<p>enforcer plugin默认会绑定到validate阶段，详细文档见<a href="http://maven.apache.org/enforcer/maven-enforcer-plugin/enforce-mojo.html" target="_blank" rel="external">这里</a>。</p>
<h1 id="插件的configuration元素">插件的configuration元素</h1>
<p>折腾enforcer插件的时候，发现一个奇怪的问题。<code>mvn clean package</code>时，插件可以正常生效；<code>mvn enforcer:enforce</code>却会报错，说找不到相关配置。<br>google了一下，找到<a href="http://stackoverflow.com/questions/6754974/usage-of-maven-enforcer-plugin" target="_blank" rel="external">这个</a>。</p>
<p>简单的说，配置一个插件的<code>&lt;configuration&gt;</code>元素时，可以直接配置，比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">plugin</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-enforcer-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.4.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">configuration</span>&gt;</span></div><div class="line">		...</div><div class="line">	<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></div></pre></td></tr></table></figure>

<p>这样的配置对这个插件在所有情况下都生效。</p>
<p>也可以配置在<code>&lt;execution&gt;</code>元素中，比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">plugin</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-enforcer-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.4.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">executions</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="title">execution</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="title">id</span>&gt;</span>enforce<span class="tag">&lt;/<span class="title">id</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="title">configuration</span>&gt;</span></div><div class="line">			...</div><div class="line">		<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="title">goals</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="title">goal</span>&gt;</span>enforce<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="title">goals</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="title">execution</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="title">executions</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></div></pre></td></tr></table></figure>

<p>这样的配置只会在maven执行到特定生命周期时才会生效。<br>对enforcer插件而言，默认绑定在validate阶段，所以configuration元素只有在validate阶段才生效。<br>所以直接执行<code>mvn enforcer:enforce</code>才会报错。</p>
<h1 id="默认插件">默认插件</h1>
<p>maven默认会将一些插件绑定到特定生命周期，比如clean插件、compile插件、resource插件等。这个是在哪里配置的？<br>答案是<code>$M2_HOME/lib/maven-core-x.y.z.jar</code>文件中，解压这个文件可以找到一个xml文件，配置了所有默认的插件和绑定的阶段。参考官方文档：<a href="https://maven.apache.org/ref/3.3.3/maven-core/lifecycles.html" target="_blank" rel="external">1</a>、<a href="https://maven.apache.org/ref/3.3.3/maven-core/default-bindings.html" target="_blank" rel="external">2</a>。<br>本来以为是在超级pom中配置的，实际不是。</p>
<h1 id="插件绑定">插件绑定</h1>
<p>一个插件可以有多个goal，每个goal可以绑定到特定的生命周期上。<br>有些goal会有默认的绑定，比如<code>enforcer:enforce</code>默认会绑定到<code>validate</code>阶段。这种插件在配置execution元素时可以不用配置phase。<br>有些goal没有默认绑定，比如<code>jetty:run</code>，如果要在build过程中自动执行，配置execution元素时就必须明确指定phase。当然也可以不在build过程中执行，直接<code>mvn jetty:run</code>去执行特定插件的特定goal。<br>这个是由编写插件时的<code>@Mojo</code>注解决定的，见<a href="http://maven.apache.org/plugin-tools/maven-plugin-tools-annotations/index.html" target="_blank" rel="external">官方文档</a>。</p>
<p>另外pluginManagement和dependencyManagement的语义有些不同。pluginManagement中的插件即使不配置在plugins中，也可以直接使用，比如<code>mvn jetty:run</code>。而dependencyManagement中的元素，必须在dependency中再配置一遍才能生效。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>好久没有写豆知识系列了。<br>记录下使用中的一些问题。</p>
]]>
    
    </summary>
    
      <category term="maven" scheme="http://jxy.me/tags/maven/"/>
    
      <category term="豆知识" scheme="http://jxy.me/tags/%E8%B1%86%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[南游记]]></title>
    <link href="http://jxy.me/2015/11/29/south-trip/"/>
    <id>http://jxy.me/2015/11/29/south-trip/</id>
    <published>2015-11-29T01:09:25.000Z</published>
    <updated>2015-12-06T08:52:40.000Z</updated>
    <content type="html"><![CDATA[<p>其实是跑到深圳参加了<a href="http://wot.51cto.com/2015bigdata/schedule.html" target="_blank" rel="external">某个会议</a>，简单总结下。</p>
<a id="more"></a>
<p>看到这个会议名字的时候，我是有点虚的。又是“大数据”，又是“互联网+”，噱头十足。一般这种会议水分也很充足。。。这种会议吧，未必真的能学到什么东西，关键在于聊天吹水换名片兼挖人。。。还未进会场就收到了一堆招聘广告。<br>每个演讲开始前，讲师都会宣传自己的公司、推销自己的书、公众号，演讲结束前还要帮公司挖人。。。<br>这个真的是技术会议嘛？</p>
<p>不过干货虽然少，还是能捞出一些。</p>
<h1 id="流水帐">流水帐</h1>
<h2 id="28日上午">28日上午</h2>
<p>很水。<br>各路CTO/CEO/VP上台演讲，本来就不能抱什么期望。不能指望听到什么技术。<br>倒是360的一个人讲的数据变现比较有意思。数据到底能不能赚钱？似乎只有广告一条路可以走。他说现在很多所谓的大数据应用其实都不是真正的大数据。bigdata已经变成了一个营销词汇。从技术上来说，<strong>只要能采样处理的都不是bigdata</strong>，只有那些必须全量处理，而数据量又大到传统手段不能处理的，才是bigdata。<br>另一个很重要的问题就是隐私，说是达摩克利斯之剑也不为过。我很久以前跟一个朋友聊天，说我是做统计的，你在app内的各种行为都能被记录到，他就非常反感。。。虽然他完全不懂技术，也不知道这些数据是用来干什么的。<br>就像倒卖个人信息的快递员，人家也算是数据从业人员了。。。</p>
<p>不过他们都真的很能讲，发明各种各样的概念。<br>“全方位的、360度的大数据”，这是什么鬼？？</p>
<p>最大的收获是一个数据驱动决策的段子：“领导看了报表，哈哈一笑，听取大多数人的意见，然后按自己的想法拍板”。。。</p>
<h2 id="28日下午">28日下午</h2>
<p>O2O电商架构专场。</p>
<ul>
<li>美团：《O2O领域的基础信息建设》。建设商家中心的一些经验。美团的商家信息都是商家上报或自主采集的，如何对这些信息进行清洗、合并、扩展。可惜没太听懂，业务还是挺复杂的。</li>
<li>菜鸟：《物流领域大数据应用-路由分单（青鸾智简）系统》。感觉就是根据地址信息自动配送路径。典型的分类算法。</li>
<li>唯品会：《实时数据在移动电商中的应用与实践》。完全是非技术的好嘛。</li>
<li>魅族：《魅族电商平台架构的变迁》。电商架构，简单明了。当然不能跟淘宝之类的比，但对我这样没什么经验的人，这种简单的反而更易理解。</li>
<li>京东：《京东搜索和618实战》。我对搜索了解不多，只知道基本的原理。架构图很复杂，但感觉讲的不太细啊。主要是hadoop离线建索引+MQ的实时索引。同行的搜索部门的同事倒觉得收获很多。</li>
</ul>
<h2 id="29日上午">29日上午</h2>
<p>移动大数据专场。</p>
<ul>
<li>汽车之家：《如何构建高效的数据采集系统》。大概就是一个日志收集系统吧，包括如何埋点，如何设计日志，前后端规范。还是讲了一些实践经验的，但技术细节较少。</li>
<li>吆喝：《AB测试高效实现全数据驱动产品优化》。讲了半天都是AB测试的好处，google/facebook通过AB测试提升了多少营收，提升了多少转化率。好处我当然知道啊，我想知道的是细节，如何构建这样一个支持AB测试的系统，怎样的分流规则，有哪些要注意的地方，踩过哪些坑。估计这哥们只是个数据分析师吧。</li>
<li>友盟：《移动大数据平台架构与实践》。友盟还是比较有发言权的。分享了data pipeline设计以及一些数据处理的经验。架构是简单的lamda architecture，但实时处理和批处理却分为了两个kafka。另外提到的一句话很有道理：“移动互联网红利已经结束，现在要比拼精细化运营”（大意）。</li>
<li>乐逗：《大数据处理及建模技术—基于R语言实现》。应该叫R语言简明教程。我完全不懂R，所以没怎么听。感觉R和matlab有点像。另外数据可视化让人印象深刻。</li>
<li>手淘：《亿级UV手淘背后的移动大数据采集体系》。难得的干货，认真的从头听到尾。因为我以前也是给移动应用做统计，所以了解很多痛点。和汽车之家的分享有些重合，但更全面，更深入。</li>
</ul>
<p>似乎现在移动端的统计都必须是专业的SDK了，我们以前那种手动打日志的方式太low了。<br>但想做一个好的SDK真的很不容易。做的不好轻则统计不准/扩展困难，重则影响app本身的功能。</p>
<p>重点说说手淘的分享。几个有意思的：<br>1.链路追踪：类似GA中的页面流，基本方法还是加参数。<br>2.客户端聚合：为了减少日志量，会在客户端做简单聚合再上传。<br>3.日志分级：业务日志的优先级明显大于性能日志，系统压力大时会优先丢弃性能日志。我以前见过开发乱打日志，打印一种类似于ping的日志，数据量急剧增大。。。数据重要性：跟钱相关的 &gt; 用户活跃相关 &gt; 运营相关。<br>4.客户端清洗：一些简单的日志清洗工作会在客户端做，不需关联处理的日志都可以这样，似乎配置是实时从服务端取的。<br>5.上传策略：定时上传/wifi上传/启动上传/crash上传。<br>6.采样上传：似乎是压力大时会采样部分用户的数据上传，同一个用户的数据也只会采样部分。<br>7.SDK自身监控。SDK自身也会打印日志用于监控。<br>8.数据运维。运维是大公司与小公司最大的区别。手淘的运维平台可以做到埋点、校验、监控、调试等等。但不知道技术细节。<br>9.双11灾备。业务分优先级，压力大时优先保证P0业务；系统降级，自动重设超时时间。</p>
<p>其实还是有很多疑问的。比如手淘是如何跨native和H5统计的。</p>
<p>汽车之家的分享中提到日志扩展性的问题，我也说说我们以前的做法。<br>早期的日志都是开发定的，非常随意，虽然都是json，但没有统一的schema。日志格式一旦变化就很痛苦。<br>后来受twitter<a href="https://engineering.twitter.com/research/publication/the-unified-logging-infrastructure-for-data-analytics-at-twitter" target="_blank" rel="external">某篇论文</a>的启发，定义了统一的日志格式，固定的N个字段+一个可扩展的json。<br>但很多时候日志格式设计都只考虑了可读性，也许可以设计的更加紧凑，那性能也会更好。</p>
<h2 id="29日下午">29日下午</h2>
<p>数据安全专场。</p>
<ul>
<li>京东：《大数据下的电商风控体系》。算是干货。部分原因是我一直不太了解风控，所以有很多启发。画像还是挺有意思的，包括IP画像/设备画像/人机画像等等。其实风控最核心的是规则引擎吧，而且这个根据业务的不同差异很大，也不能直接复制。</li>
</ul>
<p>然后我们就悄悄的跑路了。。。</p>
<h1 id="大数据万能论">大数据万能论</h1>
<p>2天听下来，最大的感受是，很多人觉得大数据是万能的？<br>张口闭口大数据。自从用了大数据，腰不酸腿不痛，成本下降了，库存不积压，决策不拍脑袋，利润一口气翻五倍不费劲，一切都无比美好？这种论调尤其在第一天的CTO/CEO之流的演讲中出现非常多。</p>
<p>也许每个人看待所谓的大数据都不同吧。在我看来的bigdata是一堆技术的集合，以hadoop为代表。技术又不能帮你创造价值，关键还是看你怎么用。什么机器学习、数据挖掘，不都是在大数据之前就有的东西么？如果你对数据只是简单的count(1)，数据量再大又能如何？<br><strong>数据-&gt;信息-&gt;价值</strong>，这个转换不是那么容易的。而且其中的经验未必是可复制的。对技术而言，不会因为公司的不同而不同。你的hadoop集群和我的hadoop集群不会差太多。但你能从数据中获取价值，我按同样的方法去做，就未必可行。往小了说这和人员素质、经验有关，往大了说这和公司的业务、文化有关。<br>一个很危险的倾向就是为了用而用。明明excel就能搞定的偏要用hive；明明抽样统计下就可以偏偏要跑全量数据。感觉就和SOA一样，很多人根本不知道自己想要什么，只是机械的模仿别人，或者是为了符合“业界标准”。</p>
<p>但对传统行业而言，也许这个概念真的是颠覆性的。就像若干年前的信息化改造一样。<br>所以CTO/CEO们抓住这个机会，各种忽悠。但也就忽悠下外行罢了。</p>
<h1 id="所谓架构">所谓架构</h1>
<p>既然是技术分享，当然有不少的架构图。但其实吧，大数据相关的技术无非就那些，hadoop/spark/kafka之流，每个人根据自己需求的不同组合起来，需要定制开发的很少，所以技术架构都是大同小异。何况还有lamda architecture这种公认（算是吧）的成功范例。一些感受：</p>
<ul>
<li>kafka已是标配。</li>
<li>实时处理的还是storm多，可能出的早吧。JStorm也开源了，要焕发第二春？</li>
<li>Elasticsearch异军突起啊。以前没怎么关注过。</li>
</ul>
<p>真正复杂的反而是各种业务架构。<br>这个我很难评判，因为我没有相关经验，总不能乱讲。我只知道看着很头痛。。。人家设计成这么复杂，总不会是为了好看吧。<br>只有在特定的场景下，才能评判一个架构的好坏。</p>
<p>我现在越来越觉得，所谓的“技术栈”深度是有限的，但在有限的技术上总能折腾出无限复杂的业务。。。</p>
<h1 id="如何听技术分享">如何听技术分享</h1>
<p>只是个人的一些习惯。<br>整个会议40多场演讲，怎么选择听哪些？听的时候有哪些重点？</p>
<ul>
<li>看背景。看人的背景，看公司的背景。来自大公司的干货机率总是大些。CXO的演讲一般没什么营养。尽量去听一线开发人员的演讲。但如果有个人光环，比如Doug Cutting之类，那是必须听了，哪怕讲的不是技术相关也得去凑凑热闹。没错我就是这么庸俗。。。</li>
<li>看题目。太宽泛的题目水的概率比较大。如果能关注某部分技术细节，我会更感兴趣。</li>
<li>个人兴趣。有些题目我完全没有背景知识，去听也没有意义。像什么R语言之类的。。。但移动统计相关还有些经验，所以能有很多收获。当然也和公司的需求有关。</li>
<li>关注实践。我最关心的是他们踩过哪些坑，是如何解决的。什么背景啊、意义啊、需求啊，讲得再多也没用。</li>
<li>别被架构图吓住。很多图看着很复杂，但只是你不了解相关业务才觉得复杂的，不要被他们的业务逻辑绕进去。单独看某一部分就会简单很多。典型的就是美团的那个分享。</li>
<li>如何提问？演讲后总会有提问环节，但提问前先理清自己的思路好嘛。问题都说不明白，让人怎么回答。而且不要问得太宽泛，不要问和演讲无关的。某些人问“XX老师您觉得电商的未来如何？”。这种问题有何意义啊。</li>
</ul>
<h1 id="如何做技术分享">如何做技术分享</h1>
<p>只是一些我觉得应该注意的细节。</p>
<ul>
<li>画得不好的架构图不如不画。太简单没意义，太复杂听众也不懂。有人总喜欢用复杂的架构图标榜自己如何NB，我觉得很没必要。能讲清楚事情就可以了。</li>
<li>别念ppt。不只是技术分享，所有的presentation都是。好的ppt应该没多少文字的。</li>
<li>别罗列代码。在ppt里嵌代码要谨慎啊。这种过于细节的东西，很难保证所有人都理解。反而让人觉得讲师功力不够。就像看书一样，大篇的代码很容易让读者疲劳。</li>
<li>不要怕短。有些人喜欢讲各种废话拖时间。。。10分钟能讲清楚的事情偏要讲半小时。</li>
<li>不用刻意幽默。讲问题就好了。台上自己笑台下鸦雀无声，真的有点尴尬。。。</li>
<li>数据说话。你说你的系统多么NB，那拿出数据来，支持了多大的业务量，跟已有的系统比较如何。</li>
<li>不会的就老老实实承认。有些细节如果含糊带过，事后被人提问答不上来，就悲剧了。。。</li>
</ul>
<h1 id="其他">其他</h1>
<ul>
<li>深圳真温暖，回到杭州冻成狗。</li>
<li>为啥前台妹子都是一口京腔。</li>
<li>原来hu建人都用“fu联网”啊。</li>
</ul>
<p>总的来说，参加这种活动还是有点意思的，抱着观光旅游的心态就好。<br>回去继续干活去了。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>其实是跑到深圳参加了<a href="http://wot.51cto.com/2015bigdata/schedule.html" target="_blank" rel="external">某个会议</a>，简单总结下。</p>
]]>
    
    </summary>
    
      <category term="杂谈" scheme="http://jxy.me/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="hadoop" scheme="http://jxy.me/tags/hadoop/"/>
    
      <category term="bigdata" scheme="http://jxy.me/tags/bigdata/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[方法论？]]></title>
    <link href="http://jxy.me/2015/10/30/methodology/"/>
    <id>http://jxy.me/2015/10/30/methodology/</id>
    <published>2015-10-30T07:49:12.000Z</published>
    <updated>2015-11-04T01:50:16.000Z</updated>
    <content type="html"><![CDATA[<p>似乎最近写的纯技术文章少了很多，反而很多吐槽。。。<br>“杂谈”这个tag，不会超过hadoop吧。。。<br>不过，无论技术还是抱怨，无论总结还是吐槽，有思考总是好的。</p>
<a id="more"></a>
<h1 id="关于代码洁癖">关于代码洁癖</h1>
<p>我算是有点强迫症的，对代码总是要改来改去，有时自己也觉得很头疼。<br>空行、缩进、变量名之类的就不说了，而且绝对不能有warning。<br>还有注释，如果看到很长一段代码没有注释，就会不舒服。。。所以即使是废话也要加几行注释。<br>怎么说呢，没有注释感觉冷冰冰的，有注释就觉得代码真的是一个“人”写的。<br>pom里，一定要把所有依赖精简到最小，有多余的依赖就很难受。scope能为provided的一定不compile。打包时，有多余的jar打进去，也很难受。<br>log4j的配置里，无用的appender一定要删掉。<br>各种抽象、各种接口、各种设计模式。<br>所以只从速度上来讲，我写代码是很慢的，总是要想半天才写几行，而且经常重构。<br>说实话，这样很累。</p>
<p>但最近，总是不自觉的用些quick and dirty的方法。<br>小到编码，比如字符串于之于enum，写一大堆if else，各种hard code。<br>大到设计，各种简单粗暴。<br>因为deadline压在那里。。。<br>测试催的人头痛。稍有延迟就会邮件通告，似乎你的进度耽误了测试、耽误了整个项目、妨碍了公司、妨碍了世界和平。。。这是个不好的地方，出问题时，所有人都在忙着推卸责任，而不是想办法解决。。。<br>更别提需求变更了。<br>在这种情况下，真的很难再精雕细琢。</p>
<p>但写这种代码有点不安啊。。。这就是个大坑，不一定落在谁头上，而且很可能落在自己头上。。。<br>有句话叫eat your own dog food，但长此以往，当你真的准备吃时，发现已不是dog food，而是dog shit了。。。到时只能自我安慰，自己X的，含泪也要吃完。。。</p>
<p>关于这个问题，应该有很多人思考过了。不知道他人是如何解决的。<br>常见的所谓解决方法是快速迭代、上线，再重构。我也很难评判是对是错。<br>不过重构真的不是万能的。<br>只能说，如何取舍，如何平衡，都没有定式。只能自己把握。</p>
<h1 id="@Autowired">@Autowired</h1>
<p>见过一些人，根本不知spring是何物，但<code>@Autowired</code>用的很欢快。<br>因为整个项目的框架已经搭好，一些“大牛”已经写好一些类，只要照猫画虎就可以了。<br>我当时就给跪了。</p>
<p>暂且不谈对于项目，这种“分工”是否合适。至少对于个人，是百弊而无一利。<br>不要以为新人才会出现这种情况，所有人都会。<br>对于自己不熟悉的领域，人们总是倾向于浅尝辄止，会用就好，而不太关注原理性的东西。<br>从我的面试经历来看，会用MR的很多，能说清shuffle过程的没几个。</p>
<p>但这种浅尝辄止式的“学习”，有个好处，就是可以用来吹B，糊弄下不懂的人。。。只要自己保持一副高深莫测的样子就可以。。。某人看了篇quick start就来跟我大谈特谈hadoop，还好我机智。。。<br>但不得不说，吹B才能获得注意，才能有存在感，所以我也很理解。<br>另外很多面试官其实都是这样的，问你的问题他自己都不懂。。。我找工作时就被某HR镇住了，还以为是个技术总监，太年轻啊。。。<br>其实分辨方法也很简单，就是看他会不会追问，考察技术的广度还是深度。</p>
<p>不是说一定要深入源码去了解，至少要知道大概的原理吧。还是要多看书。</p>
<p>我也在反思，多注意自己的言行。谨记。</p>
<h1 id="关于打杂">关于打杂</h1>
<p>前段时间折腾linkedin，要填自己的职位，想了半天，我写了“打杂工程师”。<br>这倒不是抱怨，而是我觉得，每个人都要有些打杂的能力。</p>
<p>最近做的事情确实比较杂。在好几个项目之间转，哪里缺人，哪里进度紧急，就被派到哪里。感觉就是个救火队员。。。做的事情也不全是hadoop相关，一般是普通的Java EE，有时还做前端。。。缺人的时候还去到处收集简历和面试。</p>
<p>如果能专注于某件事，专注于某些技术，当然很好。<br>但现实中往往不会有这种条件，除非是专门的做研究。大公司分工很细，也许可以，小公司却诸事混杂，很难专一。为什么有些大公司出来的人受到各种诟病，就是因为只会一种技能，只能在这个公司里用。<br>所以各种地方都混混，各种工作都参与下，蛮好。<br>但也不能忘记本职。个人感觉，能有一两项核心技能，同时触类旁通，博闻强识，是最好的。<br>通俗点说，需要你打杂的时候要能hold住。用老郭的话说，上炕认识娘们下炕认识鞋，嗯。我也越来越三俗了。。。</p>
<p>对我来说，目前为止，我的本职是hadoop相关的应用/运维，其他都是副业。写简历的话，至少hadoop中的某些部分我敢写精通，其他最多写个熟练。。。但要我去搞前端什么的，我也不会怕，多少还是知道点的。哪怕让我去写lisp/haskell之类的，也有信心短时间内熟练使用，不过最好不要。。。</p>
<h1 id="微服务？">微服务？</h1>
<p>最近似乎所谓的micro service很火？我在InfoQ上看到了很多文章：<a href="http://www.infoq.com/cn/news/2015/07/success-of-microservices" target="_blank" rel="external">1</a>/<a href="http://www.infoq.com/cn/news/2015/04/micro-service-architecture" target="_blank" rel="external">2</a>/<a href="http://www.infoq.com/cn/articles/analysis-the-architecture-of-microservice-part-01" target="_blank" rel="external">3</a>/<a href="http://www.infoq.com/cn/articles/analysis-the-architecture-of-microservice-part-02" target="_blank" rel="external">4</a>。大都是“SOA已死，微服务当立”之类的论调。</p>
<p><a href="http://www.dropwizard.io" target="_blank" rel="external">Dropwizard</a>我很早就知道，非常喜欢这种开箱即用的框架。最近又知道了<a href="http://projects.spring.io/spring-boot/" target="_blank" rel="external">Spring Boot</a>。这就是所谓的微框架。难道用了微框架就是微服务？恐怕不是。</p>
<p>虽然我对SOA的理解完全来自google，没什么实践经验（只用过dubbo）。但感觉SOA是抽象程度非常高的概念，所以每个人的理解、实现都会有不同。而现有的标准实现太复杂了，需要各种技术SOAP、WDSL啥啥的。就像以前的EJB规范一样。<br>引用一段话：</p>
<blockquote>
<p>很多人使用SOA的原因就是为了用而用；厂商、委员会与协会一起过来告诉我们什么是我们“需要”的。最终，SOA也提出了关于组织结构的相同目标，不过却迷失在了WS-*规范中。</p>
</blockquote>
<p>于是出现了一种SOA的简单实现，就是微服务。SOA和微服务不是对立的，而是class和instance的关系。<br>感觉微服务就是一堆小的tomcat，使用者要按需调用。。。这其中也有很多问题，比如如何发现服务、如何管理之类的。<br>其实很多产品，早期都是所有服务做在一起的，可以理解为一个大tomcat。后来随着业务发展，才开始逐渐拆分。</p>
<p>所谓天下大势，分久必合，合久必分。<br>反正就是来回折腾。也许某天“微服务”又被一个大一统的框架取代了。</p>
<p>据说JAX-RS是用来取代JAX-WS的，但用起来也没觉得简单。。。<br>另外“软件咨询师”到底是干啥的。。。感觉就是发明一堆概念拿去卖钱。。。</p>
<h1 id="小步快跑？平台化？">小步快跑？平台化？</h1>
<p>最近老大总是跟我们提到一个词，小步快跑。感觉上就是快速迭代，先把眼前的需求做掉再说，细节的问题以后再修。<br>不过他是很鄙视这样的，说这样坚持不了多久，早晚会死掉。他给我们灌输的思想是要做通用性的平台，在这个平台上可以承载各种各样的业务。平台初期可以做的不完善，但一定要留出扩展的余地。<br>我想了想，觉得还是很有道理。</p>
<p>所谓的小步快跑，初期实现非常容易，一个星期上线一个产品绝对不是开玩笑。但蛋疼的地方在于容错性小，扩展性差。如果不断的有需求进来，就要不断的做一个个小的系统，不断重复着相似但是又有些许不同的代码和逻辑。最后变成一堆无人敢碰的遗留系统。。。<br>小步快跑适合用在哪里？1.初期圈地；2.忽悠投资人。。。</p>
<p>平台化的思维则是尽量考虑扩展性，初期也许降低了开发速度。但有了平台的支撑，以后的开发反而会变的很简单。所以最关键的问题在于平台的设计。这没什么捷径可以走，只能凭经验和自己摸索。成了就是高瞻远瞩，不成就是过度设计。<br>比如我拿到某个产品的需求，感觉就是很简单的java应用啊，mysql+spring搞搞不就好了。<br>但老大一看，就说这个功能可以用已有的招商系统实现，这个功能可以套到已有的运营后台，另一个功能我们要做一个服务凭证的平台，以后其他产品也可以用。。。</p>
<p>怎么说呢，这是思维方式的差别，不服不行。<br>我是没什么电商相关的从业经验的，所以只能看到具体的需求。而从阿里出来的人，见识过很多。尤其是呆的时间比较长的，经历了淘宝怎样从一个普通的LAMP变成巨大的平台。经历过，自然知道怎么做。思考问题的方式自然也不同。<br>比如我，有过一些运维经验，所以在设计系统时，也会更多的考虑可用性、SLA、运维友好之类的问题。<br>而经验这种东西，是不能凭空想象的，需要一点点积累。</p>
<p>小步快跑和平台化，从某种角度上来说是对立的。<br>就好像你不能既当T又当DPS，总要有所取舍。<br>开挂另当别论。如果有这种逆天的挂，请务必通知我。。。<br>每个公司的发展过程中，都必然经历这一阶段。只有度过这一阶段，小公司才有可能发展成大公司，注意只是有可能。小公司发展过程中有太多因素会导致死掉，但如果是死在技术不给力上，身为码农也太没面子了。<br>而我们目前就在这个阶段艰难跋涉。对我个人而言，有这样一段经历，蛮好。</p>
<p>于是我对自己有了新的定位：造积木的。<br>我做的只是造出尽量好的积木，表现力尽量丰富，比如乐高那样的。让使用方按自己的意愿拼成自己想要的样子。也许叫橡皮泥更合适？<br>其实吧，这有点类似中间件的概念。具体业务之下的，都可以叫做积木，无论是语言、框架、工具。当然hadoop也是。但积木是有层次之分的。java属于底层的积木，MQ更上一层。而我要造的，是比较接近上层的，与业务方只有一层之隔。<br>我以后写本书，就叫《积木论》，感觉像儿童图书。。。</p>
<h1 id="关于翻译">关于翻译</h1>
<p>曾经我还想<a href="/2015/03/23/beyond-8-hours/">翻译一些技术blog</a>，比如cloudera blog，databricks blog之类的。上面有很多高质量的关于大数据的文章。<br>到时在文章标题前面有个大大的前缀——【译】，好像也不错啊，逼格瞬间提升。</p>
<p>可惜，看懂是一回事，翻译又是另一回事。<br>尝试着译了几段，自己读着都别扭，就跟hadoop权威指南的中译本似的。<br>我算知道这本书是怎么翻译出来的了，敢情语文水平都跟我差不多，也就比机翻好一点。<br>黑这本书已经是我的日常了。。。</p>
<p>而且按我的风格，总想夹带些私货进去，吐个槽之类的。<br>但既然是翻译别人的文章，总要严肃些。如果我的私货比原文还多，还不如重新写一篇。<br>于是不了了之。</p>
<p>也许其实只是懒而已。。。</p>
<h1 id="总结？">总结？</h1>
<p>只是想随便写写而已，为何又写了这么多。。。<br>本来还有一节，叫做“装B有风险”，写了一长串又被我删掉了，怕影响不好啊，我记得就好了。<br>大千世界无奇不有，不能高估别人的下限。</p>
<p>本篇文章为何叫“方法论？”（注意是有问号的）？可能部分是受了<a href="http://www.infoq.com/cn/news/2015/10/Bryanedds-Medium" target="_blank" rel="external">这篇文章</a>影响。这些抱怨我觉得都有些道理。</p>
<p>在我们身边存在着各种各样的“方法”，大多是别人告诉我们的，比如软件工程、各种管理书籍、各种业界标准。似乎只要按着这些方法做事，就是正确的，至少也能避免最坏的结果。也许这些“方法”刚发明时是好的，但很多却渐渐僵化，变成了为了使用而使用。不顾实际场景而硬往方法上套，往往很惨。<br>也许我是个怀疑论者？我怎么觉得各种“方法”大多是忽悠人的。也许其中有些是有价值的，但很难明确该如何使用、该用在哪种场景。<br>工作过程中，我也会总结一些“方法”，但也会碰到很多问题。大多数问题是一个“度”的问题。</p>
<p>可惜我能看到问题，却给不出答案。<br>也许根本没有标准答案，只能凭感觉和经验行事。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>似乎最近写的纯技术文章少了很多，反而很多吐槽。。。<br>“杂谈”这个tag，不会超过hadoop吧。。。<br>不过，无论技术还是抱怨，无论总结还是吐槽，有思考总是好的。</p>
]]>
    
    </summary>
    
      <category term="杂谈" scheme="http://jxy.me/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Hadoop Application Architectures》]]></title>
    <link href="http://jxy.me/2015/10/12/hadoop-application-architectures/"/>
    <id>http://jxy.me/2015/10/12/hadoop-application-architectures/</id>
    <published>2015-10-12T14:51:14.000Z</published>
    <updated>2015-10-30T07:48:15.000Z</updated>
    <content type="html"><![CDATA[<p>非常赞的一本书，链接：<a href="http://shop.oreilly.com/product/0636920033196.do" target="_blank" rel="external">OReilly Shop</a>，6月才出的。话说OReilly真是业界良心。<br>我订阅了<a href="http://www.hadoopweekly.com" target="_blank" rel="external">Hadoop Weekly</a>，某天它推荐了一篇cloudera blog，具体链接忘了，部分内容就是节选自本书，讲了实时处理的一些架构，当时就感觉很赞。于是找来原书看看，顿觉相见恨晚。<br>断断续续看了2个月，550多页啊，全英文。简单总结下。</p>
<a id="more"></a>
<p>书如其名，讲的是如何利用hadoop生态圈中的各个组件，构建自己的应用，或者叫data pipeline。只讲架构，而不会太深入细节。</p>
<h1 id="先扯些别的">先扯些别的</h1>
<p>我在<a href="/2015/03/24/some-thoughts/">以前的文章</a>中写到：大数据技术很多，但成熟的少，门槛很高，落地太难。<br>现在依然这样觉得。</p>
<p>我认为hadoop圈已经发展的足够复杂了，各种开源项目可以覆盖到大部分需求。这么多apache顶级项目任君选择，还有各种孵化器项目。在hadoop-user的邮件列表中，还经常有人推销一些不太知名的第三方项目。<br>所谓的定制开发需求，很多是没有必要的，或者是从业务逻辑上可以绕过的，可以称作伪需求。说的不客气点就是自己YY出来的。有多少公司能达到阿里/腾讯那个数据量？会碰到他们的问题？不应该为一些很小的需求投入大量精力去改造。纯研究性质的另说。<br>hadoop现在真正欠缺的是<strong>易用性</strong>。技术已经很成熟，但对用户不友好。这里的用户不只是终端用户，也包括运维、开发。<br>很多项目为了追求技术的极致，为1%的性能提升而花费大量精力。一些出自学院派的项目尤其如此（想到scala，以用户大都是博士硕士为荣）。<br>其实如果能优化下用户体验，就推广上而言，远比1%的性能提升要好。<br>可能也是我最近做业务做多了。很多时候，技术都不是最重要的，够用就好。当然也不能太low。。。<br>Done is better than perfect嘛。<br>似乎我以前也<a href="/2015/06/27/some-gossip/">吐过这种槽</a>。。。<br>这算是学术界vs工业界？</p>
<p>其实很多发行版都在做出努力优化用户体验，但是还不够。<br>如果我是一个新用户，面对这么多项目、这么复杂的系统，肯定无从下手。我只知道我要建一个数据仓库/我要分析日志/我要实时监控，有人跟我说hadoop能解决，但具体怎么做？</p>
<p>咳，这本书就是告诉你怎么做的。扯了半天终于扯回正题了。。。</p>
<h1 id="关于本书">关于本书</h1>
<p>凭一本书当然不可能解决hadoop的易用性问题。<br>本书只是描述了各个组件的适用场景，结合一些实例，总结一些经验供读者参考。这些经验都是经过实践检验的，比较可靠，比自己慢慢摸索好多了。<br>对于我这样对hadoop比较了解，对其他项目也有一些了解，但缺少实践经验的人而言，本书非常适合，简直是雪中送炭。如果要我自己去构建一个系统，应该也能搞出来，但会比较痛苦，会踩很多坑，后续的维护性和扩展性也不好说。<br>但对新人而言，看这种书可能会比较累，一些设计上的抉择也不容易搞明白。建议先了解些基础知识。</p>
<p>下面系统的总结下。<br>如果要构建一个基于hadoop的系统（无论离线还是实时），要从哪些角度去思考？或者说，要<strong>如何设计数据流</strong>？<br>一个前提：<strong>不存在one fits all的解决方案</strong>。</p>
<h2 id="数据建模">数据建模</h2>
<p>这是第一步，也是最重要的一步，但却很容易被忽视。我们以前直接纯文本，最多lzo压缩下，简单直接。<br>按本书的说法，这里有很多问题要考虑：</p>
<ul>
<li>数据格式。纯文本？二进制？是否有schema？</li>
<li>文件格式。行式？列式？avro？parquet？sequence file？</li>
<li>压缩。是否压缩？lzo/snappy？splittable？</li>
<li>存储。数据存在哪里？hdfs/hbase/kafka？有些时候会存多份。如何分区？</li>
<li>元数据管理。这是最抽象的。很多时候都意识不到元数据的存在。hive？hcatalog？</li>
</ul>
<p>数据格式，这是由各个应用决定的。<br>文件格式，我会尽量选择parquet。因为hadoop最大的应用场景是文本处理，或者类似OLAP，列式存储会有很大优势。以前还有种文件格式rcfile，现在好像很少用了。也要看具体的应用场景，如果是偏向于整行处理的，也可以选择avro。甚至可以基于sequence file设计自己的文件格式。总之还是看自己的应用模式。<br>压缩，尽量选择snappy。parquet+snappy是非常完美的。parquet/avro是一种类似于“容器”的格式，是splittable的，而不必关心容器内的数据是如何压缩的，于是snappy不能split的缺点也可以克服了。以前我们用的最多的是lzo，只是为了split。但每个lzo文件还要单独加index太蛋疼了。另外由于许可证问题，lzo的部署也比较麻烦，snappy就简单很多。如果要归档历史数据，也可以考虑gzip/bzip2。<br>存储的选择很简单，批处理就hdfs，实时就hbase/kafka。但直接用kafka存数据的比较少见，一般只是拿它过渡。<br>元数据管理没什么统一的方案，要看自己的应用。但有个偷懒的方式，尽量把数据全部导入hive，让hive去管理元数据。</p>
<h2 id="数据导入">数据导入</h2>
<p>这是数据开始“流动”的起点。如何将数据导入hadoop？</p>
<ul>
<li>数据类型？日志？数据库？纯二进制文件？</li>
<li>数据处理模式？流式？批处理？随机读取？</li>
<li>push or pull？</li>
<li>传输过程中，是否需要一些处理/过滤？</li>
<li>sink类型？是否要增量更新？append/overwrite？</li>
</ul>
<p>最简单的方式是直接以文件形式传到hdfs上，<code>hdfs fs -put</code>。这种方法虽然土，但有效，而且可以导入任意格式的数据。缺点是不太可靠。<br>如果是从rdbms导入，只能用sqoop了，没有太多选择。<br>其他情况下，一般flume都是最优选择。在hadoop圈的日志传输工具里，flume算是最成熟的了。而且flume提供interceptor机制，可以做一些简单的实时处理。但处理逻辑如果太复杂，会影响flume节点的吞吐率。<br>flume另一个问题是可能有数据重复。这是所有日志传输工具都会有的问题。flume的理念是“at least once”，优先保证数据不丢失，但故障时允许重复。<br>想要做到真正的“exactly once”是非常难的，而且势必会影响效率。<br>flume支持pull和push模式。但push模式需要改应用代码，直接在代码中像log4j一样调用，感觉不太好。。。常用的还是pull模式吧。flume实现了基于文件的pull模式，但只有当文件写完后才能pull，也就是说数据不是实时的，不支持类似tail的模式。</p>
<p>如果目的地不是hdfs，而是hbase或是其他的系统，首先看下flume有没有提供对应的sink，没有的话就要自己写了。</p>
<p>另外，kafka虽然不是用于数据导入的，但它像万金油一样，到处都可以用，能玩出很多花样。。。比如应用直接写数据到kafka，flume从kafka读取数据并归档到hdfs；或者flume直接写到kafka，让其他应用去消费。这样数据的可靠性可以交给底层的kafka保证。而且kafka中的数据可以有多个消费者，同一份数据可以用于多个地方。</p>
<p>其实在现实中，很多公司会自己开发日志传输工具。<br>题外话，很多公司最常见的“定制开发”：日志传输和调度系统。这两个确实是和需求绑定比较紧的，不太容易通用。这种定制开发看着容易，随便写写就能cover 95%的需求，但剩下的5%才是真正的问题所在，决定了这个工具是“优秀”还是“能用”。</p>
<h2 id="数据处理">数据处理</h2>
<p>首先要明白自己的处理模式。<br>借用书中的一张图：<br><img src="/2015/10/12/hadoop-application-architectures/1.png" alt=""><br>如果简单点按响应时间分类，应该有3种：</p>
<ul>
<li>批处理/batch process，至少是分钟级别的。典型的比如MR、spark。特点是一次性处理大量数据，没有daemon。</li>
<li>交互式查询/ad-hoc query。一般是秒级别，比如impala。特点是有daemon进程常驻内存。spark也能部分覆盖到这个场景。</li>
<li>实时处理/流处理/stream process。处理模式跟前两者完全不同，基于每条日志去处理。比如storm。</li>
</ul>
<p>这是一种很模糊的分类，没有明确的界限，大概知道就可以。<br>ad-hoc query很多时候是由batch process优化得来的。如果能让MR有个线程池之类的东西，再加上一些优化，相信MR也可以作为ad-hoc query。<br>spark streaming虽然也号称是流处理，但真实的处理模型其实是micro batch。<br>所以不要纠结分类，知道每种工具的适用场景就可以了。</p>
<p>上图中最左边的custom，意思是如果要更实时的处理，只能自己实现了。想到高频交易那帮人。。。<br>个人感觉，spark有一统天下的趋势，各种场合都可以用。</p>
<h3 id="批处理">批处理</h3>
<p>hadoop最主要的用处。<br>批处理和交互式查询除了响应时间，很多时候计算模式是类似的。放在一起说了。</p>
<p>这里要区分计算引擎和工具：</p>
<ul>
<li>引擎：MR（经典/可靠/效率低）、spark（新贵/准备登基）、tez（已死/有事烧纸）、impala（没用过/不确定）。</li>
<li>工具：hive、spark sql、pig、crunch、cascading。</li>
</ul>
<p>引擎和工具的区别，就是执行效率和开发效率的取舍。直接写MR可以控制大量细节，人为的做很多优化，但是要写大量代码，开发和维护的代价都很大；如果用hive，直接写sql就可以了，但hive sql编译出来的job往往不是最优的。spark/spark sql也是同理。</p>
<p>重点说说MR和spark，至于其他的，其实不用关心。。。早晚会败在spark手下。。。<br>MR是非常经典的计算模型，最重要的设计是share nothing，所以可以简单的并行执行。在MR的过程中只有一次数据交换的机会，就是shuffle，所以多次迭代必须要多次MR。更为人诟病的是效率低，startup overhead非常大。<br>spark的初衷则是DAG处理，跟MR完全不同。spark感觉就是非常学院派的。。。spark在技术上的nb是毫无疑问的，发展非常快，但快也有很多问题，书中的原话是“Spark still has many rough edges”，以后应该会慢慢好转。</p>
<p>hive是sql on MR的标准实现，很多项目都兼容hive的语法/元数据，hive也慢慢变成sql on hadoop的标准了。<br>spark sql也兼容hive。但鉴于他们放弃shark的“前科”，未来如何还要再观察。<br>另一个有趣的对比就是hive on spark和spark sql，二者功能上其实有些重叠的。但spark的东家databricks似乎对hive on spark非常不感冒，坐看他们撕逼了。。。</p>
<p>对于impala，它是用C++写的，在hadoop圈中算是比较另类的存在。但对于交互式查询，好像只有impala比较成熟，其他一些类似的项目drill、stinger，基本都没人用的。所以在spark成熟前，在交互式领域，impala还是首选。</p>
<h3 id="流处理">流处理</h3>
<p>flume interceptor之类的暂不考虑，其实可选的工具就两种：storm和spark streaming。很久以前还有些其他的实时框架，S4什么的，但已经没人用了。</p>
<p>流处理和批处理的区别是什么？其实处理上是没什么区别的。。。感觉是用吞吐量的下降换取实时性。另外由于每次只处理一条数据，一些上下文相关的处理会比较麻烦。</p>
<p>我最早接触的实时框架就是storm，那时好像是0.7.x的版本。最让人惊艳是无状态的设计，nimbus可以随时重启，这是第一次见到。storm是最纯粹的record-based process，每次只处理一条。除了处理数据外，storm另一个重要作用是DRPC。ack机制也是storm的特色。<br>trident相当于扩展了storm，类似于hive与MR的关系，提供了更方便使用的接口，但似乎处理模型也有一些变化，变成了“伪batch”。<br>而spark streaming是“真batch”，它的实时只是降低了每次batch处理的数据量，同时提高处理频率。对实时性要求没那么高的情况下，性能会比storm好很多。不过，它真正的大杀器是批处理和流处理可以共用同样的代码。。。因为spark的RDD抽象层次很高，无论批处理还是流处理，都是对RDD的各种变换，只要改下作为输入源的RDD就可以。</p>
<p>对于流处理，一个很重要的问题是可靠性保证，一共有3个级别：</p>
<ul>
<li>at most once。每条记录最多处理一次。简单的说，数据发出去就不管了，即使处理失败也不会重发。这是安全性最低的级别，可能会有数据丢失。</li>
<li>at least once。每条记录至少处理一次。这也是大多数框架默认的级别。比如storm的ack机制，一条记录处理后必须ack一次，否则storm会认为处理失败，重发一次记录。但这样也可能造成重复处理。比如一条记录处理完毕，已经更改了外部的状态（比如mysql里的计数器+1），但ack()之前失败了，就会重复处理。</li>
<li>exactly once。最严格的可靠性保证，每条记录只处理一次。使用上有很多限制，对输入源、输出目标、编码方式都有要求。而且对效率影响非常大。</li>
</ul>
<p>一般最常用的还是at least once。<br>稍微google了下exactly-once语义。要实现exactly-once，首先输入源必须是transactional的，大概的意思就是输入必须是严格有序的，可以根据id回放，并且回放的数据必须和以前的完全相同。无论storm还是spark streaming，目前只有kafka输入源能满足这个要求。其次，在写程序时，也必须一些额外的工作，处理一条记录后，不能直接修改状态（比如直接改数据库），而要把状态分成多个阶段，beforeCommit、commit等，实现相应的方法。这样把状态更新交给上层去处理（storm或spark），storm或spark会将状态变换暂时缓存到内存里，当前记录或batch处理完后，才会真正更新。如果失败，会回放数据并重新处理。这中间的机制很复杂。</p>
<p>storm早期提供了一种transactional topology以支持exactly-once，大意就是每条记录必须完全处理完毕才能开始处理下一条，不用想就知道性能很差。<br>后来出现了trident、spark streaming等micro batch模型，对exactly-once友好了很多。换句话说，rollback的代价没有那么大了。<br>micro batch的另一个好处是写hbase性能会好很多，不用每条记录一次put。</p>
<p>个人感觉，选择哪个工具还是要看自己的应用，一般情况下spark streaming是最优的。<br>如果有特殊需求，比如实时性要求较高、DRPC等，可以选择storm/trident。</p>
<h3 id="处理模式">处理模式</h3>
<p>只是总结下常见的数据处理模式，不限定于具体工具，不限定于具体应用，不区分批处理与实时。</p>
<p>基础：filter、transform、aggregate<br>高级一点的：windowing analysis、graph processing<br>更高阶的：machine learning、visualization</p>
<p>我暂时能想到的就是这些。<br>对于基础，用任何工具去做都很简单。但对于其他模式，是有所谓的最佳实践的。<br>比如图处理，可以用MR去算，像page rank那样多次迭代。但更好的办法是用专门的工具，比如spark GraphX。<br>比如machine learning，可以用mahout或spark MLlib。</p>
<p>还是那句话，选哪种工具，看自己的应用场景。</p>
<h3 id="Lambda_Architecture">Lambda Architecture</h3>
<p>storm作者提出的一种架构：<a href="https://en.wikipedia.org/wiki/Lambda_architecture" target="_blank" rel="external">wiki</a>。</p>
<p>大意就是说基于hadoop的系统都要是这样一种架构：有批处理和流处理两条线，数据是不可变的，同时进入批处理系统和流处理系统。批处理用于处理历史数据，流处理用于处理近期的数据。查询时会同时从两个系统中查询并合并结果。</p>
<p>这种架构已经经过实践检验了，据说linkedin内部一直是这样的架构（我觉得是因为他们有kafka）。其实很多系统也会不自觉的向这种结构发展。</p>
<p>但这种架构争议也很多。最大的争议是处理逻辑变化时，要同时更改两个地方的代码。摘录一段：</p>
<blockquote>
<p>以类推方式，想想跨数据库ORM框架臭名昭著的困难，试图跨越这两个系统提供一个近似标准接口语言也会如此，试图在两个不同编程范式的顶部建立一个抽象层是非常难的。</p>
</blockquote>
<p>如果流处理足够强大，也许就不需要批处理部分了。但这种合并了批处理和流处理的方式还是值得参考的。</p>
<p>其实，很多理论未必是真理，尤其是提出时间不长的。比如CAP就有很多争议。BASE更是牵强。</p>
<h2 id="调度系统">调度系统</h2>
<p>这是永远的痛啊。。。hadoop圈中一直没有一种好用的调度工具，勉强能用的是oozie和azkaban。<br>如果用crontab能满足的话，还不如用crontab简单直接。<br>所以很多公司都会开发自己的调度系统。</p>
<p>oozie的配置太过复杂了，让人望而生畏，workflow的管理也很不方便，不直观。其他传参数、传第三方lib之类的，也很麻烦。<br>azkaban的优点是强大的web界面，很多配置可以在web上修改。问题在于修改workflow很麻烦，不能部分修改，因为它是以zip包形式管理的，只能整个替换。更麻烦的是要修改自己的代码才能被azkaban调度。</p>
<p>如果一定要选的话，也只能是azkaban了。最近似乎2.7.x版本发布了，不知道会不会有些改进。</p>
<p>另外我能吐槽下linkedin么，似乎开源项目的代码质量都不高啊。。。我看过WhiteElephant的代码，这哥们以前不是写java的吧？我也看了azkaban一点代码，也不咋样。不过这两个项目的前端倒是都不错。<br>想看高质量的代码，可以看hadoop，我看过一点yarn和hdfs的，受益匪浅。</p>
<h2 id="总结">总结</h2>
<p>只是个人感觉。</p>
<ol>
<li>大部分系统从这几个角度去设计：storage/ingestion/processing/analyzing/orchestration。</li>
<li>能用hive的尽量用hive，甚至整个pipeline架在hive上也可以，有很多好处：hive原生支持parquet/avro；支持各种计算引擎；可以方便的对接各种BI工具和查询工具；支持hiveserver；后续的索引支持；对hive sql的扩展更方便，写UDF比写MR/spark简单的多；方便做各种优化等等。说实话，我也不愿意写一大堆代码做ETL和各种计算，sql要简单的多。如果以后spark sql成熟了，也可以考虑。</li>
<li>不能用/不好用hive的地方，用spark。<strong>不要用MR。写scala，不要写java。</strong></li>
<li>尽量用parquet+snappy。</li>
<li>数据导入一般是flume+sqoop。</li>
<li>需要可实时读写的持久化存储时，考虑hbase。否则一般是hdfs。</li>
<li>实时处理优先考虑spark streaming，不能满足需求再考虑trident，最次storm。</li>
<li>kafka就像润滑剂一样，设计系统碰到困难时，试着扔个kafka进去。</li>
<li>牢记，<strong>抱着spark的大腿总是没错的</strong>。</li>
</ol>
<h2 id="实例">实例</h2>
<p>书中给出了几个实例，具体的设计过程我就不列了。看看架构图吧。</p>
<h3 id="点击流分析">点击流分析</h3>
<p>特点是完全离线处理。注意数据处理过程中的sessionization.<br><img src="/2015/10/12/hadoop-application-architectures/2.png" alt=""></p>
<p><img src="/2015/10/12/hadoop-application-architectures/3.png" alt=""></p>
<h3 id="反作弊">反作弊</h3>
<p>实时+离线，就是所谓的lamda architecture。<br><img src="/2015/10/12/hadoop-application-architectures/4.png" alt=""></p>
<h3 id="数据仓库">数据仓库</h3>
<p>跟传统的数据仓库概念差不多。只不过是基于hadoop的。<br>数据仓库的关键在于建模，很多时候要反范式。从架构图上看不出什么东西。<br><img src="/2015/10/12/hadoop-application-architectures/5.png" alt=""></p>
<h1 id="事实标准">事实标准</h1>
<p>跟技术无关的一些想法。<br>hadoop已经是大数据处理事实上的标准。谈到大数据，必言hadoop。hadoop应该称为data hub更合适，各种技术、框架依附于它而存在。<br>作为大数据处理技术，hadoop未必是最早的，未必是最NB的，却是最普及的。</p>
<p>在我心目中，hadoop生态圈中各种项目的“江湖地位”：</p>
<ol>
<li>事实标准：hdfs、yarn、hive、zookeeper</li>
<li>将成为事实标准：spark、kafka</li>
<li>能独当一面：hbase、flume、storm</li>
<li>能解决特定问题：pig、sqoop、oozie、azkaban、impala、mahout、hue</li>
<li>快退休的：MR、tez</li>
</ol>
<p>详细的项目列表见<a href="https://hadoopecosystemtable.github.io" target="_blank" rel="external">这里</a>，虽然我觉得其中一些项目不属于hadoop生态圈。<br>纯粹凭感觉分类。对我来说，大部分项目属于第4类，只是能解决特定的问题。如果能做的更好，覆盖特定领域的大多数问题，就会进化到第3类，能独当一面。至于能否进化到第2类甚至第1类，不光看技术，也要看推广，甚至是运气。</p>
<p>话说，前些年如火如荼的nosql运动好像沉寂很长时间了？我记得当时隔几天就有一个新项目冒出来，mongo/redis/riak/neo4j/cassandra/hypertable/couchbase，还有各种不知名的项目。<br>还是我太久没关注。。。<br>似乎只有mongo和redis活的还不错。</p>
<h1 id="题外话">题外话</h1>
<p>这篇文章写了近2周。<br>近一万字，我特么都没想到写了这么多。。。<br>借着总结这本书的过程，沿着书中的脉络，也总结了自己的一些想法，想到哪写到哪，比较随意。<br>夸张点说，我个人关于hadoop的所有理解，都总结在本文中了。<br>以后没事再来翻翻。碰到一些架构上的问题时也可以做个参考。</p>
<p>我看技术类书籍的习惯，喜欢在书上写写画画，文中很多内容其实是当时的笔记。<br>如果不能直接在书上写，一定要开着xmind，一边看一边总结。<br>个人觉得这样是比较好的读书方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>非常赞的一本书，链接：<a href="http://shop.oreilly.com/product/0636920033196.do" target="_blank" rel="external">OReilly Shop</a>，6月才出的。话说OReilly真是业界良心。<br>我订阅了<a href="http://www.hadoopweekly.com" target="_blank" rel="external">Hadoop Weekly</a>，某天它推荐了一篇cloudera blog，具体链接忘了，部分内容就是节选自本书，讲了实时处理的一些架构，当时就感觉很赞。于是找来原书看看，顿觉相见恨晚。<br>断断续续看了2个月，550多页啊，全英文。简单总结下。</p>
]]>
    
    </summary>
    
      <category term="hadoop" scheme="http://jxy.me/tags/hadoop/"/>
    
      <category term="读书" scheme="http://jxy.me/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二手的前端开发]]></title>
    <link href="http://jxy.me/2015/09/21/second-hand-frontend/"/>
    <id>http://jxy.me/2015/09/21/second-hand-frontend/</id>
    <published>2015-09-21T15:27:32.000Z</published>
    <updated>2016-09-15T15:50:39.000Z</updated>
    <content type="html"><![CDATA[<p>题目源自老郭早年的段子，“我是个二手的科学家”。<br>我觉得现在我就是二手的前端开发。。。</p>
<a id="more"></a>
<p>最近一周多的时间，一直在做些前端相关的东西。<br>因为没有专职的前端开发来对接。。。虽然我以前也用jquery写过一些小的内部系统，但这次又刷新了我对前端的认知。。。随便写些感想吧。</p>
<p><strong>上手容易，深入很难。</strong>html、css都算不上一门语言，只是一种标记，可读性很强，简单看看就能理解。but，理解不代表会用，要想达到自己想要的效果很难，要一遍遍尝试。<br>js上手也很快，脚本语言上手都快。但是用着就会发现有很多坑。。。坑爹的undefined，各种诡异的boolean判断，各种隐式的类型转换，各种callback。<br>说到callback，当我不知道promise对象的时候，满屏幕的function(){}，现在是满屏幕的done()。。。</p>
<p><strong>js是个有点奇怪的语言。</strong>最让我纠结的是函数也是对象这点。就跟光的波粒二象性一样。。。很难想象。对象不是由函数定义的么（构造函数）？Object()/Number()/String()其实都是函数吧？函数等价于一个Function对象？那Function这个函数是怎么定义的？于是变成了鸡生蛋蛋生鸡的问题。<br>对使用上倒没什么影响，但不能在逻辑上自圆其说让我很纠结。想要搞清楚这个可能要看看执行引擎是如何实现的了。<br>感觉js糅合了很多东西，但没做好。强行OO，可能当年非OO的语言都不会有人用吧。</p>
<p><strong>混乱。</strong>js的标准很混乱。官方标准就有ES5/6，而且各个浏览器的支持程度还不一样。我这个项目是没什么历史包袱的，想尝试些新特性，比如解构，结果chrome还不支持。。。非官方的还有typescript/coffeescript之类的，还有更奇葩的GWT之流，用java写前端，简直就是妖孽啊。。。虽然我对java更熟，但也觉得这种方式很奇怪，而且肯定很多坑。google的东西也不会总是好的。<br>css的支持也是因浏览器而异，一些样式在safari中不支持。。。HTML5的标准也是。<br>不过相对于前些年，现在应该好很多了吧。<br>更混乱的是各种MV*框架。本来我打算选一个框架来用的，但不知道怎么挑。angular/react/vue/ember/backbone各种。本来想尝试下angular，听说它是按后端的逻辑来写前端，但又听说它是个大坑。。。而且1和2还不兼容，这种断代式的升级是非常讨厌的，想想python。。。而且这些框架可能很快也会过时，还特么互不兼容。<br>也许专业的前端不觉得乱吧，但对想入门的新人而言，还是很头疼的。<br>咨询了一个前端的同学，最后还是决定老老实实用jquery了，继续折腾DOM，土就土点吧。</p>
<p><strong>发展迅猛，有活力。</strong>也许这是“混乱”的另一种说法。。。最直观的表现是开源项目非常多，基本我能想到的需求，都有开源实现，稍微改下就能用。我还找到了用js写的sql语法解析器。。。还有jquery的各种插件。各种主题、样式也非常多，可以找到很多酷炫的UI KIT。<br>我觉得原因之一是做前端的人普遍更活跃，不像搞后端的都比较闷。。。至少从我接触到的人看是这样，无论online/offline。我相信编程语言真的是能影响一个人的行为模式的。</p>
<p><strong>css真是给程序员用的？</strong>真的有程序员手写css么？那么多效果是怎么记住的啊，关键是怎么脑补出在浏览器中的显示效果。。。我只会用css做一些简单的布局，但效果总是跟我想得不一样，很诡异。。。<br>但好的css真的是非常漂亮，我觉得这不是给程序员用的，是给设计师用的吧。css也有一些模板语言，less/stylus，但我从来没用过。我已经放弃自己写css了，直接找了套bootstrap的模版。</p>
<p><strong>HTML5是个好东西。</strong>html是一切前端技术的载体。想起了若干年前用editplus写html的场景。。。对我来说html5最好用的是session/local storage，一些状态信息完全可以存在前端了，否则就只能存在cookie里。<br>新增的一些input类型也很好用，但好像在一些浏览器下无效。</p>
<p><strong>前端不只是技术，还有很多的UI/交互设计，甚至可以说是艺术。</strong>我以前写的一些页面，界面丑就丑吧，反正是给内部用的。如果是我自己用的，有个命令行就满足了。但当你真的要去面对用户时，就会去考虑如何设计页面、如何能让使用更方便。比如整个站点的配色是否一致？风格？交互是否应该优化？点击删除按钮，要不要弹出一个确认的对话框？一些操作是否要有进度条提示？<br>对我这种强迫症患者，这个比技术问题还让我头疼，经常纠结在一些细节上。比如某个复选框，我想把它换成iphone风格的开关，折腾了一天。这样很容易拖慢整体的进度。。。<br>我算是体会到UED的难处了。</p>
<p><strong>所有业务逻辑放在前端真的好么？</strong>在这次的项目中，我大部分的业务逻辑都是用js实现的，后端对我而言只是个数据库，提供给我增删改查的REST接口就好了。我觉得这样设计比较自然，但这样真的好么？<strong>设计中最重要的事情是解耦。</strong>也许这种模式确实把后端和显示的逻辑解耦了，但感觉只是把复杂性转移了，并没有真正解决。至少我的js代码和html耦合还是非常紧，因为jquery依赖于整个DOM的结构和各种元素的id。如果以后html改了，要改js就会很头疼。这个我还不知道如何解耦。也许用一些框架会好些？<br>而且这种方式会不会有性能问题？如果数据量变大的话，是否会超出js的处理能力？</p>
<p><strong>前端更容易有成就感。</strong>至少对我而言是这样。因为做的是看得到的事情，比较有存在感。。。直接面对用户，接收用户的反馈，知道自己的东西真的有人在用。做出好看的页面，酷炫的效果时，都会很开心，没想到自己真的能做出来。<br><br><br>想到哪写到哪，顺便写写其他的事吧。</p>
<p><strong>如何跟他人合作？</strong>或者说，如何让一个团队协同工作？其实道理说起来很简单，还是<strong>解耦</strong>，每个人负责的工作必须要独立，尽量减少人与人之间的直接沟通，成本太大了。只要定义好各个模块之间的接口。但实行时还是会遇到各种问题，要根据实际情况处理。如无必要，我不想去修改别人的代码，别人也不要改我的代码。每个人只对自己的接口负责即可。<br>我经历的一些项目中，两个人共同写同一个类，甚至是同一个方法，真是噩梦。。。尤其是他人的逻辑跟你完全不同时。这是个教训，当初的设计和分工都有问题。<br>以前身边都是大牛，不用我来考虑这种事情。。。现在不行了。。。<br>题外话，设计中常用的解耦手段：1.MQ；2.事件驱动；3.REST，或者说基于HTTP的接口。至少是我经常用的。</p>
<p><strong>一些怪事。</strong>或者说我见到的一些坏习惯。我最近也是看了不少奇葩代码。。。</p>
<ul>
<li>为什么爱自己造轮子？不愿意用一些现成的类库。比如guava，我已经离不开了，但很少看到别人用。。。还有其他一些已经成为业界标准的库，比如apache commons系列、slf4j之类。</li>
<li>为什要敲一些无脑的代码。。。比如POJO，有人手写setter/getter，这种代码完全不用经过大脑啊。这会显得自己有事做？一副很忙的样子？</li>
<li>为什么不愿意格式化下代码。。。eclipse都提供快捷键了，按一下很麻烦么。</li>
<li>实现一个只有public staitc常量的接口是要闹那样。。。</li>
</ul>
<p>一个感受是，<strong>很多时候撕逼的能力比技术更重要</strong>。。。都是血泪的教训，不多说了。<br>另一个感受是，做的好不如说的好，这真是悲哀，但这是现实。懂的自然懂。</p>
<p>不知不觉写了这么多。。。我都觉得自己很唠叨。<br>二手前端生涯已经告一段落了，我还是回去干老本行了。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目源自老郭早年的段子，“我是个二手的科学家”。<br>我觉得现在我就是二手的前端开发。。。</p>
]]>
    
    </summary>
    
      <category term="杂谈" scheme="http://jxy.me/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="前端" scheme="http://jxy.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一些胡思乱想]]></title>
    <link href="http://jxy.me/2015/09/04/some-messy-thought/"/>
    <id>http://jxy.me/2015/09/04/some-messy-thought/</id>
    <published>2015-09-03T17:31:29.000Z</published>
    <updated>2015-09-13T06:56:44.000Z</updated>
    <content type="html"><![CDATA[<p>挺久没写了。一直忙着各种杂事。<br>最近稍微安定下来了，胡乱写些最近的想法吧。</p>
<a id="more"></a>
<h1 id="大公司与小公司">大公司与小公司</h1>
<p>就我个人的感受，小公司的人与人的联系要更紧密。因为人少，而且业务导向，人与人之间的直接交流会比较多，互相比较熟悉。<br>以前在网易的时候，大多数工作都在popo上，一天难得说几句话。很多人我只知道名字。。。</p>
<p>大公司流程比较多，小公司不太在意这些，只要能完成任务就行。这点我比较不习惯，一些项目没有文档／jira，只靠口口相传。。。没有需求／设计的过程，直接码代码。。。<br>我的感觉，流程不能过多，但也不能完全没有，这是个取舍的过程。<br>更多的流程会减少出错的概率，但也带来很大的overhead。没有完美的方案。</p>
<p>我讨厌开会，很多会议跟我关系不大，只是“为了以防万一”叫上尽可能多的人。。。就像转发邮件要cc尽可能多的人，事后如果出问题可以免责。。。这点小公司比较有优势。</p>
<p>大公司遇到牛人的概率会大点。大公司做事有些偏向于研究的性质，而小公司更多关注业务。如果能用很low的技术实现一个需求，小公司就会一直重复着这个技术，能用就行。久而久之，很多人技术上也不会有长进。这是要警惕的。<br>倒不是说小公司技术不行，而是缺乏动力去升级技术方案，除非被逼急了，随着业务的扩张，老的方案已经hold不住。<br>当然也要看场景，过度优化／设计也是不行的。</p>
<p>另外最近我看到了一些奇葩的代码，不得不吐槽，<code>extends Object</code>是要闹哪样。。。<br>感觉很多人脱离spring就不会写程序了啊，觉得java就是tomcat。。。<br>我在网易也见过一些奇葩代码，比如6个嵌套的for循环。。。</p>
<p>好的代码总是相似的，烂的代码各有不同。还是见识的太少啊。</p>
<h1 id="关于MAC">关于MAC</h1>
<p>特指macbook。<br>mac真的是生产力工具啊，创业公司配置mac不是没有理由的。<br>用熟了之后，效率比windows上升不知几个档次，非常适合程序猿。<br>键盘＋触控板，完全不需要鼠标了。</p>
<p>而且mac下有好多神器：</p>
<ul>
<li><a href="http://brew.sh" target="_blank" rel="external">brew</a>/<a href="https://github.com/caskroom/homebrew-cask" target="_blank" rel="external">brew cask</a>。包管理工具。我发现很多系统都有包管理啊apt-get/yum/pip/gem/npm，这是发展的必然趋势？</li>
<li><a href="https://www.alfredapp.com" target="_blank" rel="external">Alfred</a>。无法形容。。。什么都能干。。。关键是可以自己扩展。</li>
<li><a href="http://www.hammerspoon.org" target="_blank" rel="external">HammerSpoon</a>。有点类似alfred的workflow，但是更面向程序员，更加强大，可以自己写lua脚本控制系统的方方面面，相当于系统和用户的一个中间层。用的好的话，hammerspoon可以代替其他很多程序。</li>
<li><a href="http://vagrantup.com" target="_blank" rel="external">Vagrant</a>。本质上是一个虚拟机管理工具。我想搭一些测试环境，但又不想弄乱本身的系统。本来想用docker的，更轻量级，也更流行。但mac不支持lxc，不能直接用docker，很蛋疼，要通过一个虚拟机中转，不如直接用vagrant了。</li>
</ul>
<p>还有更多神奇的东西。不一一介绍了。</p>
<h1 id="hexo历史版本">hexo历史版本</h1>
<p>在mac上写blog，安装hexo的过程中碰到一些问题。由于我用的主题与hexo最新版不兼容，要安装2.8.3版本：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="operator"><span class="keyword">install</span> -g hexo@<span class="number">2.8</span><span class="number">.3</span> <span class="comment">--registry=http://r.cnpmjs.org</span></span></div></pre></td></tr></table></figure>

<p>加上registry参数是因为国外的镜像很慢。<br>记录下。</p>
<h1 id="python和ruby">python和ruby</h1>
<p>最近想挑一门动态语言深入学习，在python和ruby之间犹豫了下。<br>二者其实我之前都有接触过，但浅尝辄止。<br>python用来写简单的运维脚本，还折腾过一段时间Django。<br>ruby折腾Jekyll时了解过一点。</p>
<p>ruby很像perl，让我不爽。我对perl是敬而远之，能写perl的都是大神。<br>但又听说ruby有很多好玩的特性，学ruby能开阔眼界，尤其对我这样用惯了java的，有点心动。<br>ROR也很让人流口水。。。<br>以前一直以为ruby大部分是做web开发，但ruby也能实现brew这种神器，顿时对ruby改观了。就像我第一次知道nodejs，知道js也可以写后端一样。</p>
<p>但python似乎应用更广泛，类库更多。<br>而且spark官方提供python接口。<br>蛋疼的是python2和python3，不知道社区怎么搞成这样的。。。</p>
<p>至于网上其他人讨论的缩进／end／效率什么的，对我而言都不是事。<br>我觉得选择一门语言，主要看它的“哲学”。<br>语言能改造我思考问题的方式。</p>
<p>继续纠结。。。</p>
<p>更新：选了python，因为spark。<br>另一个原因是我还要研究下scala，还是因为spark。。。<br>感觉scala和ruby有点像，都是特别灵活，都是混合多种范型（真OO无双但是又支持函数式编程），都是many ways to do one thing。二者择其一，而scala是无法放弃的。</p>
<h1 id="关于读书">关于读书</h1>
<p>以前我很喜欢买纸质书，虽然完整看完的不多。。。<br>后来就更喜欢电子书了，因为纸质书搬家太麻烦了。。。<br>最近在看《Hadoop Application Architectures》，非常赞，近期写个读书笔记吧。<br>希望以后还能有充足的时间看书吧。</p>
<p>吐槽一些书，明明很简单的事情，偏偏说的很复杂。想起以前看的某本js教程，章节名字都是类似“沙场秋点兵”这种，各种引经据典，各种比喻、类比，看得非常累。。。反正我翻了几页就拿去垫高显示器了。。。<br>也许那些书适合完全不懂的人吧。对我这样稍微有些基础的，直接讲技术就好了。<br>我宁愿去看官方文档。</p>
<p>另外中文书真的是很多坑。。。我买的书多，踩的坑也多。不是我不想支持正版，有些根本就是粗制滥造，大段的代码，大段文字都是抄官方文档。这种东西也好意思拿出来卖？<br>比如前段时间研究Jersey，搜了半天中文的书只有一本《Java RESTful Web Service实战》。60多块钱买来一看，真特么后悔。。。<br>所以买书之前预览下电子版还是很有必要。。。<br>这些年买的最有诚意的书是《锋利的jQuery》。</p>
<p>如果是翻译的，可能更头痛。比如《Hadoop权威指南》，各种名词译的非常奇怪。。。我得先看英文版，找到那个单词，才知道中文版是什么意思。。。你不会译就保留原文不行么。。。所以我向人推荐的时候都说直接看英文版。不知道后几版的翻译有没有改进。<br>也有翻译的好的，《HBase权威指南》就还行。<br>翻译的书更大的问题是版本落后于原书。比如《Hadoop权威指南》英文已经出到第四版了，而中文还停留在第二版，其中很多用法已经过时，甚至被移除了。对hadoop/spark这种快速发展的项目，这个问题很严重。</p>
<p>总之，买书还是要谨慎。。。</p>
<h1 id="吐槽MVC">吐槽MVC</h1>
<p>最近参与一些小项目，发现还在用jsp、freemarker、velocity之类做视图层。我怎么感觉这是上个世纪的技术了。。。<br>传统的三大框架SSH，感觉已经是老大哥一样的存在了。<br>个人感觉，web应用中，越来越多的逻辑都移到前端了。以MVC架构而言，后端往往只负责M，只提供数据接口，而VC都完全由前端控制。原来后端负责的一些业务逻辑，现在都是在前端用js实现的，比如各种单页面应用。<br>这样前端和后端的耦合也比较小，只要定义好数据接口就可以了。而且无论app还是web，都可以使用同样的后端接口。<br>什么时候有这种趋势的？是随着移动互联网开始的？我也不知道。<br>其实是将以前后端的很多工作转移到前端了，导致前端越来越复杂，都出现自己的MV*框架了。。。<br>另外前端的xxx框架太tm多了，都自成一派，没有能一统江湖的。我还是老老实实用jquery算了。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>挺久没写了。一直忙着各种杂事。<br>最近稍微安定下来了，胡乱写些最近的想法吧。</p>
]]>
    
    </summary>
    
      <category term="杂谈" scheme="http://jxy.me/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="hexo" scheme="http://jxy.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[谢谢，再见]]></title>
    <link href="http://jxy.me/2015/08/05/goodbye-netease/"/>
    <id>http://jxy.me/2015/08/05/goodbye-netease/</id>
    <published>2015-08-05T14:54:04.000Z</published>
    <updated>2015-09-03T15:42:14.000Z</updated>
    <content type="html"><![CDATA[<p>离开网易，感觉就像离开国企下海了。。。<br>吐槽是种病啊。。。</p>
<a id="more"></a>
<p>虽然是我自己的决定，虽然早有心理准备，还是有些伤感的。<br>毕竟呆了4年，学到了很多东西，认识了很多人。</p>
<p>我很幸运，以网易作为职业生涯的起点。<br>更幸运的是，抱着感激之心离开。</p>
<p>遗憾还是有的，有些事情本来可以做的更好。<br>希望接手我代码的同学不要打我吧。。。<br>希望他们看到我各种奇葩注释时，笑一笑。<br>希望后台能发展的更好。</p>
<p>我也想豪爽的说句“青山不改，绿水长流”。<br>但好像不太符合我的风格。</p>
<p>总之，谢谢网易，谢谢所有帮助过我的人，恕我不能一一道别了。<br>我们有缘再会。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>离开网易，感觉就像离开国企下海了。。。<br>吐槽是种病啊。。。</p>
]]>
    
    </summary>
    
      <category term="杂谈" scheme="http://jxy.me/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试总结]]></title>
    <link href="http://jxy.me/2015/07/19/interview-summary/"/>
    <id>http://jxy.me/2015/07/19/interview-summary/</id>
    <published>2015-07-19T08:48:04.000Z</published>
    <updated>2015-09-03T15:42:14.000Z</updated>
    <content type="html"><![CDATA[<p>去面试了一些公司，稍微总结下。</p>
<a id="more"></a>
<p>面试的过程不只是公司考察被试者，被试者也要考察公司，判断一家公司是否值得去。这是一个双向选择。无论大公司小公司、上市的还是创业的、国内的还是国外的，都需要这样一个判断过程。<br>其实这个判断是很感性的，有时候就是喜欢/不喜欢一家公司，没什么规则。而且每个人都不一样。比如我，如果能去google，可能不要钱也会去。。。毕竟那里可以说是大数据的发源地，很想去看看。有点像旅游观光。。。</p>
<p>但我还是尝试总结下，主要有以下几个因素（按重要性递减）：</p>
<ol>
<li>和你一起共事的人。这是最最重要的。包括主管/同组同事/其他组的人。如果能有技术大牛带你，最好不过。如果面试过程中觉得对方技术很渣，或者人品有问题，赶紧走。我碰到过一些面试官让我觉得很不舒服，要么不懂装懂，问一些假大空的问题（XXX的价值是什么？）；要么态度很差，居高临下。我觉得和这些人共事不会开心。</li>
<li>HR给人的感觉。重要性仅次于同事。因为HR往往代表着一家公司的风格/价值观，真的是一家公司的脸面。有些HR让你觉得很舒服，有些HR则会各种挑刺。我说我喜欢一个人码代码（没有码农喜欢写代码时被打断吧），有的HR觉得这是一种钻研精神，有的HR觉得这是你不懂合作。。。而且某些HR会诱导你说出一些对你不利的话，好压低对你的评价。说到价值观，我一直觉得应该是求同存异，但某些HR/公司一定要强行灌输价值观，如果不能认可，进去也不会开心。</li>
<li>工作的内容。上面两条是看人，这条是看事。进去之后做什么工作？会不会学到一些新的技术？会不会有成长？尽量是核心的业务、核心的部门。一些边缘的部门呆着可能会比较痛苦。</li>
<li>氛围。这是比较虚的一个东西，但各个公司的氛围真的是有差别的。面试的时候我一般会尽量多逛逛工作区，看看员工真实工作的样子。有些公司明显会比较压抑，大家交流很少，员工看着就像苦大仇深一样。。。有些公司等级森严，各种制度太多。我希望是一个比较自由，大家可以畅快交流的工作环境。如果有认识的人在里面，一定要多打听下这方面。</li>
<li>最后才是可以量化的一些指标：薪资、期权、福利之类的。说实话，如果一家公司真的让我觉得很舒服，即使工资低我也愿意去。</li>
</ol>
<p>以上算是一些简单的总结吧，只适用于我个人。当我面临多个机会时，我会按这些条件去筛选。</p>
<p>反过来想想，我也曾作为面试官去面一些人。如果按上面的判断标准，不知道我是否合格。。。我给人的感觉是什么样的呢。。。<br>不过我只会问一些技术问题，而且是比较细节的。我最常问的就是shuffle/二次排序。。。应该不会让对方不舒服吧。。。</p>
<p>胡言乱语，博君一笑。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>去面试了一些公司，稍微总结下。</p>
]]>
    
    </summary>
    
      <category term="杂谈" scheme="http://jxy.me/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HBase豆知识]]></title>
    <link href="http://jxy.me/2015/07/06/hbase-tips/"/>
    <id>http://jxy.me/2015/07/06/hbase-tips/</id>
    <published>2015-07-06T06:26:34.000Z</published>
    <updated>2015-09-03T15:42:14.000Z</updated>
    <content type="html"><![CDATA[<p>近日重看了《HBase权威指南》，结合着0.98.8的代码，总结一些知识点。<br>由于hbase版本更新很快，而且每个版本变化都很大，本文不一定适用于其他版本。<br>我们是0.94和0.98混着用的，也可能有些0.94的知识点混在里面。。。</p>
<p>话说，<code>hadoop</code>还是<code>Hadoop</code>我都觉得挺正常，但<code>hbase</code>就不如<code>HBase</code>顺眼。。。</p>
<a id="more"></a>
<h1 id="B+树和LSM树">B+树和LSM树</h1>
<p>太理论的我也不懂。<br>B+树是传统RDBMS中实现索引的关键。特点是数据都在叶节点，而且查找操作非常高效。<br>但更新代价比较大，可能导致叶节点的分裂。更新索引的时间可能比真正写数据的时间还长，一些大表的索引比数据还大。<br>而且对磁盘的依赖较大，因为机械磁盘的随机读写性能都是比较差的。所以RDBMS都在往SSD发展。。。<br>较适合读多写少的情况。</p>
<p><a href="http://www.cnblogs.com/siegfang/archive/2013/01/12/lsm-tree.html" target="_blank" rel="external">LSM树</a>的核心思想在于延迟更新，会将数据/索引的更新暂时以日志的形式记录下来，等待后台线程去合并。<br>可以将随机写转化为顺序写（将update和delete都转化为insert），所以不像B+树那样受机械硬盘的限制。<br>特别适合大量写入的情况。读性能也不错，但storefile过多的话，估计读性能会下降比较快。<br>由于需要后台线程合并，有额外开销。当这种额外开销超过带来的性能收益时，就不值得了。也是一种trade-off。</p>
<h1 id="关于hlog">关于hlog</h1>
<p>注意hlog是regionserver级别的。所有region的日志都会写到一个文件中。当需要回复的时候，按不同的region拆分hlog。拆分好后，region才会开始回放日志。这个拆分的过程可能会非常慢，因为日志文件没有任何索引，只能从头遍历。<br>这种设计的前提是需要hlog拆分的情况比较少，可以将所有hlog写入转换为顺序写，提升性能。如果每个region维护一个hlog，可能造成大量随机写。</p>
<p>hlog其实就是hadoop的sequence file，其中key是HLogKey对象，包括region，tablename、sequence id、时间戳等信息；value是WALEdit对象。一个WALEdit对象中可以包括多KeyValue对象（这应该是为了保证行级别的原子性。如果更新一行中的多个列，会产生多个KeyValue对象，但在hlog中只保存一条记录）。</p>
<p>hlog对于写入影响很大，所以可以关闭wal或者延迟刷新wal以提升性能。</p>
<p>日志文件滚动有2种情况：</p>
<ol>
<li>regionserver中的LogRoller进程每一小时触发一次日志滚动。</li>
<li>当日志文件达到hbase.regionserver.hlog.blocksize大小时，触发日志滚动。</li>
</ol>
<p>每次日志滚动的时候，都会触发一次对oldlog的检查。这个检查有2种情况：</p>
<ol>
<li>遍历所有hlog file，如果某个hlog file中最大的sequence number小于所有store file中最大的sequence number，说明对应的hlog file中的记录已经全部持久化了，这个hlog file可以被删除了。所谓删除也不是马上删除，而是移动到一个临时目录（0.94是/hbase/.oldlogs），等待master中的一个LogCleaner线程来删除。相关逻辑见FSHLog.rollWriter方法。</li>
<li>如果hlog file文件数量大于hbase.regionserver.maxlogs，就遍历最老的一个hlog，找到哪条记录还没有被持久化，强制相应的region做一次flush，然后将最老的文件移动到临时目录等待删除。</li>
</ol>
<h1 id="hlog拆分">hlog拆分</h1>
<p>当集群启动或regionserver挂掉时，都需要拆分/回放日志。<br>以0.94 hbase为例。<br>所有hlog都存在/hbase/.logs/${regionserver.id}目录下。当回放hlog时，hmaster会按顺序遍历这个目录下所有文件，将对应region的日志放到一个临时目录/hbase/splitlog/${regionserver.id}/${region.name}。当一个hlog拆分完毕后，对应的文件会移动到/hbase/.oldlogs，等待master中的线程去定期删除。当所有hlog文件拆分完毕后，将拆分后的日志移动到/hbase/${table.name}/${region.name}/recovered.edits目录，然后打开region。region打开时如果发现recovered.edits目录，就会回放其中的日志，回放完毕才能对外服务。</p>
<p>hlog拆分机制经历过很多变化，从早期版本的单线程拆分，到多线程，到目前的分布式处理。</p>
<h1 id="关于HA">关于HA</h1>
<p>hbase没有真正的实现HA。根据上面的分析，当一个regionserver挂掉后，要经历很长时间的hlog拆分、回放过程。<br>拆分log时，会遍历/hbase/.logs下所有文件，日志越多恢复服务所需时间也越长。<br>所以及时删除log是很必要的，删除机制见我上面的分析。</p>
<h1 id="region_split">region split</h1>
<p>用户可以设置自己的split策略，我们一般用ConstantSizeRegionSplitPolicy，同时将hbase.hregion.max.filesize设为一个比较大的值，这样可以手动控制split的时机。注意这个属性限定的是一个store的大小，而不是整个region的大小。<br>split过程非常快，因为只是新建一些引用文件，当一个引用文件对应的数据被compact处理后，才会删除引用文件。<br>当一个region中存在引用文件时，不能再次split。</p>
<h1 id="触发compact检查的几种情况">触发compact检查的几种情况</h1>
<p>compact是hbase里特别折腾人的机制之一。<br>有几种操作会触发compact检查：</p>
<ol>
<li>memstore flush</li>
<li>在hbase shell里执行compact、major_compact命令</li>
<li>调用HAdmin类的相应方法</li>
<li>regionserver中有一个线程CompactionChecker，默认每10秒执行一次，检查所有online的region</li>
</ol>
<p>每次触发compact检查后，再判断是minor还是major（用户手动触发的major_compact除外）。<br>compact的临时数据会写到/hbase/${table.name}/${region.name}/.tmp目录中。</p>
<p>RegionServer中有一个对象CompactSplitThread负责compact/split/merge region。这货虽然叫XXThread但其实不是线程。。。<br>每个compact是否是major，由CompactionPolicy.isMajorCompaction方法决定。<br>默认的RatioBasedCompactionPolicy只会检查hbase.hregion.majorcompaction属性。<br>所以这个属性设为0之后就不会触发major compact。但由minor提升而来的major还是存在的（如果某次minor compact选择的storefile就是当前region的所有storefile，就会提升为major compcat，只会出现在写入较少的表上）。<br>每次compact后会再检查一次是否要split。</p>
<h1 id="关于flush与compcat">关于flush与compcat</h1>
<p>每次flush后，都会检查是否需要split、是否需要compact，见MemStoreFlusher类。<br>如果要split，就直接split；否则再检查是否要compact。是否compact由StoreEngine.needsCompcation方法决定。<br>默认是DefaultStoreEngine，其实是交给RatioBasedCompactionPolicy.needsCompaction方法决定。<br>我以前以为split后会立刻触发compact，看来不是。</p>
<h1 id="关于large和small线程池">关于large和small线程池</h1>
<p>CompactSplitThread中有两个线程池：large和small。<br>如果一次compact要处理的数据量大于hbase.regionserver.thread.compaction.throttle，就进入large线程池。否则进入small线程池。<br>这个large/small和是否major compact没有必然联系。不知为何要这样设计。</p>
<h1 id="关于hfile">关于hfile</h1>
<p>HFile格式：<br><img src="/2015/07/06/hbase-tips/1.png" alt=""></p>
<p>KeyValue格式：<br><img src="/2015/07/06/hbase-tips/2.png" alt=""></p>
<p>HFile一旦写入完成，就是不可变的。因为hdfs要修改已经存在的文件只能append，而HFile元数据在末尾，不能直接append。<br>DataIndex和MetaIndex是类似于B+树的索引结构。RegionServer启动的时候，会将所有索引加载到内存里，便于后续查找。<br>这个索引只能到块的级别（索引了每个块的rowid范围），同一个块内的KV是没索引的，只是按Key排序。所以想找特定的KV时，可能要遍历整个块。<br>注意只有rowid是有索引的，而且对于column family、column qualifier是没索引的。</p>
<p>hbase默认的块大小是64KB。写入的数据量大于64KB后，会生成一个新的块并写入。如果开启了压缩，写入的数据一般小于64KB。如果写入一个特别大的KV，也可能大于64KB。<br>hbase的块和hdfs的块没有任何关系。</p>
<p>KeyValue其实很多信息都是冗余的。比如column family，在同一个storefile中肯定全都是一样的。<br>为了减少查询开销，节省空间，务必选择名称较短的列族和列。</p>
<h1 id="hbase读路径">hbase读路径</h1>
<p>说说自己的理解，没有看代码求证过。</p>
<ol>
<li>如果读请求中包含时间戳条件，根据storefile的时间戳排除一些文件。</li>
<li>如果能应用bloom filter，又可以排除一些storefile。</li>
<li>在剩下的storefile和memstore里扫描所需数据。由于storefile和memstore是有rowid索引的，可以快速选出一批备选storefile。</li>
<li>扫描备选的storefile，定位到所需的block。遍历block，找到所需的KeyValue。在这个扫描过程中，还要加上其他一些过滤条件，比如特定的列名。</li>
<li>猜测扫描顺序是先memstore，再按时间降序扫描所有storefile。这样可以取得最新的数据，跟踪到同一份数据的update/delete。</li>
</ol>
<h1 id="关于二级索引">关于二级索引</h1>
<p>hbase中只有一种索引：rowkey（转换成byte[]按升序排列）。而如果需要多种索引就比较麻烦。</p>
<ol>
<li>存多份数据，并建不同的rowkey格式。缺点是数据量放大很多倍。</li>
<li>用户自己维护一个索引表。其实不一定是索引表，也可能是用于索引的列族。这种方式很难保证原子性，很可能数据表已经更新，但索引表还没更新（索引表可能是用MR定期更新）。而且用户写代码时也要自己处理索引表相关逻辑。</li>
<li>coprocessor。不是很了解，我的理解是将方法2中用户手动的操作转换为服务端自动的操作。</li>
</ol>
<h1 id="关于bloom_filter">关于bloom filter</h1>
<p>相关原理见<a href="http://blog.csdn.net/jiaomeng/article/details/1495500" target="_blank" rel="external">这篇文章</a>。<br>bloom filter对get操作很有效，因为可以快速判断一个rowkey是否在一个storefile里。<br>但scan操作不一定有效，因为scan是个范围，bloom filter无法判断这个范围的所有rowkey是否都在某个storefile里。</p>
<p>在0.98中建表是默认都开启了ROW级别的BloomFilter。<br>ROW级别的BloomFilter对Scan一定是无效的。<br>ROWCOL级别的BloomFilter对包含列条件的Scan可能有效。</p>
<p>所以bloom filter是否适用还是要看自己的使用场景。</p>
<h1 id="常见服务端优化">常见服务端优化</h1>
<ol>
<li>JVM调优。regionserver对内存非常敏感。目标：减少老年代的内存碎片，尽量让对象在新生代就死亡；减少FGC，否则可能触发zk超时。</li>
<li>开启MSLAB特性。默认是开启的，但可能浪费一些内存。</li>
<li>开启snappy压缩。snappy压缩优于lzo。</li>
<li>手动管理split和compcat、监控storefile数量。这也是无奈之举。尽量在流量低的时候做这些操作。</li>
<li>分散热点，将写入量较大的region分散到不同regionserver。</li>
</ol>
<h1 id="常见客户端优化">常见客户端优化</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 客户端务必关闭autoFlush，这样数据会批量提交</span></div><div class="line">table.setAutoFlush(<span class="literal">false</span>,<span class="literal">false</span>);</div><div class="line"> </div><div class="line"><span class="comment">// 写数据时，对于不重要的数据可以异步写入WAL，可以提升性能</span></div><div class="line">put.setDurability(Durability.ASYNC_WAL);</div><div class="line"> </div><div class="line"><span class="comment">// 写数据时，对于不重要的数据可以关闭WAL</span></div><div class="line">put.setDurability(Durability.SKIP_WAL);</div><div class="line"> </div><div class="line"><span class="comment">// scan时，加上尽可能多的条件，不光starkey、endkey，如果有column family、column qualifier，也尽量加上</span></div><div class="line"><span class="comment">// 能加filter的话也尽量加上。这样可以让服务端过滤更多数据</span></div><div class="line"> </div><div class="line"><span class="comment">// scan时，设置cache和batch，减少RPC次数</span></div><div class="line"><span class="comment">// cache控制每次RPC请求返回多少行，batch控制每行最多返回多少列</span></div><div class="line"><span class="comment">// 在程序里设置cache和hbase.client.scanner.caching属性是一样的效果</span></div><div class="line"><span class="comment">// 参考http://m.blog.csdn.net/blog/jiaomicha/23871123</span></div><div class="line"> </div><div class="line"><span class="comment">// scan返回的ResultScanner，记得close</span></div><div class="line"> </div><div class="line"><span class="comment">// scan时，只返回需要的数据，减少网络流量</span></div><div class="line"><span class="comment">// 如果只需要某一列的，那就把列加为scan的条件</span></div><div class="line"><span class="comment">// 如果只需要rowkey，不需要任意列的数据，可以加filter只返回rowkey</span></div><div class="line"> </div><div class="line"><span class="comment">// 根据需要使用HTablePool</span></div><div class="line"><span class="comment">// 注意HTable对象不是线程安全的</span></div></pre></td></tr></table></figure>

<p>建表时的一些优化：</p>
<ol>
<li>尽量只有一个列族</li>
<li>预分区</li>
<li>列族和列的名字尽量短</li>
<li>尽量开启snappy/lzo压缩</li>
<li>开启bloom filter（0.98默认会开启ROW级别的，如果有特殊需求可以开启ROWCOL级别的）</li>
</ol>
<h1 id="服务端比较重要的一些配置项">服务端比较重要的一些配置项</h1>
<p>比较容易出问题的一些配置。</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>zookeeper.session.timeout</td>
<td>zk客户端的超时设置，也受服务端限制</td>
</tr>
<tr>
<td>hbase.regionserver.handler.count</td>
<td>rpc handler用于处理客户端读写。当每次RPC操作数据量较小时，这个数字可以设的大一点，否则可能对regionserver产生较大内存压力，进而造成GC问题。要结合自己的内存大小来设置。</td>
</tr>
<tr>
<td>hbase.regionserver.maxlogs</td>
<td>每个regionserver保存的日志文件数量，不要太大，不然回放日志时间很长</td>
</tr>
<tr>
<td>hbase.regionserver.hlog.blocksize</td>
<td>每个hlog日志文件的大小，不要太大，不然回放日志时间很长</td>
</tr>
<tr>
<td>hbase.hstore.blockingStoreFiles</td>
<td>当某个store中storefile数量超过这个值时，整个region就会阻止继续写入，等待后台合并</td>
</tr>
<tr>
<td>hbase.hstore.blockingWaitTime</td>
<td>跟上一个配置相关。每次阻止写入多长时间。</td>
</tr>
<tr>
<td>hbase.hregion.memstore.block.multiplier</td>
<td>如果客户端写入过快来不及flush，memstore最多可以增加到几倍，之后会阻止写入</td>
</tr>
<tr>
<td>hbase.hregion.max.filesize</td>
<td>每个region的大小，超过这个大小会触发自动split，只有当hbase.regionserver.region.split.policy设置为ConstantSizeRegionSplitPolicy时才有效</td>
</tr>
<tr>
<td>hbase.regionserver.regionSplitLimit</td>
<td>当一个regionserver上region数量达到这个数字，就不会自动split了。但还是可以手动触发。</td>
</tr>
<tr>
<td>hbase.hregion.majorcompaction</td>
<td>major compact的周期，设为0可以关闭自动major compact。跟compaction policy有关，默认是RatioBasedCompactionPolicy</td>
</tr>
<tr>
<td>hbase.hstore.compaction.min</td>
<td>每次minor compact，最少选择多少个storefile？</td>
</tr>
<tr>
<td>hbase.hstore.compaction.max</td>
<td>每次minor compact，最多选择多少个storefile？</td>
</tr>
<tr>
<td>hbase.hstore.compaction.max.size</td>
<td>minor compact时，大于这大小的storefile会被排除</td>
</tr>
<tr>
<td>hbase.regionserver.thread.compaction.large</td>
<td>compact时large线程池的大小</td>
</tr>
<tr>
<td>hbase.regionserver.thread.compaction.small</td>
<td>compact时small线程池的大小</td>
</tr>
<tr>
<td>hbase.regionserver.thread.compaction.throttle</td>
<td>如果一次compact（不分minor/major）处理的数据量大于这个值，进入large线程池；否则进入small线程池。</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p>近日重看了《HBase权威指南》，结合着0.98.8的代码，总结一些知识点。<br>由于hbase版本更新很快，而且每个版本变化都很大，本文不一定适用于其他版本。<br>我们是0.94和0.98混着用的，也可能有些0.94的知识点混在里面。。。</p>
<p>话说，<code>hadoop</code>还是<code>Hadoop</code>我都觉得挺正常，但<code>hbase</code>就不如<code>HBase</code>顺眼。。。</p>
]]>
    
    </summary>
    
      <category term="hbase" scheme="http://jxy.me/tags/hbase/"/>
    
      <category term="豆知识" scheme="http://jxy.me/tags/%E8%B1%86%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2.5.2中queueMaxAppsDefault的一个bug]]></title>
    <link href="http://jxy.me/2015/07/06/scheduler-diff-2-5-2/"/>
    <id>http://jxy.me/2015/07/06/scheduler-diff-2-5-2/</id>
    <published>2015-07-06T02:51:09.000Z</published>
    <updated>2015-09-03T15:42:14.000Z</updated>
    <content type="html"><![CDATA[<p>升级hadoop 2.5.2过程中碰到的一个问题。<br>很难说是个bug，更像是功能上的一些变化，社区也没有相关jira。<br>看看代码研究下。<br>调度器的基本概念见<a href="/2015/04/30/yarn-resource-scheduler/">我以前的文章</a>。</p>
<a id="more"></a>
<h1 id="症状">症状</h1>
<p>在我们的fair-scheduler.xml中一直有这样一个属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">queueMaxAppsDefault</span>&gt;</span>2<span class="tag">&lt;/<span class="title">queueMaxAppsDefault</span>&gt;</span></div></pre></td></tr></table></figure>

<p>本意是将默认值设小一点，防止一些意外情况。在2.2.0中时，一直正常使用。<br>但升级到2.5.2后，发现这个设置变成了全局的，变成了整个集群只能并发执行2个任务。<br>删掉这个属性后就正常了。</p>
<p>我们的队列配置类似这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">allocations</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">queue</span> <span class="attribute">name</span>=<span class="value">"a"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">minResources</span>&gt;</span>10240 mb, 10 vcores<span class="tag">&lt;/<span class="title">minResources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">maxResources</span>&gt;</span>409600 mb, 200 vcores<span class="tag">&lt;/<span class="title">maxResources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">maxRunningApps</span>&gt;</span>20<span class="tag">&lt;/<span class="title">maxRunningApps</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">weight</span>&gt;</span>1.0<span class="tag">&lt;/<span class="title">weight</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">schedulingPolicy</span>&gt;</span>fair<span class="tag">&lt;/<span class="title">schedulingPolicy</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">aclSubmitApps</span>&gt;</span>a<span class="tag">&lt;/<span class="title">aclSubmitApps</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">aclAdministerApps</span>&gt;</span>hadoop,yarn,a<span class="tag">&lt;/<span class="title">aclAdministerApps</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">queue</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">queue</span> <span class="attribute">name</span>=<span class="value">"b"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">minResources</span>&gt;</span>10240 mb, 10 vcores<span class="tag">&lt;/<span class="title">minResources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">maxResources</span>&gt;</span>409600 mb, 200 vcores<span class="tag">&lt;/<span class="title">maxResources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">maxRunningApps</span>&gt;</span>20<span class="tag">&lt;/<span class="title">maxRunningApps</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">weight</span>&gt;</span>1.5<span class="tag">&lt;/<span class="title">weight</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">schedulingPolicy</span>&gt;</span>fair<span class="tag">&lt;/<span class="title">schedulingPolicy</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">aclSubmitApps</span>&gt;</span>b<span class="tag">&lt;/<span class="title">aclSubmitApps</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">aclAdministerApps</span>&gt;</span>b,hadoop,yarn<span class="tag">&lt;/<span class="title">aclAdministerApps</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">queue</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">allocations</span>&gt;</span></div></pre></td></tr></table></figure>

<p>队列结构只有2层。一个root队列，其他都是LeafQueue。并且为每个LeafQueue单独配置了maxRunningApps属性。</p>
<h1 id="2-2-0的代码">2.2.0的代码</h1>
<p>2.2.0中，队列相关配置由QueueManager类管理。包括加载fair-scheduler.xml、更新配置等等。</p>
<p>FairScheduler中有一个线程UpdateThread，默认每0.5秒调用一次update方法：</p>
<figure class="highlight java"><figcaption><span>FairScheduler.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">update</span>() {</div><div class="line">       <span class="comment">// 检查是否要重新加载fair-scheduler.xml</span></div><div class="line">	queueMgr.reloadAllocsIfNecessary(); <span class="comment">// Relaod alloc file</span></div><div class="line">	<span class="comment">// 关键的一个方法，计算每个队列是否超出了资源限制、app数量限制</span></div><div class="line">	<span class="comment">// 如果已经超出限制，所有的app的runnable属性会被设为false，不会再分配container</span></div><div class="line">	updateRunnability(); <span class="comment">// Set job runnability based on user/queue limits</span></div><div class="line"></div><div class="line">	<span class="comment">// 接下来的是抢占式调度的一些逻辑，不是本文重点</span></div><div class="line">	updatePreemptionVariables(); <span class="comment">// Determine if any queues merit preemption</span></div><div class="line">	FSQueue rootQueue = queueMgr.getRootQueue();</div><div class="line"></div><div class="line">	<span class="comment">// Recursively update demands for all queues</span></div><div class="line">	rootQueue.updateDemand();</div><div class="line"></div><div class="line">	rootQueue.setFairShare(clusterCapacity);</div><div class="line">	<span class="comment">// Recursively compute fair shares for all queues</span></div><div class="line">	<span class="comment">// and update metrics</span></div><div class="line">	rootQueue.recomputeShares();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>继续看updateRunnability方法：</p>
<figure class="highlight java"><figcaption><span>FairScheduler.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRunnability</span>() {</div><div class="line">	List&lt;AppSchedulable&gt; apps = <span class="keyword">new</span> ArrayList&lt;AppSchedulable&gt;();</div><div class="line"></div><div class="line">	<span class="comment">// Start by marking everything as not runnable</span></div><div class="line">	<span class="comment">// 注意这里，这里只处理了所有leafQueue，对于parentQueue，没有考虑maxApp限制</span></div><div class="line">	<span class="keyword">for</span> (FSLeafQueue leafQueue : queueMgr.getLeafQueues()) {</div><div class="line">		<span class="keyword">for</span> (AppSchedulable a : leafQueue.getAppSchedulables()) {</div><div class="line">			a.setRunnable(<span class="keyword">false</span>);</div><div class="line">			apps.add(a);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">// Create a list of sorted jobs in order of start time and priority</span></div><div class="line">	Collections.sort(apps, <span class="keyword">new</span> FifoAppComparator());</div><div class="line">	<span class="comment">// Mark jobs as runnable in order of start time and priority, until</span></div><div class="line">	<span class="comment">// user or queue limits have been reached.</span></div><div class="line">	Map&lt;String, Integer&gt; userApps = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</div><div class="line">	Map&lt;String, Integer&gt; queueApps = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (AppSchedulable app : apps) {</div><div class="line">		String user = app.getApp().getUser();</div><div class="line">		String queue = app.getApp().getQueueName();</div><div class="line">		<span class="keyword">int</span> userCount = userApps.containsKey(user) ? userApps.get(user) : <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> queueCount = queueApps.containsKey(queue) ? queueApps</div><div class="line">				.get(queue) : <span class="number">0</span>;</div><div class="line">		<span class="comment">// 这里获得的queueMaxApps就是我们在xml文件里为每个队列配置的maxRunningApps属性</span></div><div class="line">		<span class="comment">// 如果某个队列没有配置，就返回queueMaxAppsDefault</span></div><div class="line">		<span class="keyword">if</span> (userCount &lt; queueMgr.getUserMaxApps(user)</div><div class="line">				&& queueCount &lt; queueMgr.getQueueMaxApps(queue)) {</div><div class="line">			userApps.put(user, userCount + <span class="number">1</span>);</div><div class="line">			queueApps.put(queue, queueCount + <span class="number">1</span>);</div><div class="line">			app.setRunnable(<span class="keyword">true</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>只有当NM发来心跳时才能分配container，分配过程是一次DFS。<br>当一个leafQueue下所有app的runnable都是false时，不会分配任何container。<br>具体代码不列了。见FairScheduler.nodeUpdate和FSParentQueue.assignContainer。</p>
<p>可见，对于root队列，FairScheduler没有检查任何限制条件。</p>
<h1 id="2-5-2的代码">2.5.2的代码</h1>
<p>2.5.2的FairScheduler代码变化非常大。我目前看到的几个：</p>
<ol>
<li>处理fair-scheduler.xml的逻辑从QueueMananger类剥离，独立作为一个service：AllocationFileLoaderService。</li>
<li>FairScheduler handle的事件增加了很多APP_ATTEMPT相关的，见handle方法。相应的app提交过程也变化了。</li>
<li>maxApp相关限制的判断独立为一个类：MaxRunningAppsEnforcer。</li>
</ol>
<p>还有很多变化是为了配合RM HA的。</p>
<p>提交app后会触发addApplicationAttempt方法（相关的事件链不列了。这个方法也是2.5.2新增的）</p>
<figure class="highlight java"><figcaption><span>FairScheduler.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addApplicationAttempt</span>(</div><div class="line">      ApplicationAttemptId applicationAttemptId,</div><div class="line">      <span class="keyword">boolean</span> transferStateFromPreviousAttempt,</div><div class="line">      <span class="keyword">boolean</span> shouldNotifyAttemptAdded) {</div><div class="line">    <span class="comment">// 省略</span></div><div class="line">    <span class="comment">// 关键在这里，提交app时会判断这个app是否runnable</span></div><div class="line">    <span class="comment">// runnable=false的app会一直保持在ACCEPTED状态，不会分配任何container（包括AM Container）</span></div><div class="line">    <span class="keyword">boolean</span> runnable = maxRunningEnforcer.canAppBeRunnable(queue, user);</div><div class="line">    <span class="comment">// 将app加到队列中，会更改app的状态</span></div><div class="line">    queue.addApp(attempt, runnable);</div><div class="line">    <span class="comment">// 下面是一些统计信息</span></div><div class="line">    <span class="keyword">if</span> (runnable) {</div><div class="line">      maxRunningEnforcer.trackRunnableApp(attempt);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">      maxRunningEnforcer.trackNonRunnableApp(attempt);</div><div class="line">    }</div><div class="line">    <span class="comment">// 省略</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>继续看canAppBeRunnable方法：</p>
<figure class="highlight java"><figcaption><span>MaxRunningAppsEnforcer.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAppBeRunnable</span>(FSQueue queue, String user) {</div><div class="line">  AllocationConfiguration allocConf = scheduler.getAllocationConfiguration();</div><div class="line">  <span class="comment">// 获得当前用户RUNNING的app数量</span></div><div class="line">  Integer userNumRunnable = usersNumRunnableApps.get(user);</div><div class="line">  <span class="keyword">if</span> (userNumRunnable == <span class="keyword">null</span>) {</div><div class="line">    userNumRunnable = <span class="number">0</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">if</span> (userNumRunnable &gt;= allocConf.getUserMaxApps(user)) {</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line">  <span class="comment">// Check queue and all parent queues</span></div><div class="line">  <span class="comment">// 关键在这里，会一直回溯到root队列，判断appMax</span></div><div class="line">  <span class="comment">// 而我们对root队列没有单独配置maxRunningApps属性，就会返回queueMaxAppsDefault</span></div><div class="line">  <span class="keyword">while</span> (queue != <span class="keyword">null</span>) {</div><div class="line">    <span class="keyword">int</span> queueMaxApps = allocConf.getQueueMaxApps(queue.getName());</div><div class="line">    <span class="keyword">if</span> (queue.getNumRunnableApps() &gt;= queueMaxApps) {</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">    queue = queue.getParent();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可见在2.5.2中，maxApp的限制对所有队列都生效，不区分ParentQueue和LeafQueue。<br>所以造成了整个集群只能运行2个任务的情况。</p>
<h1 id="总结">总结</h1>
<p>很难说那种方式更好。<br>2.5.2里的FairScheduler，有点像CapacityScheduler了，父队列会限制子队列。<br>而2.2.0里的FairScheduler，父队列和子队列基本没关系（除了ACL）。<br>之前测试的时候，没有测过并发执行多个任务，直到线上升级才发现这个问题，也是考虑不周。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>升级hadoop 2.5.2过程中碰到的一个问题。<br>很难说是个bug，更像是功能上的一些变化，社区也没有相关jira。<br>看看代码研究下。<br>调度器的基本概念见<a href="/2015/04/30/yarn-resource-scheduler/">我以前的文章</a>。</p>
]]>
    
    </summary>
    
      <category term="hadoop" scheme="http://jxy.me/tags/hadoop/"/>
    
      <category term="fair scheduler" scheme="http://jxy.me/tags/fair-scheduler/"/>
    
      <category term="resourcemanager" scheme="http://jxy.me/tags/resourcemanager/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[闲言碎语]]></title>
    <link href="http://jxy.me/2015/06/27/some-gossip/"/>
    <id>http://jxy.me/2015/06/27/some-gossip/</id>
    <published>2015-06-27T06:34:13.000Z</published>
    <updated>2015-09-03T15:42:14.000Z</updated>
    <content type="html"><![CDATA[<p>一些想法，一些牢骚。<br>胡言乱语，博君一笑。</p>
<a id="more"></a>
<h1 id="关于技术">关于技术</h1>
<p>我以前是一个纯粹的唯技术论者，总是觉得技术是第一位的。可能这是学院派的通病吧。<br>但工作了一段时间，看到了一些事情，深刻觉得很多时候，<strong>技术真的没那么重要</strong>。<br>一个成功的产品，需要创意、运营、市场。。。各种各样的努力，其中技术的比重很小。<br>尤其是运营，我现在越发觉得好的运营可以弥补很多其他方面的不足。</p>
<p>有哪些公司、产品，是真正把技术创新转换为成功的？<br>也许google的PageRank算是吧。<br>facebook？twitter？我觉得这是靠创意成功的。他们的技术是在体量大了之后才慢慢发展的。<br>国内的公司更不用说了。</p>
<p>有些时候，我们设计一些很复杂的架构，用一些很新的技术。能单机解决的问题偏要分布式，能用mysql解决的偏要用mongodb/hbase。这是本末倒置。<br>我宁愿初期开发一个很土的实现，后期去重构。重构的代价可能还小于初期就搞一个复杂架构。<br>而且说实话，很多产品、项目，还熬不到需要重构的那个阶段就会死掉。</p>
<p>技术也很难有高下之分。以前道听途说，觉得php很low。但那又如何？很多产品要的就是猛糙快。<br>快速出原型、快速试错、快速死亡。就像细菌的分裂一样。。。虽然个体很脆弱，但总量很大，最后总能筛选出活下来的。活下来的就值得长期培养。<br>听说现在生物实验用的菌系都是培养了好几十年的。。。</p>
<p>也只有程序员才会关心O(logN)和O(N)的区别吧。<br>老板/用户/PM根本不会关心背后用了什么技术。只要能实现相关功能，并且没有用户抱怨，就是好的。能抓住老鼠就是好猫。</p>
<p>大多数用户都是很浅薄的。一个好看的页面，比一个优秀的算法重要的多。</p>
<p>当然我也没有说技术不重要，有人说程序员要有“匠人”精神，我也赞同。<br>但不要过度。</p>
<h1 id="关于运维">关于运维</h1>
<p>运维为什么很苦逼。因为做的事情都在暗处，大多数人都看不到，没有存在感。不出事呢是应该的，出事就要背锅。<br>考核的时候，如果一直没出事，能得个平均水准的分数；一旦出事，就只能呵呵了。<br>说的直白点，就是靠天吃饭。</p>
<p>那怎么办？搞天气预报啊。<br>各种监控系统、运维工具、报警工具，就是干这个的。<br>但开发维护这些系统需要一个庞大的团队，不是一两个人能搞的定的。<br>而且很多时候要定制开发，而不是只用一些通用的工具。</p>
<p>这跟公司文化也有关。有很多人觉得运维很简单，随便找人搞搞就行，或者找个开发兼职搞下。<br>很多小公司都没有专职的运维吧。<br>没有对运维投入人力物力，却提出很高的运维标准，比如N个9的可用率保证，我能呵呵么。</p>
<p>在RDBMS的年代，一个NB的DBA可以搞定一切。<br>但对hadoop而言，即使是单纯的运维也必须要看代码改代码。</p>
<p>改变这种情况需要自上而下的推动，可惜我无能为力。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一些想法，一些牢骚。<br>胡言乱语，博君一笑。</p>
]]>
    
    </summary>
    
      <category term="杂谈" scheme="http://jxy.me/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
